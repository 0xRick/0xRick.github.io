<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Binary Exploitation - Buffer Overflow Explained in Detail | 0xRick Owned Root !</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Binary Exploitation - Buffer Overflow Explained in Detail" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction First of all I’m writing this to help anyone who wants to learn about buffer overflow attacks, the basics to understand this can be confusing and it took me some time to understand it myself so I’ll be covering some basics in this article, what I’m going to talk about is what is a buffer , what is a stack and what are the memory addresses and we will take a look at the application memory structure , what is a buffer overflow and why does it happen then I’ll show a really basic and simple example for a buffer overflow (protostar stack0) Buffer So what’s a buffer ? Simply a buffer is a memory place or location which is used by a running program. This memory location is used to store some temporary data that is being used by the program. So for example if we have a simple program that asks the user to enter his name and stores it in a variable called username then it prints “Hello username “ . For example if we run the program and enter username as “Rick”. The word “Rick” is stored in the buffer until the program executes the print command and it retrieves the given username “Rick” from the buffer to output the result : “Hello Rick” Our example written in c will be like this #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n&quot;, username); return(0); } Break Down : int main() This defines the main function char username[20] This is where we specify the variable name but the most important thing about this line is char .... [20] this is where we specify the buffer for that variable , and i assigned it as 20 chars The rest of the code takes the user input then prints it. printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n, username&quot;); So when we compile and run this program we get the output as expected right ? Now before we talk about the buffer overflow we need to understand how the application memory works Application Memory , Stack and Memory Addresses So how does the application memory look like and what’s a stack ? A stack is a memory buffer that is used to store the functions of the program and local variables. To demonstrate this, we will take a look at this image. First We have the code and this is the source code of the program. This has the main instructions of the program. After that we have the buffer where the global variables are stored, The difference between a local variable and a global variable is that a local variable is limited to a certain function. It’s defined in that function and can be only called in that function but a global variable is either defined in the main function or defined outside a function and this type of variables can be called anywhere. Then we have the Stack and this is the important part of the memory for us because this is where the buffer overflow happens. This is the place where local variable and function calls are stored. Last thing is Heap and this is a dynamic memory allocation. Now we know what does the application memory look like and what is the stack but what are memory addresses ? Basically when a program is compiled and executed , All the instructions of the program take place in the application memory and an address is assigned to them , This address is usually in the format of hexadecimal bytes. So if you disassemble a program and look at it you’ll find the memory addresses , something like this : Why Do Buffer Overflows Happen ? Now we know what is a buffer and we took a deeper look on the memory construction. Now you might already figured out why and when does a buffer overflow happen. A buffer overflow happens when the length of the data entered exceeds the buffer limit and this causes the program to write data outside the allocated buffer area and may overwrite some parts of the memory that were used to hold data used by the program which makes it unavailable and causes the program to crash. To demonstrate this we will go back to our first example. #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n&quot;, username); printf(&quot;Program exited normally&quot;); return(0); } We will add a last line to print the sentence “program exited noramlly” just for demonstration purposes Now the program should ask us for username then print “Hello username” then print “program exited normally” and exits. The buffer for holding the username value is set to 20 chars , it’s good as long as the username length is less than 20 chars. But if the entered data is more than 20 chars length the program will crash because some data will be overwritten outside the buffer causing some parts of the program to be corrupted. in our case this will be the part which prints “program exited normally” First let’s run the program and enter the name as Rick The program exits normally. Now let’s run it again and enter the name as 30 A’s We get “Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA” printed then we don’t see “program exited normally” and we get a segmentation fault error. That happened because we entered 10 extra chars, The program only expected 20 or less. Those extra “AAAAAAAAAA” exceeded the 20 chars buffer and overwrited other data (The print instruction which prints “program exited normally”) which caused a segmentation fault because the program is corrupted. Examining Buffer Overflows with gdb Let’s take a deeper look at how this is happening with gdb (gnu debugger). We will write another program that creates a variable called “whatever” then it copies what we give it and put it in that variable. And we will assign the buffer for that variable to be 20 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char** argv) { char whatever[20]; strcpy(whatever, argv[1]); return 0; } Breakdown : int main(int argc, char** argv) This defines the main function and it’s arguments char whatever[20]; This creates the variable and gives it the name “whatever” and assigns its buffer to 20 strcpy(whatever, argv[1]); This copies our input and puts it into our variable “whatever” return 0; And this is our return address Now let’s run the program inside gdb and test it. The input was aaaaa which is less than 20 chars so the program exited normally and everything is good Now let’s throw an input more that 20 chars. We get a segmentation fault because our return address is overwritten and the program couldn’t continue. To show how are these addresses overwritten let’s input any hex value , something like \x12 for 50 times. Then let’s look at the registers. We see that most of the memory addresses are overwritten with 12 Why Are Buffer Overflows Dangerous ? Now you might ask yourself , How will that be harmful ? A buffer overflow is dangerous when the vulnerable binary or program is a setuid binary , If you don’t know what setuid binaries are, read the provided link, but in general They are programs that run with capabilities of another user (usually root) , But when that program is vulnerable to a buffer overflow it’s not a good thing anymore. Since we can pass the buffer and overwrite the program then we can overwrite it with a payload that executes a system call and spawns a root shell I will do more write ups about buffer overflows and other binary exploitation techniques, for now I will start with protostar. There are also some cool boxes on Hack The box that required buffer overflows and binary exploitation to gain root privileges but they’re active right now so I’ll publish my write ups about these boxes as soon as they retire of course. In the meantime, you can read my other Hack The Box write-ups ! Protostar Stack0 Now let’s do a simple practical example. You can download protostar from here I will solve the first level which is stack0 for this article then I will solve the rest of the levels in other write-ups. We’re given the source code of the program : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;); } else { printf(&quot;Try again?\n&quot;); } } From the code we can understand that the program has a variable called “buffer” and assigns a buffer of 64 chars to it. Then there’s another variable called modified and it’s value is 0. gets(buffer) allows us to input the value of “buffer” variable.Then there’s an if statement that checks if the value of “modified” variable is not equal to 0. If it’s not equal to zero it will print “you have changed the ‘modified’ variable” but if it’s still equal to 0 it will print “Try again?”. So our mission is to change the value of that variable called “modified” As long as the entered data is less than 64 chars everything will run as intended. But if the input exceeds the buffer it will overwrite the value of “modified” variable. We already know that the buffer is 64 chars so we just need to input 65 chars or more and the variable value will change. Let’s test that out. We execute the stack0 bin and we see the output “try again?” Let’s throw 65 “A”s and see the output. python -c &quot;print (&#39;A&#39; * 65)&quot; | ./stack0 And we have successfuly overwritten the variable’s value ! :D That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter @Ahm3d_H3sham Thanks for reading. Next Binary Exploitation article : Buffer Overflow Examples, Overwriting a variable value on the stack - Protostar Stack1 , Stack2" />
<meta property="og:description" content="Introduction First of all I’m writing this to help anyone who wants to learn about buffer overflow attacks, the basics to understand this can be confusing and it took me some time to understand it myself so I’ll be covering some basics in this article, what I’m going to talk about is what is a buffer , what is a stack and what are the memory addresses and we will take a look at the application memory structure , what is a buffer overflow and why does it happen then I’ll show a really basic and simple example for a buffer overflow (protostar stack0) Buffer So what’s a buffer ? Simply a buffer is a memory place or location which is used by a running program. This memory location is used to store some temporary data that is being used by the program. So for example if we have a simple program that asks the user to enter his name and stores it in a variable called username then it prints “Hello username “ . For example if we run the program and enter username as “Rick”. The word “Rick” is stored in the buffer until the program executes the print command and it retrieves the given username “Rick” from the buffer to output the result : “Hello Rick” Our example written in c will be like this #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n&quot;, username); return(0); } Break Down : int main() This defines the main function char username[20] This is where we specify the variable name but the most important thing about this line is char .... [20] this is where we specify the buffer for that variable , and i assigned it as 20 chars The rest of the code takes the user input then prints it. printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n, username&quot;); So when we compile and run this program we get the output as expected right ? Now before we talk about the buffer overflow we need to understand how the application memory works Application Memory , Stack and Memory Addresses So how does the application memory look like and what’s a stack ? A stack is a memory buffer that is used to store the functions of the program and local variables. To demonstrate this, we will take a look at this image. First We have the code and this is the source code of the program. This has the main instructions of the program. After that we have the buffer where the global variables are stored, The difference between a local variable and a global variable is that a local variable is limited to a certain function. It’s defined in that function and can be only called in that function but a global variable is either defined in the main function or defined outside a function and this type of variables can be called anywhere. Then we have the Stack and this is the important part of the memory for us because this is where the buffer overflow happens. This is the place where local variable and function calls are stored. Last thing is Heap and this is a dynamic memory allocation. Now we know what does the application memory look like and what is the stack but what are memory addresses ? Basically when a program is compiled and executed , All the instructions of the program take place in the application memory and an address is assigned to them , This address is usually in the format of hexadecimal bytes. So if you disassemble a program and look at it you’ll find the memory addresses , something like this : Why Do Buffer Overflows Happen ? Now we know what is a buffer and we took a deeper look on the memory construction. Now you might already figured out why and when does a buffer overflow happen. A buffer overflow happens when the length of the data entered exceeds the buffer limit and this causes the program to write data outside the allocated buffer area and may overwrite some parts of the memory that were used to hold data used by the program which makes it unavailable and causes the program to crash. To demonstrate this we will go back to our first example. #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\n&quot;, username); printf(&quot;Program exited normally&quot;); return(0); } We will add a last line to print the sentence “program exited noramlly” just for demonstration purposes Now the program should ask us for username then print “Hello username” then print “program exited normally” and exits. The buffer for holding the username value is set to 20 chars , it’s good as long as the username length is less than 20 chars. But if the entered data is more than 20 chars length the program will crash because some data will be overwritten outside the buffer causing some parts of the program to be corrupted. in our case this will be the part which prints “program exited normally” First let’s run the program and enter the name as Rick The program exits normally. Now let’s run it again and enter the name as 30 A’s We get “Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA” printed then we don’t see “program exited normally” and we get a segmentation fault error. That happened because we entered 10 extra chars, The program only expected 20 or less. Those extra “AAAAAAAAAA” exceeded the 20 chars buffer and overwrited other data (The print instruction which prints “program exited normally”) which caused a segmentation fault because the program is corrupted. Examining Buffer Overflows with gdb Let’s take a deeper look at how this is happening with gdb (gnu debugger). We will write another program that creates a variable called “whatever” then it copies what we give it and put it in that variable. And we will assign the buffer for that variable to be 20 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char** argv) { char whatever[20]; strcpy(whatever, argv[1]); return 0; } Breakdown : int main(int argc, char** argv) This defines the main function and it’s arguments char whatever[20]; This creates the variable and gives it the name “whatever” and assigns its buffer to 20 strcpy(whatever, argv[1]); This copies our input and puts it into our variable “whatever” return 0; And this is our return address Now let’s run the program inside gdb and test it. The input was aaaaa which is less than 20 chars so the program exited normally and everything is good Now let’s throw an input more that 20 chars. We get a segmentation fault because our return address is overwritten and the program couldn’t continue. To show how are these addresses overwritten let’s input any hex value , something like \x12 for 50 times. Then let’s look at the registers. We see that most of the memory addresses are overwritten with 12 Why Are Buffer Overflows Dangerous ? Now you might ask yourself , How will that be harmful ? A buffer overflow is dangerous when the vulnerable binary or program is a setuid binary , If you don’t know what setuid binaries are, read the provided link, but in general They are programs that run with capabilities of another user (usually root) , But when that program is vulnerable to a buffer overflow it’s not a good thing anymore. Since we can pass the buffer and overwrite the program then we can overwrite it with a payload that executes a system call and spawns a root shell I will do more write ups about buffer overflows and other binary exploitation techniques, for now I will start with protostar. There are also some cool boxes on Hack The box that required buffer overflows and binary exploitation to gain root privileges but they’re active right now so I’ll publish my write ups about these boxes as soon as they retire of course. In the meantime, you can read my other Hack The Box write-ups ! Protostar Stack0 Now let’s do a simple practical example. You can download protostar from here I will solve the first level which is stack0 for this article then I will solve the rest of the levels in other write-ups. We’re given the source code of the program : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;); } else { printf(&quot;Try again?\n&quot;); } } From the code we can understand that the program has a variable called “buffer” and assigns a buffer of 64 chars to it. Then there’s another variable called modified and it’s value is 0. gets(buffer) allows us to input the value of “buffer” variable.Then there’s an if statement that checks if the value of “modified” variable is not equal to 0. If it’s not equal to zero it will print “you have changed the ‘modified’ variable” but if it’s still equal to 0 it will print “Try again?”. So our mission is to change the value of that variable called “modified” As long as the entered data is less than 64 chars everything will run as intended. But if the input exceeds the buffer it will overwrite the value of “modified” variable. We already know that the buffer is 64 chars so we just need to input 65 chars or more and the variable value will change. Let’s test that out. We execute the stack0 bin and we see the output “try again?” Let’s throw 65 “A”s and see the output. python -c &quot;print (&#39;A&#39; * 65)&quot; | ./stack0 And we have successfuly overwritten the variable’s value ! :D That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter @Ahm3d_H3sham Thanks for reading. Next Binary Exploitation article : Buffer Overflow Examples, Overwriting a variable value on the stack - Protostar Stack1 , Stack2" />
<link rel="canonical" href="http://localhost:4000/binary-exploitation/bof1/" />
<meta property="og:url" content="http://localhost:4000/binary-exploitation/bof1/" />
<meta property="og:site_name" content="0xRick Owned Root !" />
<meta property="og:image" content="http://localhost:4000/binary-exploitation/BOF/0.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-19T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"Introduction First of all I’m writing this to help anyone who wants to learn about buffer overflow attacks, the basics to understand this can be confusing and it took me some time to understand it myself so I’ll be covering some basics in this article, what I’m going to talk about is what is a buffer , what is a stack and what are the memory addresses and we will take a look at the application memory structure , what is a buffer overflow and why does it happen then I’ll show a really basic and simple example for a buffer overflow (protostar stack0) Buffer So what’s a buffer ? Simply a buffer is a memory place or location which is used by a running program. This memory location is used to store some temporary data that is being used by the program. So for example if we have a simple program that asks the user to enter his name and stores it in a variable called username then it prints “Hello username “ . For example if we run the program and enter username as “Rick”. The word “Rick” is stored in the buffer until the program executes the print command and it retrieves the given username “Rick” from the buffer to output the result : “Hello Rick” Our example written in c will be like this #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\\n&quot;, username); return(0); } Break Down : int main() This defines the main function char username[20] This is where we specify the variable name but the most important thing about this line is char .... [20] this is where we specify the buffer for that variable , and i assigned it as 20 chars The rest of the code takes the user input then prints it. printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\\n, username&quot;); So when we compile and run this program we get the output as expected right ? Now before we talk about the buffer overflow we need to understand how the application memory works Application Memory , Stack and Memory Addresses So how does the application memory look like and what’s a stack ? A stack is a memory buffer that is used to store the functions of the program and local variables. To demonstrate this, we will take a look at this image. First We have the code and this is the source code of the program. This has the main instructions of the program. After that we have the buffer where the global variables are stored, The difference between a local variable and a global variable is that a local variable is limited to a certain function. It’s defined in that function and can be only called in that function but a global variable is either defined in the main function or defined outside a function and this type of variables can be called anywhere. Then we have the Stack and this is the important part of the memory for us because this is where the buffer overflow happens. This is the place where local variable and function calls are stored. Last thing is Heap and this is a dynamic memory allocation. Now we know what does the application memory look like and what is the stack but what are memory addresses ? Basically when a program is compiled and executed , All the instructions of the program take place in the application memory and an address is assigned to them , This address is usually in the format of hexadecimal bytes. So if you disassemble a program and look at it you’ll find the memory addresses , something like this : Why Do Buffer Overflows Happen ? Now we know what is a buffer and we took a deeper look on the memory construction. Now you might already figured out why and when does a buffer overflow happen. A buffer overflow happens when the length of the data entered exceeds the buffer limit and this causes the program to write data outside the allocated buffer area and may overwrite some parts of the memory that were used to hold data used by the program which makes it unavailable and causes the program to crash. To demonstrate this we will go back to our first example. #include &lt;stdio.h&gt; int main () { char username[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, username); printf(&quot;Hello %s\\n&quot;, username); printf(&quot;Program exited normally&quot;); return(0); } We will add a last line to print the sentence “program exited noramlly” just for demonstration purposes Now the program should ask us for username then print “Hello username” then print “program exited normally” and exits. The buffer for holding the username value is set to 20 chars , it’s good as long as the username length is less than 20 chars. But if the entered data is more than 20 chars length the program will crash because some data will be overwritten outside the buffer causing some parts of the program to be corrupted. in our case this will be the part which prints “program exited normally” First let’s run the program and enter the name as Rick The program exits normally. Now let’s run it again and enter the name as 30 A’s We get “Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA” printed then we don’t see “program exited normally” and we get a segmentation fault error. That happened because we entered 10 extra chars, The program only expected 20 or less. Those extra “AAAAAAAAAA” exceeded the 20 chars buffer and overwrited other data (The print instruction which prints “program exited normally”) which caused a segmentation fault because the program is corrupted. Examining Buffer Overflows with gdb Let’s take a deeper look at how this is happening with gdb (gnu debugger). We will write another program that creates a variable called “whatever” then it copies what we give it and put it in that variable. And we will assign the buffer for that variable to be 20 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char** argv) { char whatever[20]; strcpy(whatever, argv[1]); return 0; } Breakdown : int main(int argc, char** argv) This defines the main function and it’s arguments char whatever[20]; This creates the variable and gives it the name “whatever” and assigns its buffer to 20 strcpy(whatever, argv[1]); This copies our input and puts it into our variable “whatever” return 0; And this is our return address Now let’s run the program inside gdb and test it. The input was aaaaa which is less than 20 chars so the program exited normally and everything is good Now let’s throw an input more that 20 chars. We get a segmentation fault because our return address is overwritten and the program couldn’t continue. To show how are these addresses overwritten let’s input any hex value , something like \\x12 for 50 times. Then let’s look at the registers. We see that most of the memory addresses are overwritten with 12 Why Are Buffer Overflows Dangerous ? Now you might ask yourself , How will that be harmful ? A buffer overflow is dangerous when the vulnerable binary or program is a setuid binary , If you don’t know what setuid binaries are, read the provided link, but in general They are programs that run with capabilities of another user (usually root) , But when that program is vulnerable to a buffer overflow it’s not a good thing anymore. Since we can pass the buffer and overwrite the program then we can overwrite it with a payload that executes a system call and spawns a root shell I will do more write ups about buffer overflows and other binary exploitation techniques, for now I will start with protostar. There are also some cool boxes on Hack The box that required buffer overflows and binary exploitation to gain root privileges but they’re active right now so I’ll publish my write ups about these boxes as soon as they retire of course. In the meantime, you can read my other Hack The Box write-ups ! Protostar Stack0 Now let’s do a simple practical example. You can download protostar from here I will solve the first level which is stack0 for this article then I will solve the rest of the levels in other write-ups. We’re given the source code of the program : #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&quot;you have changed the &#39;modified&#39; variable\\n&quot;); } else { printf(&quot;Try again?\\n&quot;); } } From the code we can understand that the program has a variable called “buffer” and assigns a buffer of 64 chars to it. Then there’s another variable called modified and it’s value is 0. gets(buffer) allows us to input the value of “buffer” variable.Then there’s an if statement that checks if the value of “modified” variable is not equal to 0. If it’s not equal to zero it will print “you have changed the ‘modified’ variable” but if it’s still equal to 0 it will print “Try again?”. So our mission is to change the value of that variable called “modified” As long as the entered data is less than 64 chars everything will run as intended. But if the input exceeds the buffer it will overwrite the value of “modified” variable. We already know that the buffer is 64 chars so we just need to input 65 chars or more and the variable value will change. Let’s test that out. We execute the stack0 bin and we see the output “try again?” Let’s throw 65 “A”s and see the output. python -c &quot;print (&#39;A&#39; * 65)&quot; | ./stack0 And we have successfuly overwritten the variable’s value ! :D That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter @Ahm3d_H3sham Thanks for reading. Next Binary Exploitation article : Buffer Overflow Examples, Overwriting a variable value on the stack - Protostar Stack1 , Stack2","@type":"BlogPosting","url":"http://localhost:4000/binary-exploitation/bof1/","image":"http://localhost:4000/binary-exploitation/BOF/0.png","headline":"Binary Exploitation - Buffer Overflow Explained in Detail","dateModified":"2018-12-19T00:00:00+02:00","datePublished":"2018-12-19T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/binary-exploitation/bof1/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/tagbuttons.css">
  <link rel="stylesheet" href="/assets/css/ad.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="0xRick Owned Root !" /></head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2');
</script>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">0xRick Owned Root !</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/tags/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Binary Exploitation - Buffer Overflow Explained in Detail</h1>
    <p class="post-meta">
      <h7>
        Tags: 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Linux/';">Linux</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Binary Exploitation/';">Binary Exploitation</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/Buffer Overflow/';">Buffer Overflow</button> 
        
        <button class="tagbutton" onclick="window.location.href = '/tags/c/';">c</button> 
        
      </h7>
      <br>
      <time class="dt-published" datetime="2018-12-19T00:00:00+02:00" itemprop="datePublished">Dec 19, 2018
      </time><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&placement=0xrickgithubio" id="_carbonads_js"></script>
</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <hr />

<h3 id="introduction">Introduction</h3>
<h4 id="first-of-all-im-writing-this-to-help-anyone-who-wants-to-learn-about-buffer-overflow-attacks-the-basics-to-understand-this-can-be-confusing-and-it-took-me-some-time-to-understand-it-myself-so-ill-be-covering-some-basics-in-this-article-what-im-going-to-talk-about-is-what-is-a-buffer--what-is-a-stack-and-what-are-the-memory-addresses-and-we-will-take-a-look-at-the-application-memory-structure--what-is-a-buffer-overflow-and-why-does-it-happen-then-ill-show-a-really-basic-and-simple-example-for-a-buffer-overflow-protostar-stack0">First of all I’m writing this to help anyone who wants to learn about buffer overflow attacks, the basics to understand this can be confusing and it took me some time to understand it myself so I’ll be covering some basics in this article, what I’m going to talk about is what is a buffer , what is a stack and what are the memory addresses and we will take a look at the application memory structure , what is a buffer overflow and why does it happen then I’ll show a really basic and simple example for a buffer overflow (protostar stack0)</h4>
<p><img src="/images/binary-exploitation/BOF/0.png" alt="" />
<br /></p>
<hr />

<h3 id="buffer">Buffer</h3>
<h4 id="so-whats-a-buffer--simply-a-buffer-is-a-memory-place-or-location-which-is-used-by-a-running-program-this-memory-location-is-used-to-store-some-temporary-data-that-is-being-used-by-the-program-so-for-example-if-we-have-a-simple-program-that-asks-the-user-to-enter-his-name-and-stores-it-in-a-variable-called-username-then-it-prints-hello-username---for-example-if-we-run-the-program-and-enter-username-as-rick-the-word-rick-is-stored-in-the-buffer-until-the-program-executes-the-print-command-and-it-retrieves-the-given-username-rick-from-the-buffer-to-output-the-result--hello-rick">So what’s a buffer ? Simply a buffer is a memory place or location which is used by a running program. This memory location is used to store some temporary data that is being used by the program. So for example if we have a simple program that asks the user to enter his name and stores it in a variable called <em>username</em> then it prints “Hello <em>username</em> “ . For example if we run the program and enter username as “Rick”. The word “Rick” is stored in the buffer until the program executes the print command and it retrieves the given username “Rick” from the buffer to output the result : “Hello Rick”</h4>
<p><br /></p>
<h4 id="our-example-written-in-c-will-be-like-this">Our example written in c will be like this</h4>
<p><br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main () {
   char username[20];

   printf("Enter your name: ");
   scanf("%s", username);

   printf("Hello %s\n", username);
   
   return(0);
}
</code></pre></div></div>
<p><br />
<br /></p>
<h4 id="break-down-">Break Down :</h4>
<h4 id="int-main-this-defines-the-main-function"><code class="highlighter-rouge">int main()</code> This defines the main function</h4>
<h4 id="char-username20-this-is-where-we-specify-the-variable-name-but-the-most-important-thing-about-this-line-is-char--20-this-is-where-we-specify-the-buffer-for-that-variable--and-i-assigned-it-as-20-chars"><code class="highlighter-rouge">char username[20]</code> This is where we specify the variable name but the most important thing about this line is <code class="highlighter-rouge">char .... [20]</code> this is where we specify the buffer for that variable , and i assigned it as 20 chars</h4>
<h4 id="the-rest-of-the-code-takes-the-user-input-then-prints-it">The rest of the code takes the user input then prints it.</h4>
<p><code class="highlighter-rouge">printf("Enter your name: ");</code> 
<br />
<code class="highlighter-rouge">scanf("%s", username);</code>
<br />
<code class="highlighter-rouge">printf("Hello %s\n, username");</code>
<br /></p>
<h4 id="so-when-we-compile-and-run-this-program-we-get-the-output-as-expected-right-">So when we compile and run this program we get the output as expected right ?</h4>
<p><br />
<img src="/images/binary-exploitation/BOF/1.png" alt="" /></p>
<h4 id="now-before-we-talk-about-the-buffer-overflow-we-need-to-understand-how-the-application-memory-works">Now before we talk about the buffer overflow we need to understand how the application memory works</h4>
<p><br /></p>
<hr />

<h3 id="application-memory--stack-and-memory-addresses">Application Memory , Stack and Memory Addresses</h3>
<h4 id="so-how-does-the-application-memory-look-like-and-whats-a-stack--a-stack-is-a-memory-buffer-that-is-used-to-store-the-functions-of-the-program-and-local-variables-to-demonstrate-this-we-will-take-a-look-at-this-image">So how does the application memory look like and what’s a stack ? A stack is a memory buffer that is used to store the functions of the program and local variables. To demonstrate this, we will take a look at this image.</h4>
<p><img src="/images/binary-exploitation/BOF/2.png" alt="" /></p>
<h4 id="first-we-have-the-code-and-this-is-the-source-code-of-the-program-this-has-the-main-instructions-of-the-program">First We have the code and this is the source code of the program. This has the main instructions of the program.</h4>
<h4 id="after-that-we-have-the-buffer-where-the-global-variables-are-stored">After that we have the buffer where the global variables are stored,</h4>
<h4 id="the-difference-between-a-local-variable-and-a-global-variable-is-that-a-local-variable-is-limited-to-a-certain-function-its-defined-in-that-function-and-can-be-only-called-in-that-function-but-a-global-variable-is-either-defined-in-the-main-function-or-defined-outside-a-function-and-this-type-of-variables-can-be-called-anywhere"><em>The difference between a local variable and a global variable is that a local variable is limited to a certain function. It’s defined in that function and can be only called in that function but a global variable is either defined in the main function or defined outside a function and this type of variables can be called anywhere</em>.</h4>
<h4 id="then-we-have-the-stack-and-this-is-the-important-part-of-the-memory-for-us-because-this-is-where-the-buffer-overflow-happens-this-is-the-place-where-local-variable-and-function-calls-are-stored">Then we have the Stack and this is the important part of the memory for us because this is where the buffer overflow happens. This is the place where local variable and function calls are stored.</h4>
<h4 id="last-thing-is-heap-and-this-is-a-dynamic-memory-allocation">Last thing is Heap and this is a dynamic memory allocation.</h4>
<h4 id="now-we-know-what-does-the-application-memory-look-like-and-what-is-the-stack-but-what-are-memory-addresses-">Now we know what does the application memory look like and what is the stack but what are memory addresses ?</h4>
<h4 id="basically-when-a-program-is-compiled-and-executed--all-the-instructions-of-the-program-take-place-in-the-application-memory-and-an-address-is-assigned-to-them--this-address-is-usually-in-the-format-of-hexadecimal-bytes">Basically when a program is compiled and executed , All the instructions of the program take place in the application memory and an address is assigned to them , This address is usually in the format of hexadecimal bytes.</h4>
<h4 id="so-if-you-disassemble-a-program-and-look-at-it-youll-find-the-memory-addresses--something-like-this-">So if you disassemble a program and look at it you’ll find the memory addresses , something like this :</h4>
<p><img src="/images/binary-exploitation/BOF/3.png" alt="" />
<br /></p>
<hr />

<h3 id="why-do-buffer-overflows-happen-">Why Do Buffer Overflows Happen ?</h3>
<h4 id="now-we-know-what-is-a-buffer-and-we-took-a-deeper-look-on-the-memory-construction-now-you-might-already-figured-out-why-and-when-does-a-buffer-overflow-happen-a-buffer-overflow-happens-when-the-length-of-the-data-entered-exceeds-the-buffer-limit-and-this-causes-the-program-to-write-data-outside-the-allocated-buffer-area-and-may-overwrite-some-parts-of-the-memory-that-were-used-to-hold-data-used-by-the-program-which-makes-it-unavailable-and-causes-the-program-to-crash-to-demonstrate-this-we-will-go-back-to-our-first-example">Now we know what is a buffer and we took a deeper look on the memory construction. Now you might already figured out why and when does a buffer overflow happen. A buffer overflow happens when the length of the data entered exceeds the buffer limit and this causes the program to write data outside the allocated buffer area and may overwrite some parts of the memory that were used to hold data used by the program which makes it unavailable and causes the program to crash. To demonstrate this we will go back to our first example.</h4>
<p><br />
<br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main () {
   char username[20];

   printf("Enter your name: ");
   scanf("%s", username);

   printf("Hello %s\n", username);
   printf("Program exited normally");
   return(0);
}
</code></pre></div></div>
<h4 id="we-will-add-a-last-line-to-print-the-sentence-program-exited-noramlly-just-for-demonstration-purposes">We will add a last line to print the sentence “program exited noramlly” just for demonstration purposes</h4>
<h4 id="now-the-program-should-ask-us-for-username-then-print-hello-username-then-print-program-exited-normally-and-exits-the-buffer-for-holding-the-username-value-is-set-to-20-chars--its-good-as-long-as-the-username-length-is-less-than-20-chars-but-if-the-entered-data-is-more-than-20-chars-length-the-program-will-crash-because-some-data-will-be-overwritten-outside-the-buffer-causing-some-parts-of-the-program-to-be-corrupted-in-our-case-this-will-be-the-part-which-prints-program-exited-normally">Now the program should ask us for username then print “Hello <em>username</em>” then print “program exited normally” and exits. The buffer for holding the username value is set to 20 chars , it’s good as long as the username length is less than 20 chars. But if the entered data is more than 20 chars length the program will crash because some data will be overwritten outside the buffer causing some parts of the program to be corrupted. in our case this will be the part which prints “program exited normally”</h4>
<h4 id="first-lets-run-the-program-and-enter-the-name-as-rick">First let’s run the program and enter the name as Rick</h4>
<p><img src="/images/binary-exploitation/BOF/4.png" alt="" /></p>
<h4 id="the-program-exits-normally">The program exits normally.</h4>
<h4 id="now-lets-run-it-again-and-enter-the-name-as-30-as">Now let’s run it again and enter the name as 30 A’s</h4>
<p><img src="/images/binary-exploitation/BOF/5.png" alt="" /></p>
<h4 id="we-get-hello-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-printed-then-we-dont-see-program-exited-normally-and-we-get-a-segmentation-fault-error-that-happened-because-we-entered-10-extra-chars-the-program-only-expected-20-or-less-those-extra-aaaaaaaaaa-exceeded-the-20-chars-buffer-and-overwrited-other-data-the-print-instruction-which-prints-program-exited-normally-which-caused-a-segmentation-fault-because-the-program-is-corrupted">We get “Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA” printed then we don’t see “program exited normally” and we get a segmentation fault error. That happened because we entered 10 extra chars, The program only expected 20 or less. Those extra “AAAAAAAAAA” exceeded the 20 chars buffer and overwrited other data (The print instruction which prints “program exited normally”) which caused a segmentation fault because the program is corrupted.</h4>
<p><br /></p>
<hr />

<h3 id="examining-buffer-overflows-with-gdb">Examining Buffer Overflows with gdb</h3>
<h4 id="lets-take-a-deeper-look-at-how-this-is-happening-with-gdb-gnu-debugger">Let’s take a deeper look at how this is happening with gdb (gnu debugger).</h4>
<h4 id="we-will-write-another-program-that-creates-a-variable-called-whatever-then-it-copies-what-we-give-it-and-put-it-in-that-variable-and-we-will-assign-the-buffer-for-that-variable-to-be-20">We will write another program that creates a variable called “whatever” then it copies what we give it and put it in that variable. And we will assign the buffer for that variable to be 20</h4>
<p><br />
<br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char** argv)
{
	char whatever[20];
	strcpy(whatever, argv[1]);

	return 0;
}
</code></pre></div></div>
<h4 id="breakdown-">Breakdown :</h4>
<h4 id="int-mainint-argc-char-argv-this-defines-the-main-function-and-its-arguments"><code class="highlighter-rouge">int main(int argc, char** argv)</code> This defines the main function and it’s arguments</h4>
<h4 id="char-whatever20-this-creates-the-variable-and-gives-it-the-name-whatever-and-assigns-its-buffer-to-20"><code class="highlighter-rouge">char whatever[20];</code> This creates the variable and gives it the name “whatever” and assigns its buffer to 20</h4>
<h4 id="strcpywhatever-argv1-this-copies-our-input-and-puts-it-into-our-variable-whatever"><code class="highlighter-rouge">strcpy(whatever, argv[1]);</code> This copies our input and puts it into our variable “whatever”</h4>
<h4 id="return-0-and-this-is-our-return-address"><code class="highlighter-rouge">return 0;</code> And this is our return address</h4>
<p><br /></p>
<h4 id="now-lets-run-the-program-inside-gdb-and-test-it">Now let’s run the program inside gdb and test it.</h4>
<p><img src="/images/binary-exploitation/BOF/6.png" alt="" /></p>
<h4 id="the-input-was-aaaaa-which-is-less-than-20-chars-so-the-program-exited-normally-and-everything-is-good">The input was aaaaa which is less than 20 chars so the program exited normally and everything is good</h4>
<h4 id="now-lets-throw-an-input-more-that-20-chars">Now let’s throw an input more that 20 chars.</h4>
<p><img src="/images/binary-exploitation/BOF/7.png" alt="" /></p>
<h4 id="we-get-a-segmentation-fault-because-our-return-address-is-overwritten-and-the-program-couldnt-continue">We get a segmentation fault because our return address is overwritten and the program couldn’t continue.</h4>
<h4 id="to-show-how-are-these-addresses-overwritten-lets-input-any-hex-value--something-like-x12-for-50-times-then-lets-look-at-the-registers">To show how are these addresses overwritten let’s input any hex value , something like \x12 for 50 times. Then let’s look at the registers.</h4>
<p><img src="/images/binary-exploitation/BOF/8.png" alt="" /></p>
<h4 id="we-see-that-most-of-the-memory-addresses-are-overwritten-with-12">We see that most of the memory addresses are overwritten with 12</h4>
<p><br /></p>
<hr />

<h3 id="why-are-buffer-overflows-dangerous-">Why Are Buffer Overflows Dangerous ?</h3>
<h4 id="now-you-might-ask-yourself--how-will-that-be-harmful-">Now you might ask yourself , How will that be harmful ?</h4>
<h4 id="a-buffer-overflow-is-dangerous-when-the-vulnerable-binary-or-program-is-a-setuid-binary--if-you-dont-know-what-setuid-binaries-are-read-the-provided-link-but-in-general-they-are-programs-that-run-with-capabilities-of-another-user-usually-root--but-when-that-program-is-vulnerable-to-a-buffer-overflow-its-not-a-good-thing-anymore-since-we-can-pass-the-buffer-and-overwrite-the-program-then-we-can-overwrite-it-with-a-payload-that-executes-a-system-call-and-spawns-a-root-shell">A buffer overflow is dangerous when the vulnerable binary or program is a <a href="https://en.wikipedia.org/wiki/Setuid">setuid</a> binary , If you don’t know what setuid binaries are, read the provided link, but in general They are programs that run with capabilities of another user (usually root) , But when that program is vulnerable to a buffer overflow it’s not a good thing anymore. Since we can pass the buffer and overwrite the program then we can overwrite it with a payload that executes a system call and spawns a root shell</h4>
<p><br /></p>
<hr />

<h4 id="i-will-do-more-write-ups-about-buffer-overflows-and-other-binary-exploitation-techniques-for-now-i-will-start-with-protostar">I will do more write ups about buffer overflows and other binary exploitation techniques, for now I will start with protostar.</h4>
<h4 id="there-are-also-some-cool-boxes-on-hack-the-box-that-required-buffer-overflows-and-binary-exploitation-to-gain-root-privileges-but-theyre-active-right-now-so-ill-publish-my-write-ups-about-these-boxes-as-soon-as-they-retire-of-course-in-the-meantime-you-can-read-my-other-hack-the-box-write-ups-">There are also some cool boxes on Hack The box that required buffer overflows and binary exploitation to gain root privileges but they’re active right now so I’ll publish my write ups about these boxes as soon as they retire of course. In the meantime, you can read my other <a href="https://0xrick.github.io">Hack The Box write-ups</a> !</h4>
<p><br /></p>
<hr />

<h3 id="protostar-stack0">Protostar Stack0</h3>
<h4 id="now-lets-do-a-simple-practical-example">Now let’s do a simple practical example.</h4>
<h4 id="you-can-download-protostar-from-here">You can download protostar from <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">here</a></h4>
<h4 id="i-will-solve-the-first-level-which-is-stack0-for-this-article-then-i-will-solve-the-rest-of-the-levels-in-other-write-ups">I will solve the first level which is stack0 for this article then I will solve the rest of the levels in other write-ups.</h4>
<h4 id="were-given-the-source-code-of-the-program-">We’re given the source code of the program :</h4>
<p><br />
<br /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 modified = 0;
 gets(buffer);

 if(modified != 0) {
  printf("you have changed the 'modified' variable\n");
 } else {
  printf("Try again?\n");
 }
}
</code></pre></div></div>
<h4 id="from-the-code-we-can-understand-that-the-program-has-a-variable-called-buffer-and-assigns-a-buffer-of-64-chars-to-it-then-theres-another-variable-called-modified-and-its-value-is-0-getsbuffer-allows-us-to-input-the-value-of-buffer-variablethen-theres-an-if-statement-that-checks-if-the-value-of-modified-variable-is-not-equal-to-0-if-its-not-equal-to-zero-it-will-print-you-have-changed-the-modified-variable-but-if-its-still-equal-to-0-it-will-print-try-again-so-our-mission-is-to-change-the-value-of-that-variable-called-modified">From the code we can understand that the program has a variable called “buffer” and assigns a buffer of 64 chars to it. Then there’s another variable called modified and it’s value is 0. gets(buffer) allows us to input the value of “buffer” variable.Then there’s an if statement that checks if the value of “modified” variable is not equal to 0. If it’s not equal to zero it will print “you have changed the ‘modified’ variable” but if it’s still equal to 0 it will print “Try again?”. So our mission is to change the value of that variable called “modified”</h4>
<h4 id="as-long-as-the-entered-data-is-less-than-64-chars-everything-will-run-as-intended-but-if-the-input-exceeds-the-buffer-it-will-overwrite-the-value-of-modified-variable">As long as the entered data is less than 64 chars everything will run as intended. But if the input exceeds the buffer it will overwrite the value of “modified” variable.</h4>
<h4 id="we-already-know-that-the-buffer-is-64-chars-so-we-just-need-to-input-65-chars-or-more-and-the-variable-value-will-change-lets-test-that-out">We already know that the buffer is 64 chars so we just need to input 65 chars or more and the variable value will change. Let’s test that out.</h4>
<h4 id="we-execute-the-stack0-bin-and-we-see-the-output-try-again">We execute the stack0 bin and we see the output “try again?”</h4>
<p><img src="/images/binary-exploitation/BOF/9.png" alt="" /></p>
<h4 id="lets-throw-65-as-and-see-the-output">Let’s throw 65 “A”s and see the output.</h4>
<p><code class="highlighter-rouge">python -c "print ('A' * 65)" | ./stack0 </code>
<img src="/images/binary-exploitation/BOF/10.png" alt="" /></p>
<h4 id="and-we-have-successfuly-overwritten-the-variables-value--d">And we have successfuly overwritten the variable’s value ! :D</h4>
<p><br />
<br /></p>
<h4 id="thats-it--feedback-is-appreciated-">That’s it , Feedback is appreciated !</h4>
<h4 id="dont-forget-to-read-the-previous-articles--tweet-about-the-article-if-you-liked-it--follow-on-twitter-ahm3d_h3sham">Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a></h4>
<h4 id="thanks-for-reading">Thanks for reading.</h4>
<p><br />
<br /></p>
<h4 id="next-binary-exploitation-article--buffer-overflow-examples-overwriting-a-variable-value-on-the-stack---protostar-stack1--stack2">Next Binary Exploitation article : <a href="/binary-exploitation/bof2/">Buffer Overflow Examples, Overwriting a variable value on the stack - Protostar Stack1 , Stack2</a></h4>
<hr />


  </div>
<script src="https://www.hackthebox.eu/badge/65598"></script><a class="u-url" href="/binary-exploitation/bof1/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">0xRick Owned Root !</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">0xRick Owned Root !</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/Ahm3d.H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">Ahm3d.H3sham</span></a></li><li><a href="https://github.com/0xRick"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">0xRick</span></a></li><li><a href="https://www.twitter.com/Ahm3d_H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Ahm3d_H3sham</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Infosec Blog , CTF and Hack The Box write-ups , articles and other stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

