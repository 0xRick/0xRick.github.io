<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>A dive into the PE file format - LAB 1: Writing a PE Parser - 0xRick’s Blog</title>
<meta name="description" content="A dive into the PE file format - LAB 1: Writing a PE Parser  Introduction  In the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept.  The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure. We’re going to focus on PE32 and PE32+ files, and we’ll only parse the following parts of the file:     DOS Header   Rich Header   NT Headers   Data Directories (within the Optional Header)   Section Headers   Import Table   Base Relocations Table   The code of this project can be found on my github profile.    Initial Setup  Process Outline  We want out parser to follow the following process:     Read a file.   Validate that it’s a PE file.   Determine whether it’s a PE32 or a PE32+.   Parse out the following structures:            DOS Header       Rich Header       NT Headers       Section Headers       Import Data Directory       Base Relocation Data Directory           Print out the following information:            File name and type.       DOS Header:                    Magic value.           Address of new exe header.                       Each entry of the Rich Header, decrypted and decoded.       NT Headers - PE file signature.       NT Headers - File Header:                    Machine value.           Number of sections.           Size of Optional Header.                       NT Headers - Optional Header:                    Magic value.           Size of code section.           Size of initialized data.           Size of uninitialized data.           Address of entry point.           RVA of start of code section.           Desired Image Base.           Section alignment.           File alignment.           Size of image.           Size of headers.                       For each Data Directory: its name, RVA and size.       For each Section Header:                    Section name.           Section virtual address and size.           Section raw data pointer and size.           Section characteristics value.                       Import Table:                    For each DLL:                            DLL name.               ILT and IAT RVAs.               Whether its a bound import or not.               for every imported function:                                    Ordinal if ordinal/name flag is 1.                   Name, hint and Hint/Name table RVA if ordinal/name flag is 0.                                                                               Base Relocation Table:                    For each block:                            Page RVA.               Block size.               Number of entries.               For each entry:                                    Raw value.                   Relocation offset.                   Relocation Type.                                                                                   winnt.h Definitions  We will need the following definitions from the winnt.h header:     Types:            BYTE       WORD       DWORD       QWORD       LONG       LONGLONG       ULONGLONG           Constants:            IMAGE_NT_OPTIONAL_HDR32_MAGIC       IMAGE_NT_OPTIONAL_HDR64_MAGIC       IMAGE_NUMBEROF_DIRECTORY_ENTRIES       IMAGE_DOS_SIGNATURE       IMAGE_DIRECTORY_ENTRY_EXPORT       IMAGE_DIRECTORY_ENTRY_IMPORT       IMAGE_DIRECTORY_ENTRY_RESOURCE       IMAGE_DIRECTORY_ENTRY_EXCEPTION       IMAGE_DIRECTORY_ENTRY_SECURITY       IMAGE_DIRECTORY_ENTRY_BASERELOC       IMAGE_DIRECTORY_ENTRY_DEBUG       IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       IMAGE_DIRECTORY_ENTRY_GLOBALPTR       IMAGE_DIRECTORY_ENTRY_TLS       IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG       IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       IMAGE_DIRECTORY_ENTRY_IAT       IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR       IMAGE_SIZEOF_SHORT_NAME       IMAGE_SIZEOF_SECTION_HEADER           Structures:            IMAGE_DOS_HEADER       IMAGE_DATA_DIRECTORY       IMAGE_OPTIONAL_HEADER32       IMAGE_OPTIONAL_HEADER64       IMAGE_FILE_HEADER       IMAGE_NT_HEADERS32       IMAGE_NT_HEADERS64       IMAGE_IMPORT_DESCRIPTOR       IMAGE_IMPORT_BY_NAME       IMAGE_BASE_RELOCATION       IMAGE_SECTION_HEADER           I took these definitions from winnt.h and added them to a new header called winntdef.h.  winntdef.h:  typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned long DWORD; typedef unsigned long long QWORD; typedef unsigned long LONG; typedef __int64 LONGLONG; typedef unsigned __int64 ULONGLONG;  #define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC       0x10b #define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC       0x20b #define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16 #define ___IMAGE_DOS_SIGNATURE                 0x5A4D  #define ___IMAGE_DIRECTORY_ENTRY_EXPORT          0 #define ___IMAGE_DIRECTORY_ENTRY_IMPORT          1 #define ___IMAGE_DIRECTORY_ENTRY_RESOURCE        2 #define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 #define ___IMAGE_DIRECTORY_ENTRY_SECURITY        4 #define ___IMAGE_DIRECTORY_ENTRY_BASERELOC       5 #define ___IMAGE_DIRECTORY_ENTRY_DEBUG           6 #define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7 #define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8 #define ___IMAGE_DIRECTORY_ENTRY_TLS             9 #define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10 #define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11 #define ___IMAGE_DIRECTORY_ENTRY_IAT            12 #define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13 #define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14  #define ___IMAGE_SIZEOF_SHORT_NAME              8 #define ___IMAGE_SIZEOF_SECTION_HEADER          40  typedef struct __IMAGE_DOS_HEADER {     WORD   e_magic;     WORD   e_cblp;     WORD   e_cp;     WORD   e_crlc;     WORD   e_cparhdr;     WORD   e_minalloc;     WORD   e_maxalloc;     WORD   e_ss;     WORD   e_sp;     WORD   e_csum;     WORD   e_ip;     WORD   e_cs;     WORD   e_lfarlc;     WORD   e_ovno;     WORD   e_res[4];     WORD   e_oemid;     WORD   e_oeminfo;     WORD   e_res2[10];     LONG   e_lfanew; } ___IMAGE_DOS_HEADER, * ___PIMAGE_DOS_HEADER;  typedef struct __IMAGE_DATA_DIRECTORY {     DWORD   VirtualAddress;     DWORD   Size; } ___IMAGE_DATA_DIRECTORY, * ___PIMAGE_DATA_DIRECTORY;   typedef struct __IMAGE_OPTIONAL_HEADER {     WORD    Magic;     BYTE    MajorLinkerVersion;     BYTE    MinorLinkerVersion;     DWORD   SizeOfCode;     DWORD   SizeOfInitializedData;     DWORD   SizeOfUninitializedData;     DWORD   AddressOfEntryPoint;     DWORD   BaseOfCode;     DWORD   BaseOfData;     DWORD   ImageBase;     DWORD   SectionAlignment;     DWORD   FileAlignment;     WORD    MajorOperatingSystemVersion;     WORD    MinorOperatingSystemVersion;     WORD    MajorImageVersion;     WORD    MinorImageVersion;     WORD    MajorSubsystemVersion;     WORD    MinorSubsystemVersion;     DWORD   Win32VersionValue;     DWORD   SizeOfImage;     DWORD   SizeOfHeaders;     DWORD   CheckSum;     WORD    Subsystem;     WORD    DllCharacteristics;     DWORD   SizeOfStackReserve;     DWORD   SizeOfStackCommit;     DWORD   SizeOfHeapReserve;     DWORD   SizeOfHeapCommit;     DWORD   LoaderFlags;     DWORD   NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER32, * ___PIMAGE_OPTIONAL_HEADER32;  typedef struct __IMAGE_OPTIONAL_HEADER64 {     WORD        Magic;     BYTE        MajorLinkerVersion;     BYTE        MinorLinkerVersion;     DWORD       SizeOfCode;     DWORD       SizeOfInitializedData;     DWORD       SizeOfUninitializedData;     DWORD       AddressOfEntryPoint;     DWORD       BaseOfCode;     ULONGLONG   ImageBase;     DWORD       SectionAlignment;     DWORD       FileAlignment;     WORD        MajorOperatingSystemVersion;     WORD        MinorOperatingSystemVersion;     WORD        MajorImageVersion;     WORD        MinorImageVersion;     WORD        MajorSubsystemVersion;     WORD        MinorSubsystemVersion;     DWORD       Win32VersionValue;     DWORD       SizeOfImage;     DWORD       SizeOfHeaders;     DWORD       CheckSum;     WORD        Subsystem;     WORD        DllCharacteristics;     ULONGLONG   SizeOfStackReserve;     ULONGLONG   SizeOfStackCommit;     ULONGLONG   SizeOfHeapReserve;     ULONGLONG   SizeOfHeapCommit;     DWORD       LoaderFlags;     DWORD       NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER64, * ___PIMAGE_OPTIONAL_HEADER64;  typedef struct __IMAGE_FILE_HEADER {     WORD    Machine;     WORD    NumberOfSections;     DWORD   TimeDateStamp;     DWORD   PointerToSymbolTable;     DWORD   NumberOfSymbols;     WORD    SizeOfOptionalHeader;     WORD    Characteristics; } ___IMAGE_FILE_HEADER, * ___PIMAGE_FILE_HEADER;  typedef struct __IMAGE_NT_HEADERS64 {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER64 OptionalHeader; } ___IMAGE_NT_HEADERS64, * ___PIMAGE_NT_HEADERS64;  typedef struct __IMAGE_NT_HEADERS {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER32 OptionalHeader; } ___IMAGE_NT_HEADERS32, * ___PIMAGE_NT_HEADERS32;  typedef struct __IMAGE_IMPORT_DESCRIPTOR {     union {         DWORD   Characteristics;         DWORD   OriginalFirstThunk;     } DUMMYUNIONNAME;     DWORD   TimeDateStamp;     DWORD   ForwarderChain;     DWORD   Name;     DWORD   FirstThunk; } ___IMAGE_IMPORT_DESCRIPTOR, * ___PIMAGE_IMPORT_DESCRIPTOR;  typedef struct __IMAGE_IMPORT_BY_NAME {     WORD    Hint;     char   Name[100]; } ___IMAGE_IMPORT_BY_NAME, * ___PIMAGE_IMPORT_BY_NAME;  typedef struct __IMAGE_BASE_RELOCATION {     DWORD   VirtualAddress;     DWORD   SizeOfBlock; } ___IMAGE_BASE_RELOCATION, * ___PIMAGE_BASE_RELOCATION;  typedef struct __IMAGE_SECTION_HEADER {     BYTE    Name[___IMAGE_SIZEOF_SHORT_NAME];     union {         DWORD   PhysicalAddress;         DWORD   VirtualSize;     } Misc;     DWORD   VirtualAddress;     DWORD   SizeOfRawData;     DWORD   PointerToRawData;     DWORD   PointerToRelocations;     DWORD   PointerToLinenumbers;     WORD    NumberOfRelocations;     WORD    NumberOfLinenumbers;     DWORD   Characteristics; } ___IMAGE_SECTION_HEADER, * ___PIMAGE_SECTION_HEADER;   Custom Structures  I defined the following structures to help with the parsing process. They’re defined in the PEFILE_CUSTOM_STRUCTS.h header.  RICH_HEADER_INFO  A structure to hold information about the Rich Header during processing.  typedef struct __RICH_HEADER_INFO {     int size;     char* ptrToBuffer;     int entries; } RICH_HEADER_INFO, * PRICH_HEADER_INFO;      size: Size of the Rich Header (in bytes).   ptrToBuffer: A pointer to the buffer containing the data of the Rich Header.   entries: Number of entries in the Rich Header.   RICH_HEADER_ENTRY  A structure to represent a Rich Header entry.  typedef struct __RICH_HEADER_ENTRY {     WORD  prodID;     WORD  buildID;     DWORD useCount; } RICH_HEADER_ENTRY, * PRICH_HEADER_ENTRY;      prodID: Type ID / Product ID.   buildID: Build ID.   useCount: Use count.   RICH_HEADER  A structure to represent the Rich Header.  typedef struct __RICH_HEADER {     PRICH_HEADER_ENTRY entries; } RICH_HEADER, * PRICH_HEADER;      entries: A pointer to a RICH_HEADER_ENTRY array.   ILT_ENTRY_32  A structure to represent a 32-bit ILT entry during processing.  typedef struct __ILT_ENTRY_32 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;         DWORD ORDINAL_NAME_FLAG : 1;     } FIELD_1; } ILT_ENTRY_32, * PILT_ENTRY_32;   The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  ILT_ENTRY_64  A structure to represent a 64-bit ILT entry during processing.  typedef struct __ILT_ENTRY_64 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;     } FIELD_2;     DWORD ORDINAL_NAME_FLAG : 1; } ILT_ENTRY_64, * PILT_ENTRY_64;   The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  BASE_RELOC_ENTRY  A structure to represent a base relocation entry during processing.  typedef struct __BASE_RELOC_ENTRY {     WORD OFFSET : 12;     WORD TYPE : 4; } BASE_RELOC_ENTRY, * PBASE_RELOC_ENTRY;      OFFSET: Relocation offset.   TYPE: Relocation type.   PEFILE  Our parser will represent a PE file as an object type of either PE32FILE or PE64FILE. These 2 classes only differ in some member definitions but their functionality is identical. Throughout this post we will use the code from PE64FILE.  Definition  The class is defined as follows:  class PE64FILE { public:     PE64FILE(char* _NAME, FILE* Ppefile); 	     void PrintInfo();  private:     char* NAME;     FILE* Ppefile;     int _import_directory_count, _import_directory_size;     int _basreloc_directory_count;      // HEADERS     ___IMAGE_DOS_HEADER     PEFILE_DOS_HEADER;     ___IMAGE_NT_HEADERS64   PEFILE_NT_HEADERS;      // DOS HEADER     DWORD PEFILE_DOS_HEADER_EMAGIC;     LONG  PEFILE_DOS_HEADER_LFANEW;      // RICH HEADER     RICH_HEADER_INFO PEFILE_RICH_HEADER_INFO;     RICH_HEADER PEFILE_RICH_HEADER;      // NT_HEADERS.Signature     DWORD PEFILE_NT_HEADERS_SIGNATURE;      // NT_HEADERS.FileHeader     WORD PEFILE_NT_HEADERS_FILE_HEADER_MACHINE;     WORD PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS;     WORD PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER;      // NT_HEADERS.OptionalHeader     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE;     ULONGLONG PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS;      ___IMAGE_DATA_DIRECTORY PEFILE_EXPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_RESOURCE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_EXCEPTION_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_SECURITY_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BASERELOC_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DEBUG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_ARCHITECTURE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_GLOBALPTR_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_TLS_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_LOAD_CONFIG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BOUND_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IAT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DELAY_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_COM_DESCRIPTOR_DIRECTORY;      // SECTION HEADERS     ___PIMAGE_SECTION_HEADER PEFILE_SECTION_HEADERS;      // IMPORT TABLE     ___PIMAGE_IMPORT_DESCRIPTOR PEFILE_IMPORT_TABLE;          // BASE RELOCATION TABLE     ___PIMAGE_BASE_RELOCATION PEFILE_BASERELOC_TABLE;      // FUNCTIONS          // ADDRESS RESOLVERS     int  locate(DWORD VA);     DWORD resolve(DWORD VA, int index);      // PARSERS     void ParseFile();     void ParseDOSHeader();     void ParseNTHeaders();     void ParseSectionHeaders();     void ParseImportDirectory();     void ParseBaseReloc();     void ParseRichHeader();      // PRINT INFO     void PrintFileInfo();     void PrintDOSHeaderInfo();     void PrintRichHeaderInfo();     void PrintNTHeadersInfo();     void PrintSectionHeadersInfo();     void PrintImportTableInfo();     void PrintBaseRelocationsInfo(); };   The only public member beside the class constructor is a function called printInfo() which will print information about the file.  The class constructor takes two parameters, a char array representing the name of the file and a file pointer to the actual data of the file.  After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later.  In the end is a series of methods definitions, first two methods are called locate and resolve, I will talk about them in a minute. The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts.  Constructor  The constructor of the class simply sets the file pointer and name variables, then it calls the ParseFile() function.  PE64FILE::PE64FILE(char* _NAME, FILE* _Ppefile) { 	 	NAME = _NAME; 	Ppefile = _Ppefile;  	ParseFile();  }   The ParseFile() function calls the other parser functions:  void PE64FILE::ParseFile() {  	// PARSE DOS HEADER 	ParseDOSHeader();  	// PARSE RICH HEADER 	ParseRichHeader();  	//PARSE NT HEADERS 	ParseNTHeaders();  	// PARSE SECTION HEADERS 	ParseSectionHeaders();  	// PARSE IMPORT DIRECTORY 	ParseImportDirectory();  	// PARSE BASE RELOCATIONS 	ParseBaseReloc();  }   Resolving RVAs  Most of the time, we’ll have a RVA that we’ll need to change to a file offset. The process of resolving an RVA can be outlined as follows:     Determine which section range contains that RVA:            Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section.       If the RVA exists within this range then it belongs to that section.           Calculate the file offset:            Subtract the RVA from the section virtual address.       Add that value to the raw data pointer of the section.           An example of this is locating a Data Directory. The IMAGE_DATA_DIRECTORY structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address.  I wrote two functions to do this, first one to locate the virtual address (locate()), second one to resolve the address (resolve()).  int PE64FILE::locate(DWORD VA) { 	 	int index; 	 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		if (VA &gt;= PEFILE_SECTION_HEADERS[i].VirtualAddress 			&amp;&amp; VA &lt; (PEFILE_SECTION_HEADERS[i].VirtualAddress + PEFILE_SECTION_HEADERS[i].Misc.VirtualSize)){ 			index = i; 			break; 		} 	} 	return index; }  DWORD PE64FILE::resolve(DWORD VA, int index) {  	return (VA - PEFILE_SECTION_HEADERS[index].VirtualAddress) + PEFILE_SECTION_HEADERS[index].PointerToRawData;  }   locate() iterates over the PEFILE_SECTION_HEADERS array, compares the RVA as described above, then it returns the index of the appropriate section header within the PEFILE_SECTION_HEADERS array.  Please note that in order for these functions to work we’ll need to parse out the section headers and fill the PEFILE_SECTION_HEADERS array first. We still haven’t discussed this part, but I wanted to talk about the address resolvers first.  main function  The main function of the program is fairly simple, it only does 2 things:     Create a file pointer to the given file, and validate that the file was read correctly.   Call INITPARSE() on the file, and based on the return value it decides between three actions:            Exit.       Create a PE32FILE object, call PrintInfo(), close the file pointer then exit.       Create a PE64FILE object, call PrintInfo(), close the file pointer then exit.           PrintInfo() calls the other print info functions.  int main(int argc, char* argv[]) { 	if (argc != 2) { 		printf(&quot;Usage: %s [path to executable]\n&quot;, argv[0]); 		return 1; 	}  	FILE * PpeFile; 	fopen_s(&amp;PpeFile, argv[1], &quot;rb&quot;);  	if (PpeFile == NULL) { 		printf(&quot;Can&#39;t open file.\n&quot;); 		return 1; 	}  	if (INITPARSE(PpeFile) == 1) { 		exit(1); 	} 	else if (INITPARSE(PpeFile) == 32) { 		PE32FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	} 	else if (INITPARSE(PpeFile) == 64) { 		PE64FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	}  	return 0; }   INITPARSE()  INITPARSE() is a function defined in PEFILE.cpp. Its only job is to validate that the given file is a PE file, then determine whether the file is PE32 or PE32+.  It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error.  After validating the PE file, it sets the file position to (DOS_HEADER.e_lfanew + size of DWORD (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header. Then it reads a WORD, we know that the first WORD of the Optional Header is a magic value that indicates the file type, it then compares that word to IMAGE_NT_OPTIONAL_HDR32_MAGIC and IMAGE_NT_OPTIONAL_HDR64_MAGIC, and based on the comparison results it either returns 32 or 64 indicating PE32 or PE32+, or it returns an error.  int INITPARSE(FILE* PpeFile) {  	___IMAGE_DOS_HEADER TMP_DOS_HEADER; 	WORD PEFILE_TYPE;  	fseek(PpeFile, 0, SEEK_SET); 	fread(&amp;TMP_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, PpeFile);  	if (TMP_DOS_HEADER.e_magic != ___IMAGE_DOS_SIGNATURE) { 		printf(&quot;Error. Not a PE file.\n&quot;); 		return 1; 	}  	fseek(PpeFile, (TMP_DOS_HEADER.e_lfanew + sizeof(DWORD) + sizeof(___IMAGE_FILE_HEADER)), SEEK_SET); 	fread(&amp;PEFILE_TYPE, sizeof(WORD), 1, PpeFile);  	if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR32_MAGIC) { 		return 32; 	} 	else if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR64_MAGIC) { 		return 64; 	} 	else { 		printf(&quot;Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\n&quot;); 		return 1; 	}  }     Parsing DOS Header  ParseDOSHeader()  Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member PEFILE_DOS_HEADER. From there we can access all of the struct members, however we’re only interested in e_magic and e_lfanew.  void PE64FILE::ParseDOSHeader() { 	 	fseek(Ppefile, 0, SEEK_SET); 	fread(&amp;PEFILE_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, Ppefile);  	PEFILE_DOS_HEADER_EMAGIC = PEFILE_DOS_HEADER.e_magic; 	PEFILE_DOS_HEADER_LFANEW = PEFILE_DOS_HEADER.e_lfanew;  }   PrintDOSHeaderInfo()  This function prints e_magic and e_lfanew values.  void PE64FILE::PrintDOSHeaderInfo() { 	 	printf(&quot; DOS HEADER:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; Magic: 0x%X\n&quot;, PEFILE_DOS_HEADER_EMAGIC); 	printf(&quot; File address of new exe header: 0x%X\n&quot;, PEFILE_DOS_HEADER_LFANEW);  }       Parsing Rich Header  Process  To parse out the Rich Header we’ll need to go through multiple steps.  We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place.  First of all, we need to locate the Rich Header. We don’t know the exact location, however we have everything we need to locate it. We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers. We also know that any Rich Header ends with a 32-bit value Rich followed by the XOR key.  One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed. A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the Rich sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header.  Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the Rich signature and keep XORing 4 bytes at a time until we reach the DanS signature which indicates the beginning of the Rich Header.  After obtaining the position and the size of the Rich Header, we can normally read and process the data.  ParseRichHeader()  This function starts by allocating a buffer on the heap, then it reads e_lfanew size of bytes from the beginning of the file and stores the data in the allocated buffer.  It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to 0x52 (R) and 0x69 (i). When the sequence is found, it stores the index in a variable then the loop breaks.  	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}   After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments RichHeaderSize by 4 until it reaches the DanS sequence.  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}   After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates PEFILE_RICH_HEADER_INFO with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing.  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;   The rest of the function reads each entry of the Rich Header and updates PEFILE_RICH_HEADER.  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;   Here’s the full function:  void PE64FILE::ParseRichHeader() { 	 	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;  }   PrintRichHeaderInfo()  This function iterates over each entry in PEFILE_RICH_HEADER and prints its value.  void PE64FILE::PrintRichHeaderInfo() { 	 	printf(&quot; RICH HEADER:\n&quot;); 	printf(&quot; ------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_RICH_HEADER_INFO.entries; i++) { 		printf(&quot; 0x%X 0x%X 0x%X: %d.%d.%d\n&quot;, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount); 	}  }       Parsing NT Headers  ParseNTHeaders()  Similar to the DOS Header, all we need to do is to read from e_lfanew an amount of bytes equal to the size of IMAGE_NT_HEADERS.  After that we can parse out the contents of the File Header and the Optional Header.  The Optional Header contains an array of IMAGE_DATA_DIRECTORY structures which we care about. To parse out this information, we can use the IMAGE_DIRECTORY_[...] constants defined in winnt.h as array indexes to access the corresponding IMAGE_DATA_DIRECTORY structure of each Data Directory.  void PE64FILE::ParseNTHeaders() { 	 	fseek(Ppefile, PEFILE_DOS_HEADER.e_lfanew, SEEK_SET); 	fread(&amp;PEFILE_NT_HEADERS, sizeof(PEFILE_NT_HEADERS), 1, Ppefile);  	PEFILE_NT_HEADERS_SIGNATURE = PEFILE_NT_HEADERS.Signature;  	PEFILE_NT_HEADERS_FILE_HEADER_MACHINE = PEFILE_NT_HEADERS.FileHeader.Machine; 	PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS = PEFILE_NT_HEADERS.FileHeader.NumberOfSections; 	PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER = PEFILE_NT_HEADERS.FileHeader.SizeOfOptionalHeader;  	PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC = PEFILE_NT_HEADERS.OptionalHeader.Magic; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfInitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT = PEFILE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.BaseOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE = PEFILE_NT_HEADERS.OptionalHeader.ImageBase; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.SectionAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.FileAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfImage; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS = PEFILE_NT_HEADERS.OptionalHeader.SizeOfHeaders;  	PEFILE_EXPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT]; 	PEFILE_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT]; 	PEFILE_RESOURCE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE]; 	PEFILE_EXCEPTION_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXCEPTION]; 	PEFILE_SECURITY_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_SECURITY]; 	PEFILE_BASERELOC_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC]; 	PEFILE_DEBUG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DEBUG]; 	PEFILE_ARCHITECTURE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE]; 	PEFILE_GLOBALPTR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_GLOBALPTR]; 	PEFILE_TLS_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_TLS]; 	PEFILE_LOAD_CONFIG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]; 	PEFILE_BOUND_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]; 	PEFILE_IAT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IAT]; 	PEFILE_DELAY_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]; 	PEFILE_COM_DESCRIPTOR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];  }   PrintNTHeadersInfo()  This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size.  void PE64FILE::PrintNTHeadersInfo() { 	 	printf(&quot; NT HEADERS:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; PE Signature: 0x%X\n&quot;, PEFILE_NT_HEADERS_SIGNATURE);  	printf(&quot;\n File Header:\n\n&quot;); 	printf(&quot;   Machine: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_MACHINE); 	printf(&quot;   Number of sections: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS); 	printf(&quot;   Size of optional header: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER);  	printf(&quot;\n Optional Header:\n\n&quot;); 	printf(&quot;   Magic: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC); 	printf(&quot;   Size of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE); 	printf(&quot;   Size of initialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA); 	printf(&quot;   Size of uninitialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA); 	printf(&quot;   Address of entry point: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT); 	printf(&quot;   RVA of start of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE); 	printf(&quot;   Desired image base: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE); 	printf(&quot;   Section alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT); 	printf(&quot;   File alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT); 	printf(&quot;   Size of image: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE); 	printf(&quot;   Size of headers: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS);  	printf(&quot;\n Data Directories:\n&quot;); 	printf(&quot;\n   * Export Directory:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.Size); 	. 	. 	[REDACTED] 	. 	. 	printf(&quot;\n   * COM Runtime Descriptor:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.Size);  }       Parsing Section Headers  ParseSectionHeaders()  This function starts by assigning the PEFILE_SECTION_HEADERS class member to a pointer to an IMAGE_SECTION_HEADER array of the count of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS.  Then it goes into a loop of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS iterations where in each iteration it changes the file offset to (e_lfanew + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of PEFILE_SECTION_HEADERS.  void PE64FILE::ParseSectionHeaders() { 	 	PEFILE_SECTION_HEADERS = new ___IMAGE_SECTION_HEADER[PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS]; 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		int offset = (PEFILE_DOS_HEADER.e_lfanew + sizeof(PEFILE_NT_HEADERS)) + (i * ___IMAGE_SIZEOF_SECTION_HEADER); 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_SECTION_HEADERS[i], ___IMAGE_SIZEOF_SECTION_HEADER, 1, Ppefile); 	}  }   PrintSectionHeadersInfo()  This function loops over the Section Headers array (filled by ParseSectionHeaders()), and it prints information about each section.  void PE64FILE::PrintSectionHeadersInfo() { 	 	printf(&quot; SECTION HEADERS:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		printf(&quot;   * %.8s:\n&quot;, PEFILE_SECTION_HEADERS[i].Name); 		printf(&quot;        VirtualAddress: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].VirtualAddress); 		printf(&quot;        VirtualSize: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].Misc.VirtualSize); 		printf(&quot;        PointerToRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].PointerToRawData); 		printf(&quot;        SizeOfRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].SizeOfRawData); 		printf(&quot;        Characteristics: 0x%X\n\n&quot;, PEFILE_SECTION_HEADERS[i].Characteristics); 	}  }       Parsing Imports  ParseImportDirectory()  To parse out the Import Directory Table we need to determine the count of IMAGE_IMPORT_DESCRIPTORs first.  This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor. In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks. Otherwise it increments _import_directory_count and the loop continues.  After finding the size of the Import Directory, the function assigns the PEFILE_IMPORT_TABLE class member to a pointer to an IMAGE_IMPORT_DESCRIPTOR array of the count of _import_directory_count then goes into another loop similar to the one we’ve seen in ParseSectionHeaders() to parse out the import descriptors.  void PE64FILE::ParseImportDirectory() { 	 	DWORD _import_directory_address = resolve(PEFILE_IMPORT_DIRECTORY.VirtualAddress, locate(PEFILE_IMPORT_DIRECTORY.VirtualAddress)); 	_import_directory_count = 0;  	while (true) { 		___IMAGE_IMPORT_DESCRIPTOR tmp; 		int offset = (_import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile);  		if (tmp.Name == 0x00000000 &amp;&amp; tmp.FirstThunk == 0x00000000) { 			_import_directory_count -= 1; 			_import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR); 			break; 		}  		_import_directory_count++; 	}  	PEFILE_IMPORT_TABLE = new ___IMAGE_IMPORT_DESCRIPTOR[_import_directory_count];  	for (int i = 0; i &lt; _import_directory_count; i++) { 		int offset = (i * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_IMPORT_TABLE[i], sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile); 	}  }   PrintImportTableInfo()  After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions. This is done by the PrintImportTableInfo() function.  This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not.  After that it resolves the file offset of the ILT then it parses out each ILT entry. If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint.  If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts.  We’ve discussed the details about this in the PE imports post.  void PE64FILE::PrintImportTableInfo() { 	 	printf(&quot; IMPORT TABLE:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; _import_directory_count; i++) { 		DWORD NameAddr = resolve(PEFILE_IMPORT_TABLE[i].Name, locate(PEFILE_IMPORT_TABLE[i].Name)); 		int NameSize = 0;  		while (true) { 			char tmp; 			fseek(Ppefile, (NameAddr + NameSize), SEEK_SET); 			fread(&amp;tmp, sizeof(char), 1, Ppefile);  			if (tmp == 0x00) { 				break; 			}  			NameSize++; 		}  		char* Name = new char[NameSize + 2]; 		fseek(Ppefile, NameAddr, SEEK_SET); 		fread(Name, (NameSize * sizeof(char)) + 1, 1, Ppefile); 		printf(&quot;   * %s:\n&quot;, Name); 		delete[] Name;  		printf(&quot;       ILT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk); 		printf(&quot;       IAT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].FirstThunk);  		if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == 0) { 			printf(&quot;       Bound: FALSE\n&quot;); 		} 		else if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == -1) { 			printf(&quot;       Bound: TRUE\n&quot;); 		}  		printf(&quot;\n&quot;);  		DWORD ILTAddr = resolve(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk, locate(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk)); 		int entrycounter = 0;  		while (true) {  			ILT_ENTRY_64 entry;  			fseek(Ppefile, (ILTAddr + (entrycounter * sizeof(QWORD))), SEEK_SET); 			fread(&amp;entry, sizeof(ILT_ENTRY_64), 1, Ppefile);  			BYTE flag = entry.ORDINAL_NAME_FLAG; 			DWORD HintRVA = 0x0; 			WORD ordinal = 0x0;  			if (flag == 0x0) { 				HintRVA = entry.FIELD_2.HINT_NAME_TABE; 			} 			else if (flag == 0x01) { 				ordinal = entry.FIELD_2.ORDINAL; 			}  			if (flag == 0x0 &amp;&amp; HintRVA == 0x0 &amp;&amp; ordinal == 0x0) { 				break; 			}  			printf(&quot;\n       Entry:\n&quot;);  			if (flag == 0x0) { 				___IMAGE_IMPORT_BY_NAME hint;  				DWORD HintAddr = resolve(HintRVA, locate(HintRVA)); 				fseek(Ppefile, HintAddr, SEEK_SET); 				fread(&amp;hint, sizeof(___IMAGE_IMPORT_BY_NAME), 1, Ppefile); 				printf(&quot;         Name: %s\n&quot;, hint.Name); 				printf(&quot;         Hint RVA: 0x%X\n&quot;, HintRVA); 				printf(&quot;         Hint: 0x%X\n&quot;, hint.Hint); 			} 			else if (flag == 1) { 				printf(&quot;         Ordinal: 0x%X\n&quot;, ordinal); 			}  			entrycounter++; 		}  		printf(&quot;\n   ----------------------\n\n&quot;);  	}  }       Parsing Base Relocations  ParseBaseReloc()  This function follows the same process we’ve seen in ParseImportDirectory(). It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each IMAGE_BASE_RELOCATION structure in PEFILE_BASERELOC_TABLE. One thing to note here that is different from what we’ve seen in ParseImportDirectory() is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of SizeOfBlock of each block in each iteration. We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks.  void PE64FILE::ParseBaseReloc() { 	 	DWORD _basereloc_directory_address = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 	_basreloc_directory_count = 0; 	int _basereloc_size_counter = 0;  	while (true) { 		___IMAGE_BASE_RELOCATION tmp;  		int offset = (_basereloc_size_counter + _basereloc_directory_address);  		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile);  		if (tmp.VirtualAddress == 0x00000000 &amp;&amp; 			tmp.SizeOfBlock == 0x00000000) { 			break; 		}  		_basreloc_directory_count++; 		_basereloc_size_counter += tmp.SizeOfBlock; 	}  	PEFILE_BASERELOC_TABLE = new ___IMAGE_BASE_RELOCATION[_basreloc_directory_count];  	_basereloc_size_counter = 0;  	for (int i = 0; i &lt; _basreloc_directory_count; i++) { 		int offset = _basereloc_directory_address + _basereloc_size_counter; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_BASERELOC_TABLE[i], sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile); 		_basereloc_size_counter += PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 	}  }   PrintBaseRelocationInfo()  This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of IMAGE_BASE_RELOCATION from the block size then dividing that by the size of a WORD). After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them.  We’ve discussed the details about this in the PE base relocations post.  void PE64FILE::PrintBaseRelocationsInfo() { 	 	printf(&quot; BASE RELOCATIONS TABLE:\n&quot;); 	printf(&quot; -----------------------\n&quot;);  	int szCounter = sizeof(___IMAGE_BASE_RELOCATION);  	for (int i = 0; i &lt; _basreloc_directory_count; i++) {  		DWORD PAGERVA, BLOCKSIZE, BASE_RELOC_ADDR; 		int ENTRIES;  		BASE_RELOC_ADDR = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 		PAGERVA = PEFILE_BASERELOC_TABLE[i].VirtualAddress; 		BLOCKSIZE = PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 		ENTRIES = (BLOCKSIZE - sizeof(___IMAGE_BASE_RELOCATION)) / sizeof(WORD);  		printf(&quot;\n   Block 0x%X: \n&quot;, i); 		printf(&quot;     Page RVA: 0x%X\n&quot;, PAGERVA); 		printf(&quot;     Block size: 0x%X\n&quot;, BLOCKSIZE); 		printf(&quot;     Number of entries: 0x%X\n&quot;, ENTRIES); 		printf(&quot;\n     Entries:\n&quot;);  		for (int i = 0; i &lt; ENTRIES; i++) {  			BASE_RELOC_ENTRY entry;  			int offset = (BASE_RELOC_ADDR + szCounter + (i * sizeof(WORD)));  			fseek(Ppefile, offset, SEEK_SET); 			fread(&amp;entry, sizeof(WORD), 1, Ppefile);  			printf(&quot;\n       * Value: 0x%X\n&quot;, entry); 			printf(&quot;         Relocation Type: 0x%X\n&quot;, entry.TYPE); 			printf(&quot;         Offset: 0x%X\n&quot;, entry.OFFSET);  		} 		printf(&quot;\n   ----------------------\n\n&quot;); 		szCounter += BLOCKSIZE; 	}  }       Conclusion  Here’s the full output after running the parser on a file:  Desktop&gt;.\PE-Parser.exe .\SimpleApp64.exe    FILE: .\SimpleApp64.exe  TYPE: 0x20B (PE32+)   ----------------------------------   DOS HEADER:  -----------   Magic: 0x5A4D  File address of new exe header: 0x100   ----------------------------------   RICH HEADER:  ------------   0x7809 0x93 0xA: 30729.147.10  0x6FCB 0x101 0x2: 28619.257.2  0x6FCB 0x105 0x11: 28619.261.17  0x6FCB 0x104 0xA: 28619.260.10  0x6FCB 0x103 0x3: 28619.259.3  0x685B 0x101 0x5: 26715.257.5  0x0 0x1 0x30: 0.1.48  0x7086 0x109 0x1: 28806.265.1  0x7086 0xFF 0x1: 28806.255.1  0x7086 0x102 0x1: 28806.258.1   ----------------------------------   NT HEADERS:  -----------   PE Signature: 0x4550   File Header:     Machine: 0x8664    Number of sections: 0x6    Size of optional header: 0xF0   Optional Header:     Magic: 0x20B    Size of code section: 0xE00    Size of initialized data: 0x1E00    Size of uninitialized data: 0x0    Address of entry point: 0x12C4    RVA of start of code section: 0x1000    Desired image base: 0x40000000    Section alignment: 0x1000    File alignment: 0x200    Size of image: 0x7000    Size of headers: 0x400   Data Directories:     * Export Directory:        RVA: 0x0        Size: 0x0     * Import Directory:        RVA: 0x27AC        Size: 0xB4     * Resource Directory:        RVA: 0x5000        Size: 0x1E0     * Exception Directory:        RVA: 0x4000        Size: 0x168     * Security Directory:        RVA: 0x0        Size: 0x0     * Base Relocation Table:        RVA: 0x6000        Size: 0x28     * Debug Directory:        RVA: 0x2248        Size: 0x70     * Architecture Specific Data:        RVA: 0x0        Size: 0x0     * RVA of GlobalPtr:        RVA: 0x0        Size: 0x0     * TLS Directory:        RVA: 0x0        Size: 0x0     * Load Configuration Directory:        RVA: 0x22C0        Size: 0x130     * Bound Import Directory:        RVA: 0x0        Size: 0x0     * Import Address Table:        RVA: 0x2000        Size: 0x198     * Delay Load Import Descriptors:        RVA: 0x0        Size: 0x0     * COM Runtime Descriptor:        RVA: 0x0        Size: 0x0   ----------------------------------   SECTION HEADERS:  ----------------     * .text:         VirtualAddress: 0x1000         VirtualSize: 0xD2C         PointerToRawData: 0x400         SizeOfRawData: 0xE00         Characteristics: 0x60000020     * .rdata:         VirtualAddress: 0x2000         VirtualSize: 0xE3C         PointerToRawData: 0x1200         SizeOfRawData: 0x1000         Characteristics: 0x40000040     * .data:         VirtualAddress: 0x3000         VirtualSize: 0x638         PointerToRawData: 0x2200         SizeOfRawData: 0x200         Characteristics: 0xC0000040     * .pdata:         VirtualAddress: 0x4000         VirtualSize: 0x168         PointerToRawData: 0x2400         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .rsrc:         VirtualAddress: 0x5000         VirtualSize: 0x1E0         PointerToRawData: 0x2600         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .reloc:         VirtualAddress: 0x6000         VirtualSize: 0x28         PointerToRawData: 0x2800         SizeOfRawData: 0x200         Characteristics: 0x42000040    ----------------------------------   IMPORT TABLE:  ----------------     * USER32.dll:        ILT RVA: 0x28E0        IAT RVA: 0x2080        Bound: FALSE          Entry:          Name: MessageBoxA          Hint RVA: 0x29F8          Hint: 0x283     ----------------------     * VCRUNTIME140.dll:        ILT RVA: 0x28F0        IAT RVA: 0x2090        Bound: FALSE          Entry:          Name: memset          Hint RVA: 0x2A5E          Hint: 0x3E         Entry:          Name: __current_exception_context          Hint RVA: 0x2A40          Hint: 0x1C         Entry:          Name: __current_exception          Hint RVA: 0x2A2A          Hint: 0x1B         Entry:          Name: __C_specific_handler          Hint RVA: 0x2A12          Hint: 0x8     ----------------------     * api-ms-win-crt-runtime-l1-1-0.dll:        ILT RVA: 0x2948        IAT RVA: 0x20E8        Bound: FALSE          Entry:          Name: _crt_atexit          Hint RVA: 0x2C12          Hint: 0x1E         Entry:          Name: terminate          Hint RVA: 0x2C20          Hint: 0x67         Entry:          Name: _exit          Hint RVA: 0x2B30          Hint: 0x23         Entry:          Name: _register_thread_local_exe_atexit_callback          Hint RVA: 0x2B76          Hint: 0x3D         Entry:          Name: _c_exit          Hint RVA: 0x2B6C          Hint: 0x15         Entry:          Name: exit          Hint RVA: 0x2B28          Hint: 0x55         Entry:          Name: _initterm_e          Hint RVA: 0x2B1A          Hint: 0x37         Entry:          Name: _initterm          Hint RVA: 0x2B0E          Hint: 0x36         Entry:          Name: _get_initial_narrow_environment          Hint RVA: 0x2AEC          Hint: 0x28         Entry:          Name: _initialize_narrow_environment          Hint RVA: 0x2ACA          Hint: 0x33         Entry:          Name: _configure_narrow_argv          Hint RVA: 0x2AB0          Hint: 0x18         Entry:          Name: _initialize_onexit_table          Hint RVA: 0x2BDA          Hint: 0x34         Entry:          Name: _set_app_type          Hint RVA: 0x2A8C          Hint: 0x42         Entry:          Name: _seh_filter_exe          Hint RVA: 0x2A7A          Hint: 0x40         Entry:          Name: _cexit          Hint RVA: 0x2B62          Hint: 0x16         Entry:          Name: __p___argv          Hint RVA: 0x2B54          Hint: 0x5         Entry:          Name: __p___argc          Hint RVA: 0x2B46          Hint: 0x4         Entry:          Name: _register_onexit_function          Hint RVA: 0x2BF6          Hint: 0x3C     ----------------------     * api-ms-win-crt-math-l1-1-0.dll:        ILT RVA: 0x2938        IAT RVA: 0x20D8        Bound: FALSE          Entry:          Name: __setusermatherr          Hint RVA: 0x2A9C          Hint: 0x9     ----------------------     * api-ms-win-crt-stdio-l1-1-0.dll:        ILT RVA: 0x29E0        IAT RVA: 0x2180        Bound: FALSE          Entry:          Name: __p__commode          Hint RVA: 0x2BCA          Hint: 0x1         Entry:          Name: _set_fmode          Hint RVA: 0x2B38          Hint: 0x54     ----------------------     * api-ms-win-crt-locale-l1-1-0.dll:        ILT RVA: 0x2928        IAT RVA: 0x20C8        Bound: FALSE          Entry:          Name: _configthreadlocale          Hint RVA: 0x2BA4          Hint: 0x8     ----------------------     * api-ms-win-crt-heap-l1-1-0.dll:        ILT RVA: 0x2918        IAT RVA: 0x20B8        Bound: FALSE          Entry:          Name: _set_new_mode          Hint RVA: 0x2BBA          Hint: 0x16     ----------------------    ----------------------------------   BASE RELOCATIONS TABLE:  -----------------------     Block 0x0:      Page RVA: 0x2000      Block size: 0x28      Number of entries: 0x10       Entries:         * Value: 0xA198          Relocation Type: 0xA          Offset: 0x198         * Value: 0xA1A0          Relocation Type: 0xA          Offset: 0x1A0         * Value: 0xA1A8          Relocation Type: 0xA          Offset: 0x1A8         * Value: 0xA1B0          Relocation Type: 0xA          Offset: 0x1B0         * Value: 0xA1B8          Relocation Type: 0xA          Offset: 0x1B8         * Value: 0xA1C8          Relocation Type: 0xA          Offset: 0x1C8         * Value: 0xA1E0          Relocation Type: 0xA          Offset: 0x1E0         * Value: 0xA1E8          Relocation Type: 0xA          Offset: 0x1E8         * Value: 0xA220          Relocation Type: 0xA          Offset: 0x220         * Value: 0xA228          Relocation Type: 0xA          Offset: 0x228         * Value: 0xA318          Relocation Type: 0xA          Offset: 0x318         * Value: 0xA330          Relocation Type: 0xA          Offset: 0x330         * Value: 0xA338          Relocation Type: 0xA          Offset: 0x338         * Value: 0xA3D8          Relocation Type: 0xA          Offset: 0x3D8         * Value: 0xA3E0          Relocation Type: 0xA          Offset: 0x3E0         * Value: 0xA3E8          Relocation Type: 0xA          Offset: 0x3E8     ----------------------    ----------------------------------   I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts. I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated.  Thanks for reading.">


  <meta name="author" content="0xRick">
  
  <meta property="article:author" content="0xRick">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="0xRick's Blog">
<meta property="og:title" content="A dive into the PE file format - LAB 1: Writing a PE Parser">
<meta property="og:url" content="https://0xrick.github.io/win-internals/pe8/">


  <meta property="og:description" content="A dive into the PE file format - LAB 1: Writing a PE Parser  Introduction  In the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept.  The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure. We’re going to focus on PE32 and PE32+ files, and we’ll only parse the following parts of the file:     DOS Header   Rich Header   NT Headers   Data Directories (within the Optional Header)   Section Headers   Import Table   Base Relocations Table   The code of this project can be found on my github profile.    Initial Setup  Process Outline  We want out parser to follow the following process:     Read a file.   Validate that it’s a PE file.   Determine whether it’s a PE32 or a PE32+.   Parse out the following structures:            DOS Header       Rich Header       NT Headers       Section Headers       Import Data Directory       Base Relocation Data Directory           Print out the following information:            File name and type.       DOS Header:                    Magic value.           Address of new exe header.                       Each entry of the Rich Header, decrypted and decoded.       NT Headers - PE file signature.       NT Headers - File Header:                    Machine value.           Number of sections.           Size of Optional Header.                       NT Headers - Optional Header:                    Magic value.           Size of code section.           Size of initialized data.           Size of uninitialized data.           Address of entry point.           RVA of start of code section.           Desired Image Base.           Section alignment.           File alignment.           Size of image.           Size of headers.                       For each Data Directory: its name, RVA and size.       For each Section Header:                    Section name.           Section virtual address and size.           Section raw data pointer and size.           Section characteristics value.                       Import Table:                    For each DLL:                            DLL name.               ILT and IAT RVAs.               Whether its a bound import or not.               for every imported function:                                    Ordinal if ordinal/name flag is 1.                   Name, hint and Hint/Name table RVA if ordinal/name flag is 0.                                                                               Base Relocation Table:                    For each block:                            Page RVA.               Block size.               Number of entries.               For each entry:                                    Raw value.                   Relocation offset.                   Relocation Type.                                                                                   winnt.h Definitions  We will need the following definitions from the winnt.h header:     Types:            BYTE       WORD       DWORD       QWORD       LONG       LONGLONG       ULONGLONG           Constants:            IMAGE_NT_OPTIONAL_HDR32_MAGIC       IMAGE_NT_OPTIONAL_HDR64_MAGIC       IMAGE_NUMBEROF_DIRECTORY_ENTRIES       IMAGE_DOS_SIGNATURE       IMAGE_DIRECTORY_ENTRY_EXPORT       IMAGE_DIRECTORY_ENTRY_IMPORT       IMAGE_DIRECTORY_ENTRY_RESOURCE       IMAGE_DIRECTORY_ENTRY_EXCEPTION       IMAGE_DIRECTORY_ENTRY_SECURITY       IMAGE_DIRECTORY_ENTRY_BASERELOC       IMAGE_DIRECTORY_ENTRY_DEBUG       IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       IMAGE_DIRECTORY_ENTRY_GLOBALPTR       IMAGE_DIRECTORY_ENTRY_TLS       IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG       IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       IMAGE_DIRECTORY_ENTRY_IAT       IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR       IMAGE_SIZEOF_SHORT_NAME       IMAGE_SIZEOF_SECTION_HEADER           Structures:            IMAGE_DOS_HEADER       IMAGE_DATA_DIRECTORY       IMAGE_OPTIONAL_HEADER32       IMAGE_OPTIONAL_HEADER64       IMAGE_FILE_HEADER       IMAGE_NT_HEADERS32       IMAGE_NT_HEADERS64       IMAGE_IMPORT_DESCRIPTOR       IMAGE_IMPORT_BY_NAME       IMAGE_BASE_RELOCATION       IMAGE_SECTION_HEADER           I took these definitions from winnt.h and added them to a new header called winntdef.h.  winntdef.h:  typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned long DWORD; typedef unsigned long long QWORD; typedef unsigned long LONG; typedef __int64 LONGLONG; typedef unsigned __int64 ULONGLONG;  #define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC       0x10b #define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC       0x20b #define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16 #define ___IMAGE_DOS_SIGNATURE                 0x5A4D  #define ___IMAGE_DIRECTORY_ENTRY_EXPORT          0 #define ___IMAGE_DIRECTORY_ENTRY_IMPORT          1 #define ___IMAGE_DIRECTORY_ENTRY_RESOURCE        2 #define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 #define ___IMAGE_DIRECTORY_ENTRY_SECURITY        4 #define ___IMAGE_DIRECTORY_ENTRY_BASERELOC       5 #define ___IMAGE_DIRECTORY_ENTRY_DEBUG           6 #define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7 #define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8 #define ___IMAGE_DIRECTORY_ENTRY_TLS             9 #define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10 #define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11 #define ___IMAGE_DIRECTORY_ENTRY_IAT            12 #define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13 #define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14  #define ___IMAGE_SIZEOF_SHORT_NAME              8 #define ___IMAGE_SIZEOF_SECTION_HEADER          40  typedef struct __IMAGE_DOS_HEADER {     WORD   e_magic;     WORD   e_cblp;     WORD   e_cp;     WORD   e_crlc;     WORD   e_cparhdr;     WORD   e_minalloc;     WORD   e_maxalloc;     WORD   e_ss;     WORD   e_sp;     WORD   e_csum;     WORD   e_ip;     WORD   e_cs;     WORD   e_lfarlc;     WORD   e_ovno;     WORD   e_res[4];     WORD   e_oemid;     WORD   e_oeminfo;     WORD   e_res2[10];     LONG   e_lfanew; } ___IMAGE_DOS_HEADER, * ___PIMAGE_DOS_HEADER;  typedef struct __IMAGE_DATA_DIRECTORY {     DWORD   VirtualAddress;     DWORD   Size; } ___IMAGE_DATA_DIRECTORY, * ___PIMAGE_DATA_DIRECTORY;   typedef struct __IMAGE_OPTIONAL_HEADER {     WORD    Magic;     BYTE    MajorLinkerVersion;     BYTE    MinorLinkerVersion;     DWORD   SizeOfCode;     DWORD   SizeOfInitializedData;     DWORD   SizeOfUninitializedData;     DWORD   AddressOfEntryPoint;     DWORD   BaseOfCode;     DWORD   BaseOfData;     DWORD   ImageBase;     DWORD   SectionAlignment;     DWORD   FileAlignment;     WORD    MajorOperatingSystemVersion;     WORD    MinorOperatingSystemVersion;     WORD    MajorImageVersion;     WORD    MinorImageVersion;     WORD    MajorSubsystemVersion;     WORD    MinorSubsystemVersion;     DWORD   Win32VersionValue;     DWORD   SizeOfImage;     DWORD   SizeOfHeaders;     DWORD   CheckSum;     WORD    Subsystem;     WORD    DllCharacteristics;     DWORD   SizeOfStackReserve;     DWORD   SizeOfStackCommit;     DWORD   SizeOfHeapReserve;     DWORD   SizeOfHeapCommit;     DWORD   LoaderFlags;     DWORD   NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER32, * ___PIMAGE_OPTIONAL_HEADER32;  typedef struct __IMAGE_OPTIONAL_HEADER64 {     WORD        Magic;     BYTE        MajorLinkerVersion;     BYTE        MinorLinkerVersion;     DWORD       SizeOfCode;     DWORD       SizeOfInitializedData;     DWORD       SizeOfUninitializedData;     DWORD       AddressOfEntryPoint;     DWORD       BaseOfCode;     ULONGLONG   ImageBase;     DWORD       SectionAlignment;     DWORD       FileAlignment;     WORD        MajorOperatingSystemVersion;     WORD        MinorOperatingSystemVersion;     WORD        MajorImageVersion;     WORD        MinorImageVersion;     WORD        MajorSubsystemVersion;     WORD        MinorSubsystemVersion;     DWORD       Win32VersionValue;     DWORD       SizeOfImage;     DWORD       SizeOfHeaders;     DWORD       CheckSum;     WORD        Subsystem;     WORD        DllCharacteristics;     ULONGLONG   SizeOfStackReserve;     ULONGLONG   SizeOfStackCommit;     ULONGLONG   SizeOfHeapReserve;     ULONGLONG   SizeOfHeapCommit;     DWORD       LoaderFlags;     DWORD       NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER64, * ___PIMAGE_OPTIONAL_HEADER64;  typedef struct __IMAGE_FILE_HEADER {     WORD    Machine;     WORD    NumberOfSections;     DWORD   TimeDateStamp;     DWORD   PointerToSymbolTable;     DWORD   NumberOfSymbols;     WORD    SizeOfOptionalHeader;     WORD    Characteristics; } ___IMAGE_FILE_HEADER, * ___PIMAGE_FILE_HEADER;  typedef struct __IMAGE_NT_HEADERS64 {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER64 OptionalHeader; } ___IMAGE_NT_HEADERS64, * ___PIMAGE_NT_HEADERS64;  typedef struct __IMAGE_NT_HEADERS {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER32 OptionalHeader; } ___IMAGE_NT_HEADERS32, * ___PIMAGE_NT_HEADERS32;  typedef struct __IMAGE_IMPORT_DESCRIPTOR {     union {         DWORD   Characteristics;         DWORD   OriginalFirstThunk;     } DUMMYUNIONNAME;     DWORD   TimeDateStamp;     DWORD   ForwarderChain;     DWORD   Name;     DWORD   FirstThunk; } ___IMAGE_IMPORT_DESCRIPTOR, * ___PIMAGE_IMPORT_DESCRIPTOR;  typedef struct __IMAGE_IMPORT_BY_NAME {     WORD    Hint;     char   Name[100]; } ___IMAGE_IMPORT_BY_NAME, * ___PIMAGE_IMPORT_BY_NAME;  typedef struct __IMAGE_BASE_RELOCATION {     DWORD   VirtualAddress;     DWORD   SizeOfBlock; } ___IMAGE_BASE_RELOCATION, * ___PIMAGE_BASE_RELOCATION;  typedef struct __IMAGE_SECTION_HEADER {     BYTE    Name[___IMAGE_SIZEOF_SHORT_NAME];     union {         DWORD   PhysicalAddress;         DWORD   VirtualSize;     } Misc;     DWORD   VirtualAddress;     DWORD   SizeOfRawData;     DWORD   PointerToRawData;     DWORD   PointerToRelocations;     DWORD   PointerToLinenumbers;     WORD    NumberOfRelocations;     WORD    NumberOfLinenumbers;     DWORD   Characteristics; } ___IMAGE_SECTION_HEADER, * ___PIMAGE_SECTION_HEADER;   Custom Structures  I defined the following structures to help with the parsing process. They’re defined in the PEFILE_CUSTOM_STRUCTS.h header.  RICH_HEADER_INFO  A structure to hold information about the Rich Header during processing.  typedef struct __RICH_HEADER_INFO {     int size;     char* ptrToBuffer;     int entries; } RICH_HEADER_INFO, * PRICH_HEADER_INFO;      size: Size of the Rich Header (in bytes).   ptrToBuffer: A pointer to the buffer containing the data of the Rich Header.   entries: Number of entries in the Rich Header.   RICH_HEADER_ENTRY  A structure to represent a Rich Header entry.  typedef struct __RICH_HEADER_ENTRY {     WORD  prodID;     WORD  buildID;     DWORD useCount; } RICH_HEADER_ENTRY, * PRICH_HEADER_ENTRY;      prodID: Type ID / Product ID.   buildID: Build ID.   useCount: Use count.   RICH_HEADER  A structure to represent the Rich Header.  typedef struct __RICH_HEADER {     PRICH_HEADER_ENTRY entries; } RICH_HEADER, * PRICH_HEADER;      entries: A pointer to a RICH_HEADER_ENTRY array.   ILT_ENTRY_32  A structure to represent a 32-bit ILT entry during processing.  typedef struct __ILT_ENTRY_32 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;         DWORD ORDINAL_NAME_FLAG : 1;     } FIELD_1; } ILT_ENTRY_32, * PILT_ENTRY_32;   The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  ILT_ENTRY_64  A structure to represent a 64-bit ILT entry during processing.  typedef struct __ILT_ENTRY_64 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;     } FIELD_2;     DWORD ORDINAL_NAME_FLAG : 1; } ILT_ENTRY_64, * PILT_ENTRY_64;   The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  BASE_RELOC_ENTRY  A structure to represent a base relocation entry during processing.  typedef struct __BASE_RELOC_ENTRY {     WORD OFFSET : 12;     WORD TYPE : 4; } BASE_RELOC_ENTRY, * PBASE_RELOC_ENTRY;      OFFSET: Relocation offset.   TYPE: Relocation type.   PEFILE  Our parser will represent a PE file as an object type of either PE32FILE or PE64FILE. These 2 classes only differ in some member definitions but their functionality is identical. Throughout this post we will use the code from PE64FILE.  Definition  The class is defined as follows:  class PE64FILE { public:     PE64FILE(char* _NAME, FILE* Ppefile); 	     void PrintInfo();  private:     char* NAME;     FILE* Ppefile;     int _import_directory_count, _import_directory_size;     int _basreloc_directory_count;      // HEADERS     ___IMAGE_DOS_HEADER     PEFILE_DOS_HEADER;     ___IMAGE_NT_HEADERS64   PEFILE_NT_HEADERS;      // DOS HEADER     DWORD PEFILE_DOS_HEADER_EMAGIC;     LONG  PEFILE_DOS_HEADER_LFANEW;      // RICH HEADER     RICH_HEADER_INFO PEFILE_RICH_HEADER_INFO;     RICH_HEADER PEFILE_RICH_HEADER;      // NT_HEADERS.Signature     DWORD PEFILE_NT_HEADERS_SIGNATURE;      // NT_HEADERS.FileHeader     WORD PEFILE_NT_HEADERS_FILE_HEADER_MACHINE;     WORD PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS;     WORD PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER;      // NT_HEADERS.OptionalHeader     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE;     ULONGLONG PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS;      ___IMAGE_DATA_DIRECTORY PEFILE_EXPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_RESOURCE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_EXCEPTION_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_SECURITY_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BASERELOC_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DEBUG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_ARCHITECTURE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_GLOBALPTR_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_TLS_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_LOAD_CONFIG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BOUND_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IAT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DELAY_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_COM_DESCRIPTOR_DIRECTORY;      // SECTION HEADERS     ___PIMAGE_SECTION_HEADER PEFILE_SECTION_HEADERS;      // IMPORT TABLE     ___PIMAGE_IMPORT_DESCRIPTOR PEFILE_IMPORT_TABLE;          // BASE RELOCATION TABLE     ___PIMAGE_BASE_RELOCATION PEFILE_BASERELOC_TABLE;      // FUNCTIONS          // ADDRESS RESOLVERS     int  locate(DWORD VA);     DWORD resolve(DWORD VA, int index);      // PARSERS     void ParseFile();     void ParseDOSHeader();     void ParseNTHeaders();     void ParseSectionHeaders();     void ParseImportDirectory();     void ParseBaseReloc();     void ParseRichHeader();      // PRINT INFO     void PrintFileInfo();     void PrintDOSHeaderInfo();     void PrintRichHeaderInfo();     void PrintNTHeadersInfo();     void PrintSectionHeadersInfo();     void PrintImportTableInfo();     void PrintBaseRelocationsInfo(); };   The only public member beside the class constructor is a function called printInfo() which will print information about the file.  The class constructor takes two parameters, a char array representing the name of the file and a file pointer to the actual data of the file.  After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later.  In the end is a series of methods definitions, first two methods are called locate and resolve, I will talk about them in a minute. The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts.  Constructor  The constructor of the class simply sets the file pointer and name variables, then it calls the ParseFile() function.  PE64FILE::PE64FILE(char* _NAME, FILE* _Ppefile) { 	 	NAME = _NAME; 	Ppefile = _Ppefile;  	ParseFile();  }   The ParseFile() function calls the other parser functions:  void PE64FILE::ParseFile() {  	// PARSE DOS HEADER 	ParseDOSHeader();  	// PARSE RICH HEADER 	ParseRichHeader();  	//PARSE NT HEADERS 	ParseNTHeaders();  	// PARSE SECTION HEADERS 	ParseSectionHeaders();  	// PARSE IMPORT DIRECTORY 	ParseImportDirectory();  	// PARSE BASE RELOCATIONS 	ParseBaseReloc();  }   Resolving RVAs  Most of the time, we’ll have a RVA that we’ll need to change to a file offset. The process of resolving an RVA can be outlined as follows:     Determine which section range contains that RVA:            Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section.       If the RVA exists within this range then it belongs to that section.           Calculate the file offset:            Subtract the RVA from the section virtual address.       Add that value to the raw data pointer of the section.           An example of this is locating a Data Directory. The IMAGE_DATA_DIRECTORY structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address.  I wrote two functions to do this, first one to locate the virtual address (locate()), second one to resolve the address (resolve()).  int PE64FILE::locate(DWORD VA) { 	 	int index; 	 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		if (VA &gt;= PEFILE_SECTION_HEADERS[i].VirtualAddress 			&amp;&amp; VA &lt; (PEFILE_SECTION_HEADERS[i].VirtualAddress + PEFILE_SECTION_HEADERS[i].Misc.VirtualSize)){ 			index = i; 			break; 		} 	} 	return index; }  DWORD PE64FILE::resolve(DWORD VA, int index) {  	return (VA - PEFILE_SECTION_HEADERS[index].VirtualAddress) + PEFILE_SECTION_HEADERS[index].PointerToRawData;  }   locate() iterates over the PEFILE_SECTION_HEADERS array, compares the RVA as described above, then it returns the index of the appropriate section header within the PEFILE_SECTION_HEADERS array.  Please note that in order for these functions to work we’ll need to parse out the section headers and fill the PEFILE_SECTION_HEADERS array first. We still haven’t discussed this part, but I wanted to talk about the address resolvers first.  main function  The main function of the program is fairly simple, it only does 2 things:     Create a file pointer to the given file, and validate that the file was read correctly.   Call INITPARSE() on the file, and based on the return value it decides between three actions:            Exit.       Create a PE32FILE object, call PrintInfo(), close the file pointer then exit.       Create a PE64FILE object, call PrintInfo(), close the file pointer then exit.           PrintInfo() calls the other print info functions.  int main(int argc, char* argv[]) { 	if (argc != 2) { 		printf(&quot;Usage: %s [path to executable]\n&quot;, argv[0]); 		return 1; 	}  	FILE * PpeFile; 	fopen_s(&amp;PpeFile, argv[1], &quot;rb&quot;);  	if (PpeFile == NULL) { 		printf(&quot;Can&#39;t open file.\n&quot;); 		return 1; 	}  	if (INITPARSE(PpeFile) == 1) { 		exit(1); 	} 	else if (INITPARSE(PpeFile) == 32) { 		PE32FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	} 	else if (INITPARSE(PpeFile) == 64) { 		PE64FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	}  	return 0; }   INITPARSE()  INITPARSE() is a function defined in PEFILE.cpp. Its only job is to validate that the given file is a PE file, then determine whether the file is PE32 or PE32+.  It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error.  After validating the PE file, it sets the file position to (DOS_HEADER.e_lfanew + size of DWORD (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header. Then it reads a WORD, we know that the first WORD of the Optional Header is a magic value that indicates the file type, it then compares that word to IMAGE_NT_OPTIONAL_HDR32_MAGIC and IMAGE_NT_OPTIONAL_HDR64_MAGIC, and based on the comparison results it either returns 32 or 64 indicating PE32 or PE32+, or it returns an error.  int INITPARSE(FILE* PpeFile) {  	___IMAGE_DOS_HEADER TMP_DOS_HEADER; 	WORD PEFILE_TYPE;  	fseek(PpeFile, 0, SEEK_SET); 	fread(&amp;TMP_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, PpeFile);  	if (TMP_DOS_HEADER.e_magic != ___IMAGE_DOS_SIGNATURE) { 		printf(&quot;Error. Not a PE file.\n&quot;); 		return 1; 	}  	fseek(PpeFile, (TMP_DOS_HEADER.e_lfanew + sizeof(DWORD) + sizeof(___IMAGE_FILE_HEADER)), SEEK_SET); 	fread(&amp;PEFILE_TYPE, sizeof(WORD), 1, PpeFile);  	if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR32_MAGIC) { 		return 32; 	} 	else if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR64_MAGIC) { 		return 64; 	} 	else { 		printf(&quot;Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\n&quot;); 		return 1; 	}  }     Parsing DOS Header  ParseDOSHeader()  Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member PEFILE_DOS_HEADER. From there we can access all of the struct members, however we’re only interested in e_magic and e_lfanew.  void PE64FILE::ParseDOSHeader() { 	 	fseek(Ppefile, 0, SEEK_SET); 	fread(&amp;PEFILE_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, Ppefile);  	PEFILE_DOS_HEADER_EMAGIC = PEFILE_DOS_HEADER.e_magic; 	PEFILE_DOS_HEADER_LFANEW = PEFILE_DOS_HEADER.e_lfanew;  }   PrintDOSHeaderInfo()  This function prints e_magic and e_lfanew values.  void PE64FILE::PrintDOSHeaderInfo() { 	 	printf(&quot; DOS HEADER:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; Magic: 0x%X\n&quot;, PEFILE_DOS_HEADER_EMAGIC); 	printf(&quot; File address of new exe header: 0x%X\n&quot;, PEFILE_DOS_HEADER_LFANEW);  }       Parsing Rich Header  Process  To parse out the Rich Header we’ll need to go through multiple steps.  We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place.  First of all, we need to locate the Rich Header. We don’t know the exact location, however we have everything we need to locate it. We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers. We also know that any Rich Header ends with a 32-bit value Rich followed by the XOR key.  One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed. A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the Rich sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header.  Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the Rich signature and keep XORing 4 bytes at a time until we reach the DanS signature which indicates the beginning of the Rich Header.  After obtaining the position and the size of the Rich Header, we can normally read and process the data.  ParseRichHeader()  This function starts by allocating a buffer on the heap, then it reads e_lfanew size of bytes from the beginning of the file and stores the data in the allocated buffer.  It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to 0x52 (R) and 0x69 (i). When the sequence is found, it stores the index in a variable then the loop breaks.  	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}   After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments RichHeaderSize by 4 until it reaches the DanS sequence.  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}   After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates PEFILE_RICH_HEADER_INFO with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing.  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;   The rest of the function reads each entry of the Rich Header and updates PEFILE_RICH_HEADER.  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;   Here’s the full function:  void PE64FILE::ParseRichHeader() { 	 	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;  }   PrintRichHeaderInfo()  This function iterates over each entry in PEFILE_RICH_HEADER and prints its value.  void PE64FILE::PrintRichHeaderInfo() { 	 	printf(&quot; RICH HEADER:\n&quot;); 	printf(&quot; ------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_RICH_HEADER_INFO.entries; i++) { 		printf(&quot; 0x%X 0x%X 0x%X: %d.%d.%d\n&quot;, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount); 	}  }       Parsing NT Headers  ParseNTHeaders()  Similar to the DOS Header, all we need to do is to read from e_lfanew an amount of bytes equal to the size of IMAGE_NT_HEADERS.  After that we can parse out the contents of the File Header and the Optional Header.  The Optional Header contains an array of IMAGE_DATA_DIRECTORY structures which we care about. To parse out this information, we can use the IMAGE_DIRECTORY_[...] constants defined in winnt.h as array indexes to access the corresponding IMAGE_DATA_DIRECTORY structure of each Data Directory.  void PE64FILE::ParseNTHeaders() { 	 	fseek(Ppefile, PEFILE_DOS_HEADER.e_lfanew, SEEK_SET); 	fread(&amp;PEFILE_NT_HEADERS, sizeof(PEFILE_NT_HEADERS), 1, Ppefile);  	PEFILE_NT_HEADERS_SIGNATURE = PEFILE_NT_HEADERS.Signature;  	PEFILE_NT_HEADERS_FILE_HEADER_MACHINE = PEFILE_NT_HEADERS.FileHeader.Machine; 	PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS = PEFILE_NT_HEADERS.FileHeader.NumberOfSections; 	PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER = PEFILE_NT_HEADERS.FileHeader.SizeOfOptionalHeader;  	PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC = PEFILE_NT_HEADERS.OptionalHeader.Magic; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfInitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT = PEFILE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.BaseOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE = PEFILE_NT_HEADERS.OptionalHeader.ImageBase; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.SectionAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.FileAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfImage; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS = PEFILE_NT_HEADERS.OptionalHeader.SizeOfHeaders;  	PEFILE_EXPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT]; 	PEFILE_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT]; 	PEFILE_RESOURCE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE]; 	PEFILE_EXCEPTION_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXCEPTION]; 	PEFILE_SECURITY_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_SECURITY]; 	PEFILE_BASERELOC_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC]; 	PEFILE_DEBUG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DEBUG]; 	PEFILE_ARCHITECTURE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE]; 	PEFILE_GLOBALPTR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_GLOBALPTR]; 	PEFILE_TLS_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_TLS]; 	PEFILE_LOAD_CONFIG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]; 	PEFILE_BOUND_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]; 	PEFILE_IAT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IAT]; 	PEFILE_DELAY_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]; 	PEFILE_COM_DESCRIPTOR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];  }   PrintNTHeadersInfo()  This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size.  void PE64FILE::PrintNTHeadersInfo() { 	 	printf(&quot; NT HEADERS:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; PE Signature: 0x%X\n&quot;, PEFILE_NT_HEADERS_SIGNATURE);  	printf(&quot;\n File Header:\n\n&quot;); 	printf(&quot;   Machine: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_MACHINE); 	printf(&quot;   Number of sections: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS); 	printf(&quot;   Size of optional header: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER);  	printf(&quot;\n Optional Header:\n\n&quot;); 	printf(&quot;   Magic: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC); 	printf(&quot;   Size of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE); 	printf(&quot;   Size of initialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA); 	printf(&quot;   Size of uninitialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA); 	printf(&quot;   Address of entry point: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT); 	printf(&quot;   RVA of start of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE); 	printf(&quot;   Desired image base: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE); 	printf(&quot;   Section alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT); 	printf(&quot;   File alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT); 	printf(&quot;   Size of image: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE); 	printf(&quot;   Size of headers: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS);  	printf(&quot;\n Data Directories:\n&quot;); 	printf(&quot;\n   * Export Directory:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.Size); 	. 	. 	[REDACTED] 	. 	. 	printf(&quot;\n   * COM Runtime Descriptor:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.Size);  }       Parsing Section Headers  ParseSectionHeaders()  This function starts by assigning the PEFILE_SECTION_HEADERS class member to a pointer to an IMAGE_SECTION_HEADER array of the count of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS.  Then it goes into a loop of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS iterations where in each iteration it changes the file offset to (e_lfanew + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of PEFILE_SECTION_HEADERS.  void PE64FILE::ParseSectionHeaders() { 	 	PEFILE_SECTION_HEADERS = new ___IMAGE_SECTION_HEADER[PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS]; 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		int offset = (PEFILE_DOS_HEADER.e_lfanew + sizeof(PEFILE_NT_HEADERS)) + (i * ___IMAGE_SIZEOF_SECTION_HEADER); 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_SECTION_HEADERS[i], ___IMAGE_SIZEOF_SECTION_HEADER, 1, Ppefile); 	}  }   PrintSectionHeadersInfo()  This function loops over the Section Headers array (filled by ParseSectionHeaders()), and it prints information about each section.  void PE64FILE::PrintSectionHeadersInfo() { 	 	printf(&quot; SECTION HEADERS:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		printf(&quot;   * %.8s:\n&quot;, PEFILE_SECTION_HEADERS[i].Name); 		printf(&quot;        VirtualAddress: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].VirtualAddress); 		printf(&quot;        VirtualSize: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].Misc.VirtualSize); 		printf(&quot;        PointerToRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].PointerToRawData); 		printf(&quot;        SizeOfRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].SizeOfRawData); 		printf(&quot;        Characteristics: 0x%X\n\n&quot;, PEFILE_SECTION_HEADERS[i].Characteristics); 	}  }       Parsing Imports  ParseImportDirectory()  To parse out the Import Directory Table we need to determine the count of IMAGE_IMPORT_DESCRIPTORs first.  This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor. In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks. Otherwise it increments _import_directory_count and the loop continues.  After finding the size of the Import Directory, the function assigns the PEFILE_IMPORT_TABLE class member to a pointer to an IMAGE_IMPORT_DESCRIPTOR array of the count of _import_directory_count then goes into another loop similar to the one we’ve seen in ParseSectionHeaders() to parse out the import descriptors.  void PE64FILE::ParseImportDirectory() { 	 	DWORD _import_directory_address = resolve(PEFILE_IMPORT_DIRECTORY.VirtualAddress, locate(PEFILE_IMPORT_DIRECTORY.VirtualAddress)); 	_import_directory_count = 0;  	while (true) { 		___IMAGE_IMPORT_DESCRIPTOR tmp; 		int offset = (_import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile);  		if (tmp.Name == 0x00000000 &amp;&amp; tmp.FirstThunk == 0x00000000) { 			_import_directory_count -= 1; 			_import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR); 			break; 		}  		_import_directory_count++; 	}  	PEFILE_IMPORT_TABLE = new ___IMAGE_IMPORT_DESCRIPTOR[_import_directory_count];  	for (int i = 0; i &lt; _import_directory_count; i++) { 		int offset = (i * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_IMPORT_TABLE[i], sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile); 	}  }   PrintImportTableInfo()  After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions. This is done by the PrintImportTableInfo() function.  This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not.  After that it resolves the file offset of the ILT then it parses out each ILT entry. If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint.  If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts.  We’ve discussed the details about this in the PE imports post.  void PE64FILE::PrintImportTableInfo() { 	 	printf(&quot; IMPORT TABLE:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; _import_directory_count; i++) { 		DWORD NameAddr = resolve(PEFILE_IMPORT_TABLE[i].Name, locate(PEFILE_IMPORT_TABLE[i].Name)); 		int NameSize = 0;  		while (true) { 			char tmp; 			fseek(Ppefile, (NameAddr + NameSize), SEEK_SET); 			fread(&amp;tmp, sizeof(char), 1, Ppefile);  			if (tmp == 0x00) { 				break; 			}  			NameSize++; 		}  		char* Name = new char[NameSize + 2]; 		fseek(Ppefile, NameAddr, SEEK_SET); 		fread(Name, (NameSize * sizeof(char)) + 1, 1, Ppefile); 		printf(&quot;   * %s:\n&quot;, Name); 		delete[] Name;  		printf(&quot;       ILT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk); 		printf(&quot;       IAT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].FirstThunk);  		if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == 0) { 			printf(&quot;       Bound: FALSE\n&quot;); 		} 		else if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == -1) { 			printf(&quot;       Bound: TRUE\n&quot;); 		}  		printf(&quot;\n&quot;);  		DWORD ILTAddr = resolve(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk, locate(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk)); 		int entrycounter = 0;  		while (true) {  			ILT_ENTRY_64 entry;  			fseek(Ppefile, (ILTAddr + (entrycounter * sizeof(QWORD))), SEEK_SET); 			fread(&amp;entry, sizeof(ILT_ENTRY_64), 1, Ppefile);  			BYTE flag = entry.ORDINAL_NAME_FLAG; 			DWORD HintRVA = 0x0; 			WORD ordinal = 0x0;  			if (flag == 0x0) { 				HintRVA = entry.FIELD_2.HINT_NAME_TABE; 			} 			else if (flag == 0x01) { 				ordinal = entry.FIELD_2.ORDINAL; 			}  			if (flag == 0x0 &amp;&amp; HintRVA == 0x0 &amp;&amp; ordinal == 0x0) { 				break; 			}  			printf(&quot;\n       Entry:\n&quot;);  			if (flag == 0x0) { 				___IMAGE_IMPORT_BY_NAME hint;  				DWORD HintAddr = resolve(HintRVA, locate(HintRVA)); 				fseek(Ppefile, HintAddr, SEEK_SET); 				fread(&amp;hint, sizeof(___IMAGE_IMPORT_BY_NAME), 1, Ppefile); 				printf(&quot;         Name: %s\n&quot;, hint.Name); 				printf(&quot;         Hint RVA: 0x%X\n&quot;, HintRVA); 				printf(&quot;         Hint: 0x%X\n&quot;, hint.Hint); 			} 			else if (flag == 1) { 				printf(&quot;         Ordinal: 0x%X\n&quot;, ordinal); 			}  			entrycounter++; 		}  		printf(&quot;\n   ----------------------\n\n&quot;);  	}  }       Parsing Base Relocations  ParseBaseReloc()  This function follows the same process we’ve seen in ParseImportDirectory(). It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each IMAGE_BASE_RELOCATION structure in PEFILE_BASERELOC_TABLE. One thing to note here that is different from what we’ve seen in ParseImportDirectory() is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of SizeOfBlock of each block in each iteration. We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks.  void PE64FILE::ParseBaseReloc() { 	 	DWORD _basereloc_directory_address = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 	_basreloc_directory_count = 0; 	int _basereloc_size_counter = 0;  	while (true) { 		___IMAGE_BASE_RELOCATION tmp;  		int offset = (_basereloc_size_counter + _basereloc_directory_address);  		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile);  		if (tmp.VirtualAddress == 0x00000000 &amp;&amp; 			tmp.SizeOfBlock == 0x00000000) { 			break; 		}  		_basreloc_directory_count++; 		_basereloc_size_counter += tmp.SizeOfBlock; 	}  	PEFILE_BASERELOC_TABLE = new ___IMAGE_BASE_RELOCATION[_basreloc_directory_count];  	_basereloc_size_counter = 0;  	for (int i = 0; i &lt; _basreloc_directory_count; i++) { 		int offset = _basereloc_directory_address + _basereloc_size_counter; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_BASERELOC_TABLE[i], sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile); 		_basereloc_size_counter += PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 	}  }   PrintBaseRelocationInfo()  This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of IMAGE_BASE_RELOCATION from the block size then dividing that by the size of a WORD). After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them.  We’ve discussed the details about this in the PE base relocations post.  void PE64FILE::PrintBaseRelocationsInfo() { 	 	printf(&quot; BASE RELOCATIONS TABLE:\n&quot;); 	printf(&quot; -----------------------\n&quot;);  	int szCounter = sizeof(___IMAGE_BASE_RELOCATION);  	for (int i = 0; i &lt; _basreloc_directory_count; i++) {  		DWORD PAGERVA, BLOCKSIZE, BASE_RELOC_ADDR; 		int ENTRIES;  		BASE_RELOC_ADDR = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 		PAGERVA = PEFILE_BASERELOC_TABLE[i].VirtualAddress; 		BLOCKSIZE = PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 		ENTRIES = (BLOCKSIZE - sizeof(___IMAGE_BASE_RELOCATION)) / sizeof(WORD);  		printf(&quot;\n   Block 0x%X: \n&quot;, i); 		printf(&quot;     Page RVA: 0x%X\n&quot;, PAGERVA); 		printf(&quot;     Block size: 0x%X\n&quot;, BLOCKSIZE); 		printf(&quot;     Number of entries: 0x%X\n&quot;, ENTRIES); 		printf(&quot;\n     Entries:\n&quot;);  		for (int i = 0; i &lt; ENTRIES; i++) {  			BASE_RELOC_ENTRY entry;  			int offset = (BASE_RELOC_ADDR + szCounter + (i * sizeof(WORD)));  			fseek(Ppefile, offset, SEEK_SET); 			fread(&amp;entry, sizeof(WORD), 1, Ppefile);  			printf(&quot;\n       * Value: 0x%X\n&quot;, entry); 			printf(&quot;         Relocation Type: 0x%X\n&quot;, entry.TYPE); 			printf(&quot;         Offset: 0x%X\n&quot;, entry.OFFSET);  		} 		printf(&quot;\n   ----------------------\n\n&quot;); 		szCounter += BLOCKSIZE; 	}  }       Conclusion  Here’s the full output after running the parser on a file:  Desktop&gt;.\PE-Parser.exe .\SimpleApp64.exe    FILE: .\SimpleApp64.exe  TYPE: 0x20B (PE32+)   ----------------------------------   DOS HEADER:  -----------   Magic: 0x5A4D  File address of new exe header: 0x100   ----------------------------------   RICH HEADER:  ------------   0x7809 0x93 0xA: 30729.147.10  0x6FCB 0x101 0x2: 28619.257.2  0x6FCB 0x105 0x11: 28619.261.17  0x6FCB 0x104 0xA: 28619.260.10  0x6FCB 0x103 0x3: 28619.259.3  0x685B 0x101 0x5: 26715.257.5  0x0 0x1 0x30: 0.1.48  0x7086 0x109 0x1: 28806.265.1  0x7086 0xFF 0x1: 28806.255.1  0x7086 0x102 0x1: 28806.258.1   ----------------------------------   NT HEADERS:  -----------   PE Signature: 0x4550   File Header:     Machine: 0x8664    Number of sections: 0x6    Size of optional header: 0xF0   Optional Header:     Magic: 0x20B    Size of code section: 0xE00    Size of initialized data: 0x1E00    Size of uninitialized data: 0x0    Address of entry point: 0x12C4    RVA of start of code section: 0x1000    Desired image base: 0x40000000    Section alignment: 0x1000    File alignment: 0x200    Size of image: 0x7000    Size of headers: 0x400   Data Directories:     * Export Directory:        RVA: 0x0        Size: 0x0     * Import Directory:        RVA: 0x27AC        Size: 0xB4     * Resource Directory:        RVA: 0x5000        Size: 0x1E0     * Exception Directory:        RVA: 0x4000        Size: 0x168     * Security Directory:        RVA: 0x0        Size: 0x0     * Base Relocation Table:        RVA: 0x6000        Size: 0x28     * Debug Directory:        RVA: 0x2248        Size: 0x70     * Architecture Specific Data:        RVA: 0x0        Size: 0x0     * RVA of GlobalPtr:        RVA: 0x0        Size: 0x0     * TLS Directory:        RVA: 0x0        Size: 0x0     * Load Configuration Directory:        RVA: 0x22C0        Size: 0x130     * Bound Import Directory:        RVA: 0x0        Size: 0x0     * Import Address Table:        RVA: 0x2000        Size: 0x198     * Delay Load Import Descriptors:        RVA: 0x0        Size: 0x0     * COM Runtime Descriptor:        RVA: 0x0        Size: 0x0   ----------------------------------   SECTION HEADERS:  ----------------     * .text:         VirtualAddress: 0x1000         VirtualSize: 0xD2C         PointerToRawData: 0x400         SizeOfRawData: 0xE00         Characteristics: 0x60000020     * .rdata:         VirtualAddress: 0x2000         VirtualSize: 0xE3C         PointerToRawData: 0x1200         SizeOfRawData: 0x1000         Characteristics: 0x40000040     * .data:         VirtualAddress: 0x3000         VirtualSize: 0x638         PointerToRawData: 0x2200         SizeOfRawData: 0x200         Characteristics: 0xC0000040     * .pdata:         VirtualAddress: 0x4000         VirtualSize: 0x168         PointerToRawData: 0x2400         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .rsrc:         VirtualAddress: 0x5000         VirtualSize: 0x1E0         PointerToRawData: 0x2600         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .reloc:         VirtualAddress: 0x6000         VirtualSize: 0x28         PointerToRawData: 0x2800         SizeOfRawData: 0x200         Characteristics: 0x42000040    ----------------------------------   IMPORT TABLE:  ----------------     * USER32.dll:        ILT RVA: 0x28E0        IAT RVA: 0x2080        Bound: FALSE          Entry:          Name: MessageBoxA          Hint RVA: 0x29F8          Hint: 0x283     ----------------------     * VCRUNTIME140.dll:        ILT RVA: 0x28F0        IAT RVA: 0x2090        Bound: FALSE          Entry:          Name: memset          Hint RVA: 0x2A5E          Hint: 0x3E         Entry:          Name: __current_exception_context          Hint RVA: 0x2A40          Hint: 0x1C         Entry:          Name: __current_exception          Hint RVA: 0x2A2A          Hint: 0x1B         Entry:          Name: __C_specific_handler          Hint RVA: 0x2A12          Hint: 0x8     ----------------------     * api-ms-win-crt-runtime-l1-1-0.dll:        ILT RVA: 0x2948        IAT RVA: 0x20E8        Bound: FALSE          Entry:          Name: _crt_atexit          Hint RVA: 0x2C12          Hint: 0x1E         Entry:          Name: terminate          Hint RVA: 0x2C20          Hint: 0x67         Entry:          Name: _exit          Hint RVA: 0x2B30          Hint: 0x23         Entry:          Name: _register_thread_local_exe_atexit_callback          Hint RVA: 0x2B76          Hint: 0x3D         Entry:          Name: _c_exit          Hint RVA: 0x2B6C          Hint: 0x15         Entry:          Name: exit          Hint RVA: 0x2B28          Hint: 0x55         Entry:          Name: _initterm_e          Hint RVA: 0x2B1A          Hint: 0x37         Entry:          Name: _initterm          Hint RVA: 0x2B0E          Hint: 0x36         Entry:          Name: _get_initial_narrow_environment          Hint RVA: 0x2AEC          Hint: 0x28         Entry:          Name: _initialize_narrow_environment          Hint RVA: 0x2ACA          Hint: 0x33         Entry:          Name: _configure_narrow_argv          Hint RVA: 0x2AB0          Hint: 0x18         Entry:          Name: _initialize_onexit_table          Hint RVA: 0x2BDA          Hint: 0x34         Entry:          Name: _set_app_type          Hint RVA: 0x2A8C          Hint: 0x42         Entry:          Name: _seh_filter_exe          Hint RVA: 0x2A7A          Hint: 0x40         Entry:          Name: _cexit          Hint RVA: 0x2B62          Hint: 0x16         Entry:          Name: __p___argv          Hint RVA: 0x2B54          Hint: 0x5         Entry:          Name: __p___argc          Hint RVA: 0x2B46          Hint: 0x4         Entry:          Name: _register_onexit_function          Hint RVA: 0x2BF6          Hint: 0x3C     ----------------------     * api-ms-win-crt-math-l1-1-0.dll:        ILT RVA: 0x2938        IAT RVA: 0x20D8        Bound: FALSE          Entry:          Name: __setusermatherr          Hint RVA: 0x2A9C          Hint: 0x9     ----------------------     * api-ms-win-crt-stdio-l1-1-0.dll:        ILT RVA: 0x29E0        IAT RVA: 0x2180        Bound: FALSE          Entry:          Name: __p__commode          Hint RVA: 0x2BCA          Hint: 0x1         Entry:          Name: _set_fmode          Hint RVA: 0x2B38          Hint: 0x54     ----------------------     * api-ms-win-crt-locale-l1-1-0.dll:        ILT RVA: 0x2928        IAT RVA: 0x20C8        Bound: FALSE          Entry:          Name: _configthreadlocale          Hint RVA: 0x2BA4          Hint: 0x8     ----------------------     * api-ms-win-crt-heap-l1-1-0.dll:        ILT RVA: 0x2918        IAT RVA: 0x20B8        Bound: FALSE          Entry:          Name: _set_new_mode          Hint RVA: 0x2BBA          Hint: 0x16     ----------------------    ----------------------------------   BASE RELOCATIONS TABLE:  -----------------------     Block 0x0:      Page RVA: 0x2000      Block size: 0x28      Number of entries: 0x10       Entries:         * Value: 0xA198          Relocation Type: 0xA          Offset: 0x198         * Value: 0xA1A0          Relocation Type: 0xA          Offset: 0x1A0         * Value: 0xA1A8          Relocation Type: 0xA          Offset: 0x1A8         * Value: 0xA1B0          Relocation Type: 0xA          Offset: 0x1B0         * Value: 0xA1B8          Relocation Type: 0xA          Offset: 0x1B8         * Value: 0xA1C8          Relocation Type: 0xA          Offset: 0x1C8         * Value: 0xA1E0          Relocation Type: 0xA          Offset: 0x1E0         * Value: 0xA1E8          Relocation Type: 0xA          Offset: 0x1E8         * Value: 0xA220          Relocation Type: 0xA          Offset: 0x220         * Value: 0xA228          Relocation Type: 0xA          Offset: 0x228         * Value: 0xA318          Relocation Type: 0xA          Offset: 0x318         * Value: 0xA330          Relocation Type: 0xA          Offset: 0x330         * Value: 0xA338          Relocation Type: 0xA          Offset: 0x338         * Value: 0xA3D8          Relocation Type: 0xA          Offset: 0x3D8         * Value: 0xA3E0          Relocation Type: 0xA          Offset: 0x3E0         * Value: 0xA3E8          Relocation Type: 0xA          Offset: 0x3E8     ----------------------    ----------------------------------   I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts. I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated.  Thanks for reading.">





  <meta name="twitter:site" content="@ahm3d_h3sham">
  <meta name="twitter:title" content="A dive into the PE file format - LAB 1: Writing a PE Parser">
  <meta name="twitter:description" content="A dive into the PE file format - LAB 1: Writing a PE Parser  Introduction  In the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept.  The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure. We’re going to focus on PE32 and PE32+ files, and we’ll only parse the following parts of the file:     DOS Header   Rich Header   NT Headers   Data Directories (within the Optional Header)   Section Headers   Import Table   Base Relocations Table   The code of this project can be found on my github profile.    Initial Setup  Process Outline  We want out parser to follow the following process:     Read a file.   Validate that it’s a PE file.   Determine whether it’s a PE32 or a PE32+.   Parse out the following structures:            DOS Header       Rich Header       NT Headers       Section Headers       Import Data Directory       Base Relocation Data Directory           Print out the following information:            File name and type.       DOS Header:                    Magic value.           Address of new exe header.                       Each entry of the Rich Header, decrypted and decoded.       NT Headers - PE file signature.       NT Headers - File Header:                    Machine value.           Number of sections.           Size of Optional Header.                       NT Headers - Optional Header:                    Magic value.           Size of code section.           Size of initialized data.           Size of uninitialized data.           Address of entry point.           RVA of start of code section.           Desired Image Base.           Section alignment.           File alignment.           Size of image.           Size of headers.                       For each Data Directory: its name, RVA and size.       For each Section Header:                    Section name.           Section virtual address and size.           Section raw data pointer and size.           Section characteristics value.                       Import Table:                    For each DLL:                            DLL name.               ILT and IAT RVAs.               Whether its a bound import or not.               for every imported function:                                    Ordinal if ordinal/name flag is 1.                   Name, hint and Hint/Name table RVA if ordinal/name flag is 0.                                                                               Base Relocation Table:                    For each block:                            Page RVA.               Block size.               Number of entries.               For each entry:                                    Raw value.                   Relocation offset.                   Relocation Type.                                                                                   winnt.h Definitions  We will need the following definitions from the winnt.h header:     Types:            BYTE       WORD       DWORD       QWORD       LONG       LONGLONG       ULONGLONG           Constants:            IMAGE_NT_OPTIONAL_HDR32_MAGIC       IMAGE_NT_OPTIONAL_HDR64_MAGIC       IMAGE_NUMBEROF_DIRECTORY_ENTRIES       IMAGE_DOS_SIGNATURE       IMAGE_DIRECTORY_ENTRY_EXPORT       IMAGE_DIRECTORY_ENTRY_IMPORT       IMAGE_DIRECTORY_ENTRY_RESOURCE       IMAGE_DIRECTORY_ENTRY_EXCEPTION       IMAGE_DIRECTORY_ENTRY_SECURITY       IMAGE_DIRECTORY_ENTRY_BASERELOC       IMAGE_DIRECTORY_ENTRY_DEBUG       IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       IMAGE_DIRECTORY_ENTRY_GLOBALPTR       IMAGE_DIRECTORY_ENTRY_TLS       IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG       IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       IMAGE_DIRECTORY_ENTRY_IAT       IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR       IMAGE_SIZEOF_SHORT_NAME       IMAGE_SIZEOF_SECTION_HEADER           Structures:            IMAGE_DOS_HEADER       IMAGE_DATA_DIRECTORY       IMAGE_OPTIONAL_HEADER32       IMAGE_OPTIONAL_HEADER64       IMAGE_FILE_HEADER       IMAGE_NT_HEADERS32       IMAGE_NT_HEADERS64       IMAGE_IMPORT_DESCRIPTOR       IMAGE_IMPORT_BY_NAME       IMAGE_BASE_RELOCATION       IMAGE_SECTION_HEADER           I took these definitions from winnt.h and added them to a new header called winntdef.h.  winntdef.h:  typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned long DWORD; typedef unsigned long long QWORD; typedef unsigned long LONG; typedef __int64 LONGLONG; typedef unsigned __int64 ULONGLONG;  #define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC       0x10b #define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC       0x20b #define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16 #define ___IMAGE_DOS_SIGNATURE                 0x5A4D  #define ___IMAGE_DIRECTORY_ENTRY_EXPORT          0 #define ___IMAGE_DIRECTORY_ENTRY_IMPORT          1 #define ___IMAGE_DIRECTORY_ENTRY_RESOURCE        2 #define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 #define ___IMAGE_DIRECTORY_ENTRY_SECURITY        4 #define ___IMAGE_DIRECTORY_ENTRY_BASERELOC       5 #define ___IMAGE_DIRECTORY_ENTRY_DEBUG           6 #define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7 #define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8 #define ___IMAGE_DIRECTORY_ENTRY_TLS             9 #define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10 #define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11 #define ___IMAGE_DIRECTORY_ENTRY_IAT            12 #define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13 #define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14  #define ___IMAGE_SIZEOF_SHORT_NAME              8 #define ___IMAGE_SIZEOF_SECTION_HEADER          40  typedef struct __IMAGE_DOS_HEADER {     WORD   e_magic;     WORD   e_cblp;     WORD   e_cp;     WORD   e_crlc;     WORD   e_cparhdr;     WORD   e_minalloc;     WORD   e_maxalloc;     WORD   e_ss;     WORD   e_sp;     WORD   e_csum;     WORD   e_ip;     WORD   e_cs;     WORD   e_lfarlc;     WORD   e_ovno;     WORD   e_res[4];     WORD   e_oemid;     WORD   e_oeminfo;     WORD   e_res2[10];     LONG   e_lfanew; } ___IMAGE_DOS_HEADER, * ___PIMAGE_DOS_HEADER;  typedef struct __IMAGE_DATA_DIRECTORY {     DWORD   VirtualAddress;     DWORD   Size; } ___IMAGE_DATA_DIRECTORY, * ___PIMAGE_DATA_DIRECTORY;   typedef struct __IMAGE_OPTIONAL_HEADER {     WORD    Magic;     BYTE    MajorLinkerVersion;     BYTE    MinorLinkerVersion;     DWORD   SizeOfCode;     DWORD   SizeOfInitializedData;     DWORD   SizeOfUninitializedData;     DWORD   AddressOfEntryPoint;     DWORD   BaseOfCode;     DWORD   BaseOfData;     DWORD   ImageBase;     DWORD   SectionAlignment;     DWORD   FileAlignment;     WORD    MajorOperatingSystemVersion;     WORD    MinorOperatingSystemVersion;     WORD    MajorImageVersion;     WORD    MinorImageVersion;     WORD    MajorSubsystemVersion;     WORD    MinorSubsystemVersion;     DWORD   Win32VersionValue;     DWORD   SizeOfImage;     DWORD   SizeOfHeaders;     DWORD   CheckSum;     WORD    Subsystem;     WORD    DllCharacteristics;     DWORD   SizeOfStackReserve;     DWORD   SizeOfStackCommit;     DWORD   SizeOfHeapReserve;     DWORD   SizeOfHeapCommit;     DWORD   LoaderFlags;     DWORD   NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER32, * ___PIMAGE_OPTIONAL_HEADER32;  typedef struct __IMAGE_OPTIONAL_HEADER64 {     WORD        Magic;     BYTE        MajorLinkerVersion;     BYTE        MinorLinkerVersion;     DWORD       SizeOfCode;     DWORD       SizeOfInitializedData;     DWORD       SizeOfUninitializedData;     DWORD       AddressOfEntryPoint;     DWORD       BaseOfCode;     ULONGLONG   ImageBase;     DWORD       SectionAlignment;     DWORD       FileAlignment;     WORD        MajorOperatingSystemVersion;     WORD        MinorOperatingSystemVersion;     WORD        MajorImageVersion;     WORD        MinorImageVersion;     WORD        MajorSubsystemVersion;     WORD        MinorSubsystemVersion;     DWORD       Win32VersionValue;     DWORD       SizeOfImage;     DWORD       SizeOfHeaders;     DWORD       CheckSum;     WORD        Subsystem;     WORD        DllCharacteristics;     ULONGLONG   SizeOfStackReserve;     ULONGLONG   SizeOfStackCommit;     ULONGLONG   SizeOfHeapReserve;     ULONGLONG   SizeOfHeapCommit;     DWORD       LoaderFlags;     DWORD       NumberOfRvaAndSizes;     ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER64, * ___PIMAGE_OPTIONAL_HEADER64;  typedef struct __IMAGE_FILE_HEADER {     WORD    Machine;     WORD    NumberOfSections;     DWORD   TimeDateStamp;     DWORD   PointerToSymbolTable;     DWORD   NumberOfSymbols;     WORD    SizeOfOptionalHeader;     WORD    Characteristics; } ___IMAGE_FILE_HEADER, * ___PIMAGE_FILE_HEADER;  typedef struct __IMAGE_NT_HEADERS64 {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER64 OptionalHeader; } ___IMAGE_NT_HEADERS64, * ___PIMAGE_NT_HEADERS64;  typedef struct __IMAGE_NT_HEADERS {     DWORD Signature;     ___IMAGE_FILE_HEADER FileHeader;     ___IMAGE_OPTIONAL_HEADER32 OptionalHeader; } ___IMAGE_NT_HEADERS32, * ___PIMAGE_NT_HEADERS32;  typedef struct __IMAGE_IMPORT_DESCRIPTOR {     union {         DWORD   Characteristics;         DWORD   OriginalFirstThunk;     } DUMMYUNIONNAME;     DWORD   TimeDateStamp;     DWORD   ForwarderChain;     DWORD   Name;     DWORD   FirstThunk; } ___IMAGE_IMPORT_DESCRIPTOR, * ___PIMAGE_IMPORT_DESCRIPTOR;  typedef struct __IMAGE_IMPORT_BY_NAME {     WORD    Hint;     char   Name[100]; } ___IMAGE_IMPORT_BY_NAME, * ___PIMAGE_IMPORT_BY_NAME;  typedef struct __IMAGE_BASE_RELOCATION {     DWORD   VirtualAddress;     DWORD   SizeOfBlock; } ___IMAGE_BASE_RELOCATION, * ___PIMAGE_BASE_RELOCATION;  typedef struct __IMAGE_SECTION_HEADER {     BYTE    Name[___IMAGE_SIZEOF_SHORT_NAME];     union {         DWORD   PhysicalAddress;         DWORD   VirtualSize;     } Misc;     DWORD   VirtualAddress;     DWORD   SizeOfRawData;     DWORD   PointerToRawData;     DWORD   PointerToRelocations;     DWORD   PointerToLinenumbers;     WORD    NumberOfRelocations;     WORD    NumberOfLinenumbers;     DWORD   Characteristics; } ___IMAGE_SECTION_HEADER, * ___PIMAGE_SECTION_HEADER;   Custom Structures  I defined the following structures to help with the parsing process. They’re defined in the PEFILE_CUSTOM_STRUCTS.h header.  RICH_HEADER_INFO  A structure to hold information about the Rich Header during processing.  typedef struct __RICH_HEADER_INFO {     int size;     char* ptrToBuffer;     int entries; } RICH_HEADER_INFO, * PRICH_HEADER_INFO;      size: Size of the Rich Header (in bytes).   ptrToBuffer: A pointer to the buffer containing the data of the Rich Header.   entries: Number of entries in the Rich Header.   RICH_HEADER_ENTRY  A structure to represent a Rich Header entry.  typedef struct __RICH_HEADER_ENTRY {     WORD  prodID;     WORD  buildID;     DWORD useCount; } RICH_HEADER_ENTRY, * PRICH_HEADER_ENTRY;      prodID: Type ID / Product ID.   buildID: Build ID.   useCount: Use count.   RICH_HEADER  A structure to represent the Rich Header.  typedef struct __RICH_HEADER {     PRICH_HEADER_ENTRY entries; } RICH_HEADER, * PRICH_HEADER;      entries: A pointer to a RICH_HEADER_ENTRY array.   ILT_ENTRY_32  A structure to represent a 32-bit ILT entry during processing.  typedef struct __ILT_ENTRY_32 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;         DWORD ORDINAL_NAME_FLAG : 1;     } FIELD_1; } ILT_ENTRY_32, * PILT_ENTRY_32;   The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  ILT_ENTRY_64  A structure to represent a 64-bit ILT entry during processing.  typedef struct __ILT_ENTRY_64 {     union {         DWORD ORDINAL : 16;         DWORD HINT_NAME_TABE : 32;     } FIELD_2;     DWORD ORDINAL_NAME_FLAG : 1; } ILT_ENTRY_64, * PILT_ENTRY_64;   The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.  BASE_RELOC_ENTRY  A structure to represent a base relocation entry during processing.  typedef struct __BASE_RELOC_ENTRY {     WORD OFFSET : 12;     WORD TYPE : 4; } BASE_RELOC_ENTRY, * PBASE_RELOC_ENTRY;      OFFSET: Relocation offset.   TYPE: Relocation type.   PEFILE  Our parser will represent a PE file as an object type of either PE32FILE or PE64FILE. These 2 classes only differ in some member definitions but their functionality is identical. Throughout this post we will use the code from PE64FILE.  Definition  The class is defined as follows:  class PE64FILE { public:     PE64FILE(char* _NAME, FILE* Ppefile); 	     void PrintInfo();  private:     char* NAME;     FILE* Ppefile;     int _import_directory_count, _import_directory_size;     int _basreloc_directory_count;      // HEADERS     ___IMAGE_DOS_HEADER     PEFILE_DOS_HEADER;     ___IMAGE_NT_HEADERS64   PEFILE_NT_HEADERS;      // DOS HEADER     DWORD PEFILE_DOS_HEADER_EMAGIC;     LONG  PEFILE_DOS_HEADER_LFANEW;      // RICH HEADER     RICH_HEADER_INFO PEFILE_RICH_HEADER_INFO;     RICH_HEADER PEFILE_RICH_HEADER;      // NT_HEADERS.Signature     DWORD PEFILE_NT_HEADERS_SIGNATURE;      // NT_HEADERS.FileHeader     WORD PEFILE_NT_HEADERS_FILE_HEADER_MACHINE;     WORD PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS;     WORD PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER;      // NT_HEADERS.OptionalHeader     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE;     ULONGLONG PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE;     DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS;      ___IMAGE_DATA_DIRECTORY PEFILE_EXPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_RESOURCE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_EXCEPTION_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_SECURITY_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BASERELOC_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DEBUG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_ARCHITECTURE_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_GLOBALPTR_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_TLS_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_LOAD_CONFIG_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_BOUND_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_IAT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_DELAY_IMPORT_DIRECTORY;     ___IMAGE_DATA_DIRECTORY PEFILE_COM_DESCRIPTOR_DIRECTORY;      // SECTION HEADERS     ___PIMAGE_SECTION_HEADER PEFILE_SECTION_HEADERS;      // IMPORT TABLE     ___PIMAGE_IMPORT_DESCRIPTOR PEFILE_IMPORT_TABLE;          // BASE RELOCATION TABLE     ___PIMAGE_BASE_RELOCATION PEFILE_BASERELOC_TABLE;      // FUNCTIONS          // ADDRESS RESOLVERS     int  locate(DWORD VA);     DWORD resolve(DWORD VA, int index);      // PARSERS     void ParseFile();     void ParseDOSHeader();     void ParseNTHeaders();     void ParseSectionHeaders();     void ParseImportDirectory();     void ParseBaseReloc();     void ParseRichHeader();      // PRINT INFO     void PrintFileInfo();     void PrintDOSHeaderInfo();     void PrintRichHeaderInfo();     void PrintNTHeadersInfo();     void PrintSectionHeadersInfo();     void PrintImportTableInfo();     void PrintBaseRelocationsInfo(); };   The only public member beside the class constructor is a function called printInfo() which will print information about the file.  The class constructor takes two parameters, a char array representing the name of the file and a file pointer to the actual data of the file.  After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later.  In the end is a series of methods definitions, first two methods are called locate and resolve, I will talk about them in a minute. The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts.  Constructor  The constructor of the class simply sets the file pointer and name variables, then it calls the ParseFile() function.  PE64FILE::PE64FILE(char* _NAME, FILE* _Ppefile) { 	 	NAME = _NAME; 	Ppefile = _Ppefile;  	ParseFile();  }   The ParseFile() function calls the other parser functions:  void PE64FILE::ParseFile() {  	// PARSE DOS HEADER 	ParseDOSHeader();  	// PARSE RICH HEADER 	ParseRichHeader();  	//PARSE NT HEADERS 	ParseNTHeaders();  	// PARSE SECTION HEADERS 	ParseSectionHeaders();  	// PARSE IMPORT DIRECTORY 	ParseImportDirectory();  	// PARSE BASE RELOCATIONS 	ParseBaseReloc();  }   Resolving RVAs  Most of the time, we’ll have a RVA that we’ll need to change to a file offset. The process of resolving an RVA can be outlined as follows:     Determine which section range contains that RVA:            Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section.       If the RVA exists within this range then it belongs to that section.           Calculate the file offset:            Subtract the RVA from the section virtual address.       Add that value to the raw data pointer of the section.           An example of this is locating a Data Directory. The IMAGE_DATA_DIRECTORY structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address.  I wrote two functions to do this, first one to locate the virtual address (locate()), second one to resolve the address (resolve()).  int PE64FILE::locate(DWORD VA) { 	 	int index; 	 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		if (VA &gt;= PEFILE_SECTION_HEADERS[i].VirtualAddress 			&amp;&amp; VA &lt; (PEFILE_SECTION_HEADERS[i].VirtualAddress + PEFILE_SECTION_HEADERS[i].Misc.VirtualSize)){ 			index = i; 			break; 		} 	} 	return index; }  DWORD PE64FILE::resolve(DWORD VA, int index) {  	return (VA - PEFILE_SECTION_HEADERS[index].VirtualAddress) + PEFILE_SECTION_HEADERS[index].PointerToRawData;  }   locate() iterates over the PEFILE_SECTION_HEADERS array, compares the RVA as described above, then it returns the index of the appropriate section header within the PEFILE_SECTION_HEADERS array.  Please note that in order for these functions to work we’ll need to parse out the section headers and fill the PEFILE_SECTION_HEADERS array first. We still haven’t discussed this part, but I wanted to talk about the address resolvers first.  main function  The main function of the program is fairly simple, it only does 2 things:     Create a file pointer to the given file, and validate that the file was read correctly.   Call INITPARSE() on the file, and based on the return value it decides between three actions:            Exit.       Create a PE32FILE object, call PrintInfo(), close the file pointer then exit.       Create a PE64FILE object, call PrintInfo(), close the file pointer then exit.           PrintInfo() calls the other print info functions.  int main(int argc, char* argv[]) { 	if (argc != 2) { 		printf(&quot;Usage: %s [path to executable]\n&quot;, argv[0]); 		return 1; 	}  	FILE * PpeFile; 	fopen_s(&amp;PpeFile, argv[1], &quot;rb&quot;);  	if (PpeFile == NULL) { 		printf(&quot;Can&#39;t open file.\n&quot;); 		return 1; 	}  	if (INITPARSE(PpeFile) == 1) { 		exit(1); 	} 	else if (INITPARSE(PpeFile) == 32) { 		PE32FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	} 	else if (INITPARSE(PpeFile) == 64) { 		PE64FILE PeFile_1(argv[1], PpeFile); 		PeFile_1.PrintInfo(); 		fclose(PpeFile); 		exit(0); 	}  	return 0; }   INITPARSE()  INITPARSE() is a function defined in PEFILE.cpp. Its only job is to validate that the given file is a PE file, then determine whether the file is PE32 or PE32+.  It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error.  After validating the PE file, it sets the file position to (DOS_HEADER.e_lfanew + size of DWORD (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header. Then it reads a WORD, we know that the first WORD of the Optional Header is a magic value that indicates the file type, it then compares that word to IMAGE_NT_OPTIONAL_HDR32_MAGIC and IMAGE_NT_OPTIONAL_HDR64_MAGIC, and based on the comparison results it either returns 32 or 64 indicating PE32 or PE32+, or it returns an error.  int INITPARSE(FILE* PpeFile) {  	___IMAGE_DOS_HEADER TMP_DOS_HEADER; 	WORD PEFILE_TYPE;  	fseek(PpeFile, 0, SEEK_SET); 	fread(&amp;TMP_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, PpeFile);  	if (TMP_DOS_HEADER.e_magic != ___IMAGE_DOS_SIGNATURE) { 		printf(&quot;Error. Not a PE file.\n&quot;); 		return 1; 	}  	fseek(PpeFile, (TMP_DOS_HEADER.e_lfanew + sizeof(DWORD) + sizeof(___IMAGE_FILE_HEADER)), SEEK_SET); 	fread(&amp;PEFILE_TYPE, sizeof(WORD), 1, PpeFile);  	if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR32_MAGIC) { 		return 32; 	} 	else if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR64_MAGIC) { 		return 64; 	} 	else { 		printf(&quot;Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\n&quot;); 		return 1; 	}  }     Parsing DOS Header  ParseDOSHeader()  Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member PEFILE_DOS_HEADER. From there we can access all of the struct members, however we’re only interested in e_magic and e_lfanew.  void PE64FILE::ParseDOSHeader() { 	 	fseek(Ppefile, 0, SEEK_SET); 	fread(&amp;PEFILE_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, Ppefile);  	PEFILE_DOS_HEADER_EMAGIC = PEFILE_DOS_HEADER.e_magic; 	PEFILE_DOS_HEADER_LFANEW = PEFILE_DOS_HEADER.e_lfanew;  }   PrintDOSHeaderInfo()  This function prints e_magic and e_lfanew values.  void PE64FILE::PrintDOSHeaderInfo() { 	 	printf(&quot; DOS HEADER:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; Magic: 0x%X\n&quot;, PEFILE_DOS_HEADER_EMAGIC); 	printf(&quot; File address of new exe header: 0x%X\n&quot;, PEFILE_DOS_HEADER_LFANEW);  }       Parsing Rich Header  Process  To parse out the Rich Header we’ll need to go through multiple steps.  We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place.  First of all, we need to locate the Rich Header. We don’t know the exact location, however we have everything we need to locate it. We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers. We also know that any Rich Header ends with a 32-bit value Rich followed by the XOR key.  One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed. A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the Rich sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header.  Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the Rich signature and keep XORing 4 bytes at a time until we reach the DanS signature which indicates the beginning of the Rich Header.  After obtaining the position and the size of the Rich Header, we can normally read and process the data.  ParseRichHeader()  This function starts by allocating a buffer on the heap, then it reads e_lfanew size of bytes from the beginning of the file and stores the data in the allocated buffer.  It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to 0x52 (R) and 0x69 (i). When the sequence is found, it stores the index in a variable then the loop breaks.  	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}   After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments RichHeaderSize by 4 until it reaches the DanS sequence.  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}   After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates PEFILE_RICH_HEADER_INFO with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing.  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;   The rest of the function reads each entry of the Rich Header and updates PEFILE_RICH_HEADER.  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;   Here’s the full function:  void PE64FILE::ParseRichHeader() { 	 	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; 	fseek(Ppefile, 0, SEEK_SET); 	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);  	int index_ = 0;  	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { 		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { 			index_ = i; 			break; 		} 	}  	if (index_ == 0) { 		printf(&quot;Error while parsing Rich Header.&quot;); 		PEFILE_RICH_HEADER_INFO.entries = 0; 		return; 	}  	char key[4]; 	memcpy(key, dataPtr + (index_ + 4), 4);  	int indexpointer = index_ - 4; 	int RichHeaderSize = 0;  	while (true) { 		char tmpchar[4]; 		memcpy(tmpchar, dataPtr + indexpointer, 4);  		for (int i = 0; i &lt; 4; i++) { 			tmpchar[i] = tmpchar[i] ^ key[i]; 		}  		indexpointer -= 4; 		RichHeaderSize += 4;  		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { 			break; 		} 	}  	char* RichHeaderPtr = new char[RichHeaderSize]; 	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);  	for (int i = 0; i &lt; RichHeaderSize; i += 4) {  		for (int x = 0; x &lt; 4; x++) { 			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; 		}  	}  	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; 	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; 	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;  	delete[] dataPtr;  	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];  	for (int i = 16; i &lt; RichHeaderSize; i += 8) { 		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; 		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; 		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; 		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { 			PRODID, 			BUILDID, 			USECOUNT 		};  		if (i + 8 &gt;= RichHeaderSize) { 			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; 		}  	}  	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;  }   PrintRichHeaderInfo()  This function iterates over each entry in PEFILE_RICH_HEADER and prints its value.  void PE64FILE::PrintRichHeaderInfo() { 	 	printf(&quot; RICH HEADER:\n&quot;); 	printf(&quot; ------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_RICH_HEADER_INFO.entries; i++) { 		printf(&quot; 0x%X 0x%X 0x%X: %d.%d.%d\n&quot;, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount, 			PEFILE_RICH_HEADER.entries[i].buildID, 			PEFILE_RICH_HEADER.entries[i].prodID, 			PEFILE_RICH_HEADER.entries[i].useCount); 	}  }       Parsing NT Headers  ParseNTHeaders()  Similar to the DOS Header, all we need to do is to read from e_lfanew an amount of bytes equal to the size of IMAGE_NT_HEADERS.  After that we can parse out the contents of the File Header and the Optional Header.  The Optional Header contains an array of IMAGE_DATA_DIRECTORY structures which we care about. To parse out this information, we can use the IMAGE_DIRECTORY_[...] constants defined in winnt.h as array indexes to access the corresponding IMAGE_DATA_DIRECTORY structure of each Data Directory.  void PE64FILE::ParseNTHeaders() { 	 	fseek(Ppefile, PEFILE_DOS_HEADER.e_lfanew, SEEK_SET); 	fread(&amp;PEFILE_NT_HEADERS, sizeof(PEFILE_NT_HEADERS), 1, Ppefile);  	PEFILE_NT_HEADERS_SIGNATURE = PEFILE_NT_HEADERS.Signature;  	PEFILE_NT_HEADERS_FILE_HEADER_MACHINE = PEFILE_NT_HEADERS.FileHeader.Machine; 	PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS = PEFILE_NT_HEADERS.FileHeader.NumberOfSections; 	PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER = PEFILE_NT_HEADERS.FileHeader.SizeOfOptionalHeader;  	PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC = PEFILE_NT_HEADERS.OptionalHeader.Magic; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfInitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT = PEFILE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.BaseOfCode; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE = PEFILE_NT_HEADERS.OptionalHeader.ImageBase; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.SectionAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.FileAlignment; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfImage; 	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS = PEFILE_NT_HEADERS.OptionalHeader.SizeOfHeaders;  	PEFILE_EXPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT]; 	PEFILE_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT]; 	PEFILE_RESOURCE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE]; 	PEFILE_EXCEPTION_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXCEPTION]; 	PEFILE_SECURITY_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_SECURITY]; 	PEFILE_BASERELOC_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC]; 	PEFILE_DEBUG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DEBUG]; 	PEFILE_ARCHITECTURE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE]; 	PEFILE_GLOBALPTR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_GLOBALPTR]; 	PEFILE_TLS_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_TLS]; 	PEFILE_LOAD_CONFIG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]; 	PEFILE_BOUND_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]; 	PEFILE_IAT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IAT]; 	PEFILE_DELAY_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]; 	PEFILE_COM_DESCRIPTOR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];  }   PrintNTHeadersInfo()  This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size.  void PE64FILE::PrintNTHeadersInfo() { 	 	printf(&quot; NT HEADERS:\n&quot;); 	printf(&quot; -----------\n\n&quot;);  	printf(&quot; PE Signature: 0x%X\n&quot;, PEFILE_NT_HEADERS_SIGNATURE);  	printf(&quot;\n File Header:\n\n&quot;); 	printf(&quot;   Machine: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_MACHINE); 	printf(&quot;   Number of sections: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS); 	printf(&quot;   Size of optional header: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER);  	printf(&quot;\n Optional Header:\n\n&quot;); 	printf(&quot;   Magic: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC); 	printf(&quot;   Size of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE); 	printf(&quot;   Size of initialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA); 	printf(&quot;   Size of uninitialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA); 	printf(&quot;   Address of entry point: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT); 	printf(&quot;   RVA of start of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE); 	printf(&quot;   Desired image base: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE); 	printf(&quot;   Section alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT); 	printf(&quot;   File alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT); 	printf(&quot;   Size of image: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE); 	printf(&quot;   Size of headers: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS);  	printf(&quot;\n Data Directories:\n&quot;); 	printf(&quot;\n   * Export Directory:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.Size); 	. 	. 	[REDACTED] 	. 	. 	printf(&quot;\n   * COM Runtime Descriptor:\n&quot;); 	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.VirtualAddress); 	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.Size);  }       Parsing Section Headers  ParseSectionHeaders()  This function starts by assigning the PEFILE_SECTION_HEADERS class member to a pointer to an IMAGE_SECTION_HEADER array of the count of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS.  Then it goes into a loop of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS iterations where in each iteration it changes the file offset to (e_lfanew + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of PEFILE_SECTION_HEADERS.  void PE64FILE::ParseSectionHeaders() { 	 	PEFILE_SECTION_HEADERS = new ___IMAGE_SECTION_HEADER[PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS]; 	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		int offset = (PEFILE_DOS_HEADER.e_lfanew + sizeof(PEFILE_NT_HEADERS)) + (i * ___IMAGE_SIZEOF_SECTION_HEADER); 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_SECTION_HEADERS[i], ___IMAGE_SIZEOF_SECTION_HEADER, 1, Ppefile); 	}  }   PrintSectionHeadersInfo()  This function loops over the Section Headers array (filled by ParseSectionHeaders()), and it prints information about each section.  void PE64FILE::PrintSectionHeadersInfo() { 	 	printf(&quot; SECTION HEADERS:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { 		printf(&quot;   * %.8s:\n&quot;, PEFILE_SECTION_HEADERS[i].Name); 		printf(&quot;        VirtualAddress: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].VirtualAddress); 		printf(&quot;        VirtualSize: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].Misc.VirtualSize); 		printf(&quot;        PointerToRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].PointerToRawData); 		printf(&quot;        SizeOfRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].SizeOfRawData); 		printf(&quot;        Characteristics: 0x%X\n\n&quot;, PEFILE_SECTION_HEADERS[i].Characteristics); 	}  }       Parsing Imports  ParseImportDirectory()  To parse out the Import Directory Table we need to determine the count of IMAGE_IMPORT_DESCRIPTORs first.  This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor. In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks. Otherwise it increments _import_directory_count and the loop continues.  After finding the size of the Import Directory, the function assigns the PEFILE_IMPORT_TABLE class member to a pointer to an IMAGE_IMPORT_DESCRIPTOR array of the count of _import_directory_count then goes into another loop similar to the one we’ve seen in ParseSectionHeaders() to parse out the import descriptors.  void PE64FILE::ParseImportDirectory() { 	 	DWORD _import_directory_address = resolve(PEFILE_IMPORT_DIRECTORY.VirtualAddress, locate(PEFILE_IMPORT_DIRECTORY.VirtualAddress)); 	_import_directory_count = 0;  	while (true) { 		___IMAGE_IMPORT_DESCRIPTOR tmp; 		int offset = (_import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile);  		if (tmp.Name == 0x00000000 &amp;&amp; tmp.FirstThunk == 0x00000000) { 			_import_directory_count -= 1; 			_import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR); 			break; 		}  		_import_directory_count++; 	}  	PEFILE_IMPORT_TABLE = new ___IMAGE_IMPORT_DESCRIPTOR[_import_directory_count];  	for (int i = 0; i &lt; _import_directory_count; i++) { 		int offset = (i * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_IMPORT_TABLE[i], sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile); 	}  }   PrintImportTableInfo()  After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions. This is done by the PrintImportTableInfo() function.  This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not.  After that it resolves the file offset of the ILT then it parses out each ILT entry. If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint.  If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts.  We’ve discussed the details about this in the PE imports post.  void PE64FILE::PrintImportTableInfo() { 	 	printf(&quot; IMPORT TABLE:\n&quot;); 	printf(&quot; ----------------\n\n&quot;);  	for (int i = 0; i &lt; _import_directory_count; i++) { 		DWORD NameAddr = resolve(PEFILE_IMPORT_TABLE[i].Name, locate(PEFILE_IMPORT_TABLE[i].Name)); 		int NameSize = 0;  		while (true) { 			char tmp; 			fseek(Ppefile, (NameAddr + NameSize), SEEK_SET); 			fread(&amp;tmp, sizeof(char), 1, Ppefile);  			if (tmp == 0x00) { 				break; 			}  			NameSize++; 		}  		char* Name = new char[NameSize + 2]; 		fseek(Ppefile, NameAddr, SEEK_SET); 		fread(Name, (NameSize * sizeof(char)) + 1, 1, Ppefile); 		printf(&quot;   * %s:\n&quot;, Name); 		delete[] Name;  		printf(&quot;       ILT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk); 		printf(&quot;       IAT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].FirstThunk);  		if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == 0) { 			printf(&quot;       Bound: FALSE\n&quot;); 		} 		else if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == -1) { 			printf(&quot;       Bound: TRUE\n&quot;); 		}  		printf(&quot;\n&quot;);  		DWORD ILTAddr = resolve(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk, locate(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk)); 		int entrycounter = 0;  		while (true) {  			ILT_ENTRY_64 entry;  			fseek(Ppefile, (ILTAddr + (entrycounter * sizeof(QWORD))), SEEK_SET); 			fread(&amp;entry, sizeof(ILT_ENTRY_64), 1, Ppefile);  			BYTE flag = entry.ORDINAL_NAME_FLAG; 			DWORD HintRVA = 0x0; 			WORD ordinal = 0x0;  			if (flag == 0x0) { 				HintRVA = entry.FIELD_2.HINT_NAME_TABE; 			} 			else if (flag == 0x01) { 				ordinal = entry.FIELD_2.ORDINAL; 			}  			if (flag == 0x0 &amp;&amp; HintRVA == 0x0 &amp;&amp; ordinal == 0x0) { 				break; 			}  			printf(&quot;\n       Entry:\n&quot;);  			if (flag == 0x0) { 				___IMAGE_IMPORT_BY_NAME hint;  				DWORD HintAddr = resolve(HintRVA, locate(HintRVA)); 				fseek(Ppefile, HintAddr, SEEK_SET); 				fread(&amp;hint, sizeof(___IMAGE_IMPORT_BY_NAME), 1, Ppefile); 				printf(&quot;         Name: %s\n&quot;, hint.Name); 				printf(&quot;         Hint RVA: 0x%X\n&quot;, HintRVA); 				printf(&quot;         Hint: 0x%X\n&quot;, hint.Hint); 			} 			else if (flag == 1) { 				printf(&quot;         Ordinal: 0x%X\n&quot;, ordinal); 			}  			entrycounter++; 		}  		printf(&quot;\n   ----------------------\n\n&quot;);  	}  }       Parsing Base Relocations  ParseBaseReloc()  This function follows the same process we’ve seen in ParseImportDirectory(). It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each IMAGE_BASE_RELOCATION structure in PEFILE_BASERELOC_TABLE. One thing to note here that is different from what we’ve seen in ParseImportDirectory() is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of SizeOfBlock of each block in each iteration. We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks.  void PE64FILE::ParseBaseReloc() { 	 	DWORD _basereloc_directory_address = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 	_basreloc_directory_count = 0; 	int _basereloc_size_counter = 0;  	while (true) { 		___IMAGE_BASE_RELOCATION tmp;  		int offset = (_basereloc_size_counter + _basereloc_directory_address);  		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;tmp, sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile);  		if (tmp.VirtualAddress == 0x00000000 &amp;&amp; 			tmp.SizeOfBlock == 0x00000000) { 			break; 		}  		_basreloc_directory_count++; 		_basereloc_size_counter += tmp.SizeOfBlock; 	}  	PEFILE_BASERELOC_TABLE = new ___IMAGE_BASE_RELOCATION[_basreloc_directory_count];  	_basereloc_size_counter = 0;  	for (int i = 0; i &lt; _basreloc_directory_count; i++) { 		int offset = _basereloc_directory_address + _basereloc_size_counter; 		fseek(Ppefile, offset, SEEK_SET); 		fread(&amp;PEFILE_BASERELOC_TABLE[i], sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile); 		_basereloc_size_counter += PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 	}  }   PrintBaseRelocationInfo()  This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of IMAGE_BASE_RELOCATION from the block size then dividing that by the size of a WORD). After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them.  We’ve discussed the details about this in the PE base relocations post.  void PE64FILE::PrintBaseRelocationsInfo() { 	 	printf(&quot; BASE RELOCATIONS TABLE:\n&quot;); 	printf(&quot; -----------------------\n&quot;);  	int szCounter = sizeof(___IMAGE_BASE_RELOCATION);  	for (int i = 0; i &lt; _basreloc_directory_count; i++) {  		DWORD PAGERVA, BLOCKSIZE, BASE_RELOC_ADDR; 		int ENTRIES;  		BASE_RELOC_ADDR = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); 		PAGERVA = PEFILE_BASERELOC_TABLE[i].VirtualAddress; 		BLOCKSIZE = PEFILE_BASERELOC_TABLE[i].SizeOfBlock; 		ENTRIES = (BLOCKSIZE - sizeof(___IMAGE_BASE_RELOCATION)) / sizeof(WORD);  		printf(&quot;\n   Block 0x%X: \n&quot;, i); 		printf(&quot;     Page RVA: 0x%X\n&quot;, PAGERVA); 		printf(&quot;     Block size: 0x%X\n&quot;, BLOCKSIZE); 		printf(&quot;     Number of entries: 0x%X\n&quot;, ENTRIES); 		printf(&quot;\n     Entries:\n&quot;);  		for (int i = 0; i &lt; ENTRIES; i++) {  			BASE_RELOC_ENTRY entry;  			int offset = (BASE_RELOC_ADDR + szCounter + (i * sizeof(WORD)));  			fseek(Ppefile, offset, SEEK_SET); 			fread(&amp;entry, sizeof(WORD), 1, Ppefile);  			printf(&quot;\n       * Value: 0x%X\n&quot;, entry); 			printf(&quot;         Relocation Type: 0x%X\n&quot;, entry.TYPE); 			printf(&quot;         Offset: 0x%X\n&quot;, entry.OFFSET);  		} 		printf(&quot;\n   ----------------------\n\n&quot;); 		szCounter += BLOCKSIZE; 	}  }       Conclusion  Here’s the full output after running the parser on a file:  Desktop&gt;.\PE-Parser.exe .\SimpleApp64.exe    FILE: .\SimpleApp64.exe  TYPE: 0x20B (PE32+)   ----------------------------------   DOS HEADER:  -----------   Magic: 0x5A4D  File address of new exe header: 0x100   ----------------------------------   RICH HEADER:  ------------   0x7809 0x93 0xA: 30729.147.10  0x6FCB 0x101 0x2: 28619.257.2  0x6FCB 0x105 0x11: 28619.261.17  0x6FCB 0x104 0xA: 28619.260.10  0x6FCB 0x103 0x3: 28619.259.3  0x685B 0x101 0x5: 26715.257.5  0x0 0x1 0x30: 0.1.48  0x7086 0x109 0x1: 28806.265.1  0x7086 0xFF 0x1: 28806.255.1  0x7086 0x102 0x1: 28806.258.1   ----------------------------------   NT HEADERS:  -----------   PE Signature: 0x4550   File Header:     Machine: 0x8664    Number of sections: 0x6    Size of optional header: 0xF0   Optional Header:     Magic: 0x20B    Size of code section: 0xE00    Size of initialized data: 0x1E00    Size of uninitialized data: 0x0    Address of entry point: 0x12C4    RVA of start of code section: 0x1000    Desired image base: 0x40000000    Section alignment: 0x1000    File alignment: 0x200    Size of image: 0x7000    Size of headers: 0x400   Data Directories:     * Export Directory:        RVA: 0x0        Size: 0x0     * Import Directory:        RVA: 0x27AC        Size: 0xB4     * Resource Directory:        RVA: 0x5000        Size: 0x1E0     * Exception Directory:        RVA: 0x4000        Size: 0x168     * Security Directory:        RVA: 0x0        Size: 0x0     * Base Relocation Table:        RVA: 0x6000        Size: 0x28     * Debug Directory:        RVA: 0x2248        Size: 0x70     * Architecture Specific Data:        RVA: 0x0        Size: 0x0     * RVA of GlobalPtr:        RVA: 0x0        Size: 0x0     * TLS Directory:        RVA: 0x0        Size: 0x0     * Load Configuration Directory:        RVA: 0x22C0        Size: 0x130     * Bound Import Directory:        RVA: 0x0        Size: 0x0     * Import Address Table:        RVA: 0x2000        Size: 0x198     * Delay Load Import Descriptors:        RVA: 0x0        Size: 0x0     * COM Runtime Descriptor:        RVA: 0x0        Size: 0x0   ----------------------------------   SECTION HEADERS:  ----------------     * .text:         VirtualAddress: 0x1000         VirtualSize: 0xD2C         PointerToRawData: 0x400         SizeOfRawData: 0xE00         Characteristics: 0x60000020     * .rdata:         VirtualAddress: 0x2000         VirtualSize: 0xE3C         PointerToRawData: 0x1200         SizeOfRawData: 0x1000         Characteristics: 0x40000040     * .data:         VirtualAddress: 0x3000         VirtualSize: 0x638         PointerToRawData: 0x2200         SizeOfRawData: 0x200         Characteristics: 0xC0000040     * .pdata:         VirtualAddress: 0x4000         VirtualSize: 0x168         PointerToRawData: 0x2400         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .rsrc:         VirtualAddress: 0x5000         VirtualSize: 0x1E0         PointerToRawData: 0x2600         SizeOfRawData: 0x200         Characteristics: 0x40000040     * .reloc:         VirtualAddress: 0x6000         VirtualSize: 0x28         PointerToRawData: 0x2800         SizeOfRawData: 0x200         Characteristics: 0x42000040    ----------------------------------   IMPORT TABLE:  ----------------     * USER32.dll:        ILT RVA: 0x28E0        IAT RVA: 0x2080        Bound: FALSE          Entry:          Name: MessageBoxA          Hint RVA: 0x29F8          Hint: 0x283     ----------------------     * VCRUNTIME140.dll:        ILT RVA: 0x28F0        IAT RVA: 0x2090        Bound: FALSE          Entry:          Name: memset          Hint RVA: 0x2A5E          Hint: 0x3E         Entry:          Name: __current_exception_context          Hint RVA: 0x2A40          Hint: 0x1C         Entry:          Name: __current_exception          Hint RVA: 0x2A2A          Hint: 0x1B         Entry:          Name: __C_specific_handler          Hint RVA: 0x2A12          Hint: 0x8     ----------------------     * api-ms-win-crt-runtime-l1-1-0.dll:        ILT RVA: 0x2948        IAT RVA: 0x20E8        Bound: FALSE          Entry:          Name: _crt_atexit          Hint RVA: 0x2C12          Hint: 0x1E         Entry:          Name: terminate          Hint RVA: 0x2C20          Hint: 0x67         Entry:          Name: _exit          Hint RVA: 0x2B30          Hint: 0x23         Entry:          Name: _register_thread_local_exe_atexit_callback          Hint RVA: 0x2B76          Hint: 0x3D         Entry:          Name: _c_exit          Hint RVA: 0x2B6C          Hint: 0x15         Entry:          Name: exit          Hint RVA: 0x2B28          Hint: 0x55         Entry:          Name: _initterm_e          Hint RVA: 0x2B1A          Hint: 0x37         Entry:          Name: _initterm          Hint RVA: 0x2B0E          Hint: 0x36         Entry:          Name: _get_initial_narrow_environment          Hint RVA: 0x2AEC          Hint: 0x28         Entry:          Name: _initialize_narrow_environment          Hint RVA: 0x2ACA          Hint: 0x33         Entry:          Name: _configure_narrow_argv          Hint RVA: 0x2AB0          Hint: 0x18         Entry:          Name: _initialize_onexit_table          Hint RVA: 0x2BDA          Hint: 0x34         Entry:          Name: _set_app_type          Hint RVA: 0x2A8C          Hint: 0x42         Entry:          Name: _seh_filter_exe          Hint RVA: 0x2A7A          Hint: 0x40         Entry:          Name: _cexit          Hint RVA: 0x2B62          Hint: 0x16         Entry:          Name: __p___argv          Hint RVA: 0x2B54          Hint: 0x5         Entry:          Name: __p___argc          Hint RVA: 0x2B46          Hint: 0x4         Entry:          Name: _register_onexit_function          Hint RVA: 0x2BF6          Hint: 0x3C     ----------------------     * api-ms-win-crt-math-l1-1-0.dll:        ILT RVA: 0x2938        IAT RVA: 0x20D8        Bound: FALSE          Entry:          Name: __setusermatherr          Hint RVA: 0x2A9C          Hint: 0x9     ----------------------     * api-ms-win-crt-stdio-l1-1-0.dll:        ILT RVA: 0x29E0        IAT RVA: 0x2180        Bound: FALSE          Entry:          Name: __p__commode          Hint RVA: 0x2BCA          Hint: 0x1         Entry:          Name: _set_fmode          Hint RVA: 0x2B38          Hint: 0x54     ----------------------     * api-ms-win-crt-locale-l1-1-0.dll:        ILT RVA: 0x2928        IAT RVA: 0x20C8        Bound: FALSE          Entry:          Name: _configthreadlocale          Hint RVA: 0x2BA4          Hint: 0x8     ----------------------     * api-ms-win-crt-heap-l1-1-0.dll:        ILT RVA: 0x2918        IAT RVA: 0x20B8        Bound: FALSE          Entry:          Name: _set_new_mode          Hint RVA: 0x2BBA          Hint: 0x16     ----------------------    ----------------------------------   BASE RELOCATIONS TABLE:  -----------------------     Block 0x0:      Page RVA: 0x2000      Block size: 0x28      Number of entries: 0x10       Entries:         * Value: 0xA198          Relocation Type: 0xA          Offset: 0x198         * Value: 0xA1A0          Relocation Type: 0xA          Offset: 0x1A0         * Value: 0xA1A8          Relocation Type: 0xA          Offset: 0x1A8         * Value: 0xA1B0          Relocation Type: 0xA          Offset: 0x1B0         * Value: 0xA1B8          Relocation Type: 0xA          Offset: 0x1B8         * Value: 0xA1C8          Relocation Type: 0xA          Offset: 0x1C8         * Value: 0xA1E0          Relocation Type: 0xA          Offset: 0x1E0         * Value: 0xA1E8          Relocation Type: 0xA          Offset: 0x1E8         * Value: 0xA220          Relocation Type: 0xA          Offset: 0x220         * Value: 0xA228          Relocation Type: 0xA          Offset: 0x228         * Value: 0xA318          Relocation Type: 0xA          Offset: 0x318         * Value: 0xA330          Relocation Type: 0xA          Offset: 0x330         * Value: 0xA338          Relocation Type: 0xA          Offset: 0x338         * Value: 0xA3D8          Relocation Type: 0xA          Offset: 0x3D8         * Value: 0xA3E0          Relocation Type: 0xA          Offset: 0x3E0         * Value: 0xA3E8          Relocation Type: 0xA          Offset: 0x3E8     ----------------------    ----------------------------------   I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts. I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated.  Thanks for reading.">
  <meta name="twitter:url" content="https://0xrick.github.io/win-internals/pe8/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2021-10-29T03:00:00+02:00">






<link rel="canonical" href="https://0xrick.github.io/win-internals/pe8/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "0xRick",
      "url": "https://0xrick.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->




<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          0xRick's Blog
          
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/about">About</a>
            </li>
<li class="masthead__menu-item">
              <a href="/categories">Categories</a>
            </li>
<li class="masthead__menu-item">
              <a href="/tags">Tags</a>
            </li>
</ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/images/avatar.jpg" alt="0xRick" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">0xRick</h3>
    
    
      <div class="author__bio" itemprop="description">
        

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Somewhere between 1's and 0's</span>
        </li>
      

      
        
          
            <li><a href="/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-home" aria-hidden="true"></i><span class="label">Home Page</span></a></li>
          
        
          
            <li><a href="https://twitter.com/ahm3d_h3sham" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/0xRick" rel="noopener noreferrer" target="_blank"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">Github</span></a></li>
          
        
          
            <li><a href="https://www.buymeacoffee.com/VGEfcAqvn" rel="noopener noreferrer" target="_blank"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">buymeacoffee</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>
 
  
  </div>


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="A dive into the PE file format - LAB 1: Writing a PE Parser">
    <meta itemprop="description" content="A dive into the PE file format - LAB 1: Writing a PE ParserIntroductionIn the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept.The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure.We’re going to focus on PE32 and PE32+ files, and we’ll only parse the following parts of the file:  DOS Header  Rich Header  NT Headers  Data Directories (within the Optional Header)  Section Headers  Import Table  Base Relocations TableThe code of this project can be found on my github profile.Initial SetupProcess OutlineWe want out parser to follow the following process:  Read a file.  Validate that it’s a PE file.  Determine whether it’s a PE32 or a PE32+.  Parse out the following structures:          DOS Header      Rich Header      NT Headers      Section Headers      Import Data Directory      Base Relocation Data Directory        Print out the following information:          File name and type.      DOS Header:                  Magic value.          Address of new exe header.                    Each entry of the Rich Header, decrypted and decoded.      NT Headers - PE file signature.      NT Headers - File Header:                  Machine value.          Number of sections.          Size of Optional Header.                    NT Headers - Optional Header:                  Magic value.          Size of code section.          Size of initialized data.          Size of uninitialized data.          Address of entry point.          RVA of start of code section.          Desired Image Base.          Section alignment.          File alignment.          Size of image.          Size of headers.                    For each Data Directory: its name, RVA and size.      For each Section Header:                  Section name.          Section virtual address and size.          Section raw data pointer and size.          Section characteristics value.                    Import Table:                  For each DLL:                          DLL name.              ILT and IAT RVAs.              Whether its a bound import or not.              for every imported function:                                  Ordinal if ordinal/name flag is 1.                  Name, hint and Hint/Name table RVA if ordinal/name flag is 0.                                                                        Base Relocation Table:                  For each block:                          Page RVA.              Block size.              Number of entries.              For each entry:                                  Raw value.                  Relocation offset.                  Relocation Type.                                                                        winnt.h DefinitionsWe will need the following definitions from the winnt.h header:  Types:          BYTE      WORD      DWORD      QWORD      LONG      LONGLONG      ULONGLONG        Constants:          IMAGE_NT_OPTIONAL_HDR32_MAGIC      IMAGE_NT_OPTIONAL_HDR64_MAGIC      IMAGE_NUMBEROF_DIRECTORY_ENTRIES      IMAGE_DOS_SIGNATURE      IMAGE_DIRECTORY_ENTRY_EXPORT      IMAGE_DIRECTORY_ENTRY_IMPORT      IMAGE_DIRECTORY_ENTRY_RESOURCE      IMAGE_DIRECTORY_ENTRY_EXCEPTION      IMAGE_DIRECTORY_ENTRY_SECURITY      IMAGE_DIRECTORY_ENTRY_BASERELOC      IMAGE_DIRECTORY_ENTRY_DEBUG      IMAGE_DIRECTORY_ENTRY_ARCHITECTURE      IMAGE_DIRECTORY_ENTRY_GLOBALPTR      IMAGE_DIRECTORY_ENTRY_TLS      IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG      IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT      IMAGE_DIRECTORY_ENTRY_IAT      IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT      IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR      IMAGE_SIZEOF_SHORT_NAME      IMAGE_SIZEOF_SECTION_HEADER        Structures:          IMAGE_DOS_HEADER      IMAGE_DATA_DIRECTORY      IMAGE_OPTIONAL_HEADER32      IMAGE_OPTIONAL_HEADER64      IMAGE_FILE_HEADER      IMAGE_NT_HEADERS32      IMAGE_NT_HEADERS64      IMAGE_IMPORT_DESCRIPTOR      IMAGE_IMPORT_BY_NAME      IMAGE_BASE_RELOCATION      IMAGE_SECTION_HEADER      I took these definitions from winnt.h and added them to a new header called winntdef.h.winntdef.h:typedef unsigned char BYTE;typedef unsigned short WORD;typedef unsigned long DWORD;typedef unsigned long long QWORD;typedef unsigned long LONG;typedef __int64 LONGLONG;typedef unsigned __int64 ULONGLONG;#define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC       0x10b#define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC       0x20b#define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16#define ___IMAGE_DOS_SIGNATURE                 0x5A4D#define ___IMAGE_DIRECTORY_ENTRY_EXPORT          0#define ___IMAGE_DIRECTORY_ENTRY_IMPORT          1#define ___IMAGE_DIRECTORY_ENTRY_RESOURCE        2#define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION       3#define ___IMAGE_DIRECTORY_ENTRY_SECURITY        4#define ___IMAGE_DIRECTORY_ENTRY_BASERELOC       5#define ___IMAGE_DIRECTORY_ENTRY_DEBUG           6#define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7#define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8#define ___IMAGE_DIRECTORY_ENTRY_TLS             9#define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10#define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11#define ___IMAGE_DIRECTORY_ENTRY_IAT            12#define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13#define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14#define ___IMAGE_SIZEOF_SHORT_NAME              8#define ___IMAGE_SIZEOF_SECTION_HEADER          40typedef struct __IMAGE_DOS_HEADER {    WORD   e_magic;    WORD   e_cblp;    WORD   e_cp;    WORD   e_crlc;    WORD   e_cparhdr;    WORD   e_minalloc;    WORD   e_maxalloc;    WORD   e_ss;    WORD   e_sp;    WORD   e_csum;    WORD   e_ip;    WORD   e_cs;    WORD   e_lfarlc;    WORD   e_ovno;    WORD   e_res[4];    WORD   e_oemid;    WORD   e_oeminfo;    WORD   e_res2[10];    LONG   e_lfanew;} ___IMAGE_DOS_HEADER, * ___PIMAGE_DOS_HEADER;typedef struct __IMAGE_DATA_DIRECTORY {    DWORD   VirtualAddress;    DWORD   Size;} ___IMAGE_DATA_DIRECTORY, * ___PIMAGE_DATA_DIRECTORY;typedef struct __IMAGE_OPTIONAL_HEADER {    WORD    Magic;    BYTE    MajorLinkerVersion;    BYTE    MinorLinkerVersion;    DWORD   SizeOfCode;    DWORD   SizeOfInitializedData;    DWORD   SizeOfUninitializedData;    DWORD   AddressOfEntryPoint;    DWORD   BaseOfCode;    DWORD   BaseOfData;    DWORD   ImageBase;    DWORD   SectionAlignment;    DWORD   FileAlignment;    WORD    MajorOperatingSystemVersion;    WORD    MinorOperatingSystemVersion;    WORD    MajorImageVersion;    WORD    MinorImageVersion;    WORD    MajorSubsystemVersion;    WORD    MinorSubsystemVersion;    DWORD   Win32VersionValue;    DWORD   SizeOfImage;    DWORD   SizeOfHeaders;    DWORD   CheckSum;    WORD    Subsystem;    WORD    DllCharacteristics;    DWORD   SizeOfStackReserve;    DWORD   SizeOfStackCommit;    DWORD   SizeOfHeapReserve;    DWORD   SizeOfHeapCommit;    DWORD   LoaderFlags;    DWORD   NumberOfRvaAndSizes;    ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES];} ___IMAGE_OPTIONAL_HEADER32, * ___PIMAGE_OPTIONAL_HEADER32;typedef struct __IMAGE_OPTIONAL_HEADER64 {    WORD        Magic;    BYTE        MajorLinkerVersion;    BYTE        MinorLinkerVersion;    DWORD       SizeOfCode;    DWORD       SizeOfInitializedData;    DWORD       SizeOfUninitializedData;    DWORD       AddressOfEntryPoint;    DWORD       BaseOfCode;    ULONGLONG   ImageBase;    DWORD       SectionAlignment;    DWORD       FileAlignment;    WORD        MajorOperatingSystemVersion;    WORD        MinorOperatingSystemVersion;    WORD        MajorImageVersion;    WORD        MinorImageVersion;    WORD        MajorSubsystemVersion;    WORD        MinorSubsystemVersion;    DWORD       Win32VersionValue;    DWORD       SizeOfImage;    DWORD       SizeOfHeaders;    DWORD       CheckSum;    WORD        Subsystem;    WORD        DllCharacteristics;    ULONGLONG   SizeOfStackReserve;    ULONGLONG   SizeOfStackCommit;    ULONGLONG   SizeOfHeapReserve;    ULONGLONG   SizeOfHeapCommit;    DWORD       LoaderFlags;    DWORD       NumberOfRvaAndSizes;    ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES];} ___IMAGE_OPTIONAL_HEADER64, * ___PIMAGE_OPTIONAL_HEADER64;typedef struct __IMAGE_FILE_HEADER {    WORD    Machine;    WORD    NumberOfSections;    DWORD   TimeDateStamp;    DWORD   PointerToSymbolTable;    DWORD   NumberOfSymbols;    WORD    SizeOfOptionalHeader;    WORD    Characteristics;} ___IMAGE_FILE_HEADER, * ___PIMAGE_FILE_HEADER;typedef struct __IMAGE_NT_HEADERS64 {    DWORD Signature;    ___IMAGE_FILE_HEADER FileHeader;    ___IMAGE_OPTIONAL_HEADER64 OptionalHeader;} ___IMAGE_NT_HEADERS64, * ___PIMAGE_NT_HEADERS64;typedef struct __IMAGE_NT_HEADERS {    DWORD Signature;    ___IMAGE_FILE_HEADER FileHeader;    ___IMAGE_OPTIONAL_HEADER32 OptionalHeader;} ___IMAGE_NT_HEADERS32, * ___PIMAGE_NT_HEADERS32;typedef struct __IMAGE_IMPORT_DESCRIPTOR {    union {        DWORD   Characteristics;        DWORD   OriginalFirstThunk;    } DUMMYUNIONNAME;    DWORD   TimeDateStamp;    DWORD   ForwarderChain;    DWORD   Name;    DWORD   FirstThunk;} ___IMAGE_IMPORT_DESCRIPTOR, * ___PIMAGE_IMPORT_DESCRIPTOR;typedef struct __IMAGE_IMPORT_BY_NAME {    WORD    Hint;    char   Name[100];} ___IMAGE_IMPORT_BY_NAME, * ___PIMAGE_IMPORT_BY_NAME;typedef struct __IMAGE_BASE_RELOCATION {    DWORD   VirtualAddress;    DWORD   SizeOfBlock;} ___IMAGE_BASE_RELOCATION, * ___PIMAGE_BASE_RELOCATION;typedef struct __IMAGE_SECTION_HEADER {    BYTE    Name[___IMAGE_SIZEOF_SHORT_NAME];    union {        DWORD   PhysicalAddress;        DWORD   VirtualSize;    } Misc;    DWORD   VirtualAddress;    DWORD   SizeOfRawData;    DWORD   PointerToRawData;    DWORD   PointerToRelocations;    DWORD   PointerToLinenumbers;    WORD    NumberOfRelocations;    WORD    NumberOfLinenumbers;    DWORD   Characteristics;} ___IMAGE_SECTION_HEADER, * ___PIMAGE_SECTION_HEADER;Custom StructuresI defined the following structures to help with the parsing process.They’re defined in the PEFILE_CUSTOM_STRUCTS.h header.RICH_HEADER_INFOA structure to hold information about the Rich Header during processing.typedef struct __RICH_HEADER_INFO {    int size;    char* ptrToBuffer;    int entries;} RICH_HEADER_INFO, * PRICH_HEADER_INFO;  size: Size of the Rich Header (in bytes).  ptrToBuffer: A pointer to the buffer containing the data of the Rich Header.  entries: Number of entries in the Rich Header.RICH_HEADER_ENTRYA structure to represent a Rich Header entry.typedef struct __RICH_HEADER_ENTRY {    WORD  prodID;    WORD  buildID;    DWORD useCount;} RICH_HEADER_ENTRY, * PRICH_HEADER_ENTRY;  prodID: Type ID / Product ID.  buildID: Build ID.  useCount: Use count.RICH_HEADERA structure to represent the Rich Header.typedef struct __RICH_HEADER {    PRICH_HEADER_ENTRY entries;} RICH_HEADER, * PRICH_HEADER;  entries: A pointer to a RICH_HEADER_ENTRY array.ILT_ENTRY_32A structure to represent a 32-bit ILT entry during processing.typedef struct __ILT_ENTRY_32 {    union {        DWORD ORDINAL : 16;        DWORD HINT_NAME_TABE : 32;        DWORD ORDINAL_NAME_FLAG : 1;    } FIELD_1;} ILT_ENTRY_32, * PILT_ENTRY_32;The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.ILT_ENTRY_64A structure to represent a 64-bit ILT entry during processing.typedef struct __ILT_ENTRY_64 {    union {        DWORD ORDINAL : 16;        DWORD HINT_NAME_TABE : 32;    } FIELD_2;    DWORD ORDINAL_NAME_FLAG : 1;} ILT_ENTRY_64, * PILT_ENTRY_64;The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.BASE_RELOC_ENTRYA structure to represent a base relocation entry during processing.typedef struct __BASE_RELOC_ENTRY {    WORD OFFSET : 12;    WORD TYPE : 4;} BASE_RELOC_ENTRY, * PBASE_RELOC_ENTRY;  OFFSET: Relocation offset.  TYPE: Relocation type.PEFILEOur parser will represent a PE file as an object type of either PE32FILE or PE64FILE.These 2 classes only differ in some member definitions but their functionality is identical.Throughout this post we will use the code from PE64FILE.DefinitionThe class is defined as follows:class PE64FILE{public:    PE64FILE(char* _NAME, FILE* Ppefile);	    void PrintInfo();private:    char* NAME;    FILE* Ppefile;    int _import_directory_count, _import_directory_size;    int _basreloc_directory_count;    // HEADERS    ___IMAGE_DOS_HEADER     PEFILE_DOS_HEADER;    ___IMAGE_NT_HEADERS64   PEFILE_NT_HEADERS;    // DOS HEADER    DWORD PEFILE_DOS_HEADER_EMAGIC;    LONG  PEFILE_DOS_HEADER_LFANEW;    // RICH HEADER    RICH_HEADER_INFO PEFILE_RICH_HEADER_INFO;    RICH_HEADER PEFILE_RICH_HEADER;    // NT_HEADERS.Signature    DWORD PEFILE_NT_HEADERS_SIGNATURE;    // NT_HEADERS.FileHeader    WORD PEFILE_NT_HEADERS_FILE_HEADER_MACHINE;    WORD PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS;    WORD PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER;    // NT_HEADERS.OptionalHeader    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE;    ULONGLONG PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE;    DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS;    ___IMAGE_DATA_DIRECTORY PEFILE_EXPORT_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_IMPORT_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_RESOURCE_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_EXCEPTION_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_SECURITY_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_BASERELOC_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_DEBUG_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_ARCHITECTURE_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_GLOBALPTR_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_TLS_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_LOAD_CONFIG_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_BOUND_IMPORT_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_IAT_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_DELAY_IMPORT_DIRECTORY;    ___IMAGE_DATA_DIRECTORY PEFILE_COM_DESCRIPTOR_DIRECTORY;    // SECTION HEADERS    ___PIMAGE_SECTION_HEADER PEFILE_SECTION_HEADERS;    // IMPORT TABLE    ___PIMAGE_IMPORT_DESCRIPTOR PEFILE_IMPORT_TABLE;        // BASE RELOCATION TABLE    ___PIMAGE_BASE_RELOCATION PEFILE_BASERELOC_TABLE;    // FUNCTIONS        // ADDRESS RESOLVERS    int  locate(DWORD VA);    DWORD resolve(DWORD VA, int index);    // PARSERS    void ParseFile();    void ParseDOSHeader();    void ParseNTHeaders();    void ParseSectionHeaders();    void ParseImportDirectory();    void ParseBaseReloc();    void ParseRichHeader();    // PRINT INFO    void PrintFileInfo();    void PrintDOSHeaderInfo();    void PrintRichHeaderInfo();    void PrintNTHeadersInfo();    void PrintSectionHeadersInfo();    void PrintImportTableInfo();    void PrintBaseRelocationsInfo();};The only public member beside the class constructor is a function called printInfo() which will print information about the file.The class constructor takes two parameters, a char array representing the name of the file and a file pointer to the actual data of the file.After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later.In the end is a series of methods definitions, first two methods are called locate and resolve, I will talk about them in a minute.The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts.ConstructorThe constructor of the class simply sets the file pointer and name variables, then it calls the ParseFile() function.PE64FILE::PE64FILE(char* _NAME, FILE* _Ppefile) {		NAME = _NAME;	Ppefile = _Ppefile;	ParseFile();}The ParseFile() function calls the other parser functions:void PE64FILE::ParseFile() {	// PARSE DOS HEADER	ParseDOSHeader();	// PARSE RICH HEADER	ParseRichHeader();	//PARSE NT HEADERS	ParseNTHeaders();	// PARSE SECTION HEADERS	ParseSectionHeaders();	// PARSE IMPORT DIRECTORY	ParseImportDirectory();	// PARSE BASE RELOCATIONS	ParseBaseReloc();}Resolving RVAsMost of the time, we’ll have a RVA that we’ll need to change to a file offset.The process of resolving an RVA can be outlined as follows:  Determine which section range contains that RVA:          Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section.      If the RVA exists within this range then it belongs to that section.        Calculate the file offset:          Subtract the RVA from the section virtual address.      Add that value to the raw data pointer of the section.      An example of this is locating a Data Directory.The IMAGE_DATA_DIRECTORY structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address.I wrote two functions to do this, first one to locate the virtual address (locate()), second one to resolve the address (resolve()).int PE64FILE::locate(DWORD VA) {		int index;		for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) {		if (VA &gt;= PEFILE_SECTION_HEADERS[i].VirtualAddress			&amp;&amp; VA &lt; (PEFILE_SECTION_HEADERS[i].VirtualAddress + PEFILE_SECTION_HEADERS[i].Misc.VirtualSize)){			index = i;			break;		}	}	return index;}DWORD PE64FILE::resolve(DWORD VA, int index) {	return (VA - PEFILE_SECTION_HEADERS[index].VirtualAddress) + PEFILE_SECTION_HEADERS[index].PointerToRawData;}locate() iterates over the PEFILE_SECTION_HEADERS array, compares the RVA as described above, then it returns the index of the appropriate section header within the PEFILE_SECTION_HEADERS array.Please note that in order for these functions to work we’ll need to parse out the section headers and fill the PEFILE_SECTION_HEADERS array first.We still haven’t discussed this part, but I wanted to talk about the address resolvers first.main functionThe main function of the program is fairly simple, it only does 2 things:  Create a file pointer to the given file, and validate that the file was read correctly.  Call INITPARSE() on the file, and based on the return value it decides between three actions:          Exit.      Create a PE32FILE object, call PrintInfo(), close the file pointer then exit.      Create a PE64FILE object, call PrintInfo(), close the file pointer then exit.      PrintInfo() calls the other print info functions.int main(int argc, char* argv[]){	if (argc != 2) {		printf(&quot;Usage: %s [path to executable]\n&quot;, argv[0]);		return 1;	}	FILE * PpeFile;	fopen_s(&amp;PpeFile, argv[1], &quot;rb&quot;);	if (PpeFile == NULL) {		printf(&quot;Can't open file.\n&quot;);		return 1;	}	if (INITPARSE(PpeFile) == 1) {		exit(1);	}	else if (INITPARSE(PpeFile) == 32) {		PE32FILE PeFile_1(argv[1], PpeFile);		PeFile_1.PrintInfo();		fclose(PpeFile);		exit(0);	}	else if (INITPARSE(PpeFile) == 64) {		PE64FILE PeFile_1(argv[1], PpeFile);		PeFile_1.PrintInfo();		fclose(PpeFile);		exit(0);	}	return 0;}INITPARSE()INITPARSE() is a function defined in PEFILE.cpp.Its only job is to validate that the given file is a PE file, then determine whether the file is PE32 or PE32+.It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error.After validating the PE file, it sets the file position to (DOS_HEADER.e_lfanew + size of DWORD (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header.Then it reads a WORD, we know that the first WORD of the Optional Header is a magic value that indicates the file type, it then compares that word to IMAGE_NT_OPTIONAL_HDR32_MAGIC and IMAGE_NT_OPTIONAL_HDR64_MAGIC, and based on the comparison results it either returns 32 or 64 indicating PE32 or PE32+, or it returns an error.int INITPARSE(FILE* PpeFile) {	___IMAGE_DOS_HEADER TMP_DOS_HEADER;	WORD PEFILE_TYPE;	fseek(PpeFile, 0, SEEK_SET);	fread(&amp;TMP_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, PpeFile);	if (TMP_DOS_HEADER.e_magic != ___IMAGE_DOS_SIGNATURE) {		printf(&quot;Error. Not a PE file.\n&quot;);		return 1;	}	fseek(PpeFile, (TMP_DOS_HEADER.e_lfanew + sizeof(DWORD) + sizeof(___IMAGE_FILE_HEADER)), SEEK_SET);	fread(&amp;PEFILE_TYPE, sizeof(WORD), 1, PpeFile);	if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR32_MAGIC) {		return 32;	}	else if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR64_MAGIC) {		return 64;	}	else {		printf(&quot;Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\n&quot;);		return 1;	}}Parsing DOS HeaderParseDOSHeader()Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member PEFILE_DOS_HEADER.From there we can access all of the struct members, however we’re only interested in e_magic and e_lfanew.void PE64FILE::ParseDOSHeader() {		fseek(Ppefile, 0, SEEK_SET);	fread(&amp;PEFILE_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, Ppefile);	PEFILE_DOS_HEADER_EMAGIC = PEFILE_DOS_HEADER.e_magic;	PEFILE_DOS_HEADER_LFANEW = PEFILE_DOS_HEADER.e_lfanew;}PrintDOSHeaderInfo()This function prints e_magic and e_lfanew values.void PE64FILE::PrintDOSHeaderInfo() {		printf(&quot; DOS HEADER:\n&quot;);	printf(&quot; -----------\n\n&quot;);	printf(&quot; Magic: 0x%X\n&quot;, PEFILE_DOS_HEADER_EMAGIC);	printf(&quot; File address of new exe header: 0x%X\n&quot;, PEFILE_DOS_HEADER_LFANEW);}Parsing Rich HeaderProcessTo parse out the Rich Header we’ll need to go through multiple steps.We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place.First of all, we need to locate the Rich Header.We don’t know the exact location, however we have everything we need to locate it.We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers.We also know that any Rich Header ends with a 32-bit value Rich followed by the XOR key.One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed.A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the Rich sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header.Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the Rich signature and keep XORing 4 bytes at a time until we reach the DanS signature which indicates the beginning of the Rich Header.After obtaining the position and the size of the Rich Header, we can normally read and process the data.ParseRichHeader()This function starts by allocating a buffer on the heap, then it reads e_lfanew size of bytes from the beginning of the file and stores the data in the allocated buffer.It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to 0x52 (R) and 0x69 (i).When the sequence is found, it stores the index in a variable then the loop breaks.	char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW];	fseek(Ppefile, 0, SEEK_SET);	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);	int index_ = 0;	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) {		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) {			index_ = i;			break;		}	}	if (index_ == 0) {		printf(&quot;Error while parsing Rich Header.&quot;);		PEFILE_RICH_HEADER_INFO.entries = 0;		return;	}After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments RichHeaderSize by 4 until it reaches the DanS sequence.	char key[4];	memcpy(key, dataPtr + (index_ + 4), 4);	int indexpointer = index_ - 4;	int RichHeaderSize = 0;	while (true) {		char tmpchar[4];		memcpy(tmpchar, dataPtr + indexpointer, 4);		for (int i = 0; i &lt; 4; i++) {			tmpchar[i] = tmpchar[i] ^ key[i];		}		indexpointer -= 4;		RichHeaderSize += 4;		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) {			break;		}	}After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates PEFILE_RICH_HEADER_INFO with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing.	char* RichHeaderPtr = new char[RichHeaderSize];	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);	for (int i = 0; i &lt; RichHeaderSize; i += 4) {		for (int x = 0; x &lt; 4; x++) {			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x];		}	}	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize;	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr;	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;	delete[] dataPtr;The rest of the function reads each entry of the Rich Header and updates PEFILE_RICH_HEADER.	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];	for (int i = 16; i &lt; RichHeaderSize; i += 8) {		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2];		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i];		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4];		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = {			PRODID,			BUILDID,			USECOUNT		};		if (i + 8 &gt;= RichHeaderSize) {			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 };		}	}	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;Here’s the full function:void PE64FILE::ParseRichHeader() {		char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW];	fseek(Ppefile, 0, SEEK_SET);	fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile);	int index_ = 0;	for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) {		if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) {			index_ = i;			break;		}	}	if (index_ == 0) {		printf(&quot;Error while parsing Rich Header.&quot;);		PEFILE_RICH_HEADER_INFO.entries = 0;		return;	}	char key[4];	memcpy(key, dataPtr + (index_ + 4), 4);	int indexpointer = index_ - 4;	int RichHeaderSize = 0;	while (true) {		char tmpchar[4];		memcpy(tmpchar, dataPtr + indexpointer, 4);		for (int i = 0; i &lt; 4; i++) {			tmpchar[i] = tmpchar[i] ^ key[i];		}		indexpointer -= 4;		RichHeaderSize += 4;		if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) {			break;		}	}	char* RichHeaderPtr = new char[RichHeaderSize];	memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize);	for (int i = 0; i &lt; RichHeaderSize; i += 4) {		for (int x = 0; x &lt; 4; x++) {			RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x];		}	}	PEFILE_RICH_HEADER_INFO.size = RichHeaderSize;	PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr;	PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8;	delete[] dataPtr;	PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries];	for (int i = 16; i &lt; RichHeaderSize; i += 8) {		WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2];		WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i];		DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4];		PEFILE_RICH_HEADER.entries[(i / 8) - 2] = {			PRODID,			BUILDID,			USECOUNT		};		if (i + 8 &gt;= RichHeaderSize) {			PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 };		}	}	delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer;}PrintRichHeaderInfo()This function iterates over each entry in PEFILE_RICH_HEADER and prints its value.void PE64FILE::PrintRichHeaderInfo() {		printf(&quot; RICH HEADER:\n&quot;);	printf(&quot; ------------\n\n&quot;);	for (int i = 0; i &lt; PEFILE_RICH_HEADER_INFO.entries; i++) {		printf(&quot; 0x%X 0x%X 0x%X: %d.%d.%d\n&quot;,			PEFILE_RICH_HEADER.entries[i].buildID,			PEFILE_RICH_HEADER.entries[i].prodID,			PEFILE_RICH_HEADER.entries[i].useCount,			PEFILE_RICH_HEADER.entries[i].buildID,			PEFILE_RICH_HEADER.entries[i].prodID,			PEFILE_RICH_HEADER.entries[i].useCount);	}}Parsing NT HeadersParseNTHeaders()Similar to the DOS Header, all we need to do is to read from e_lfanew an amount of bytes equal to the size of IMAGE_NT_HEADERS.After that we can parse out the contents of the File Header and the Optional Header.The Optional Header contains an array of IMAGE_DATA_DIRECTORY structures which we care about.To parse out this information, we can use the IMAGE_DIRECTORY_[...] constants defined in winnt.h as array indexes to access the corresponding IMAGE_DATA_DIRECTORY structure of each Data Directory.void PE64FILE::ParseNTHeaders() {		fseek(Ppefile, PEFILE_DOS_HEADER.e_lfanew, SEEK_SET);	fread(&amp;PEFILE_NT_HEADERS, sizeof(PEFILE_NT_HEADERS), 1, Ppefile);	PEFILE_NT_HEADERS_SIGNATURE = PEFILE_NT_HEADERS.Signature;	PEFILE_NT_HEADERS_FILE_HEADER_MACHINE = PEFILE_NT_HEADERS.FileHeader.Machine;	PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS = PEFILE_NT_HEADERS.FileHeader.NumberOfSections;	PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER = PEFILE_NT_HEADERS.FileHeader.SizeOfOptionalHeader;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC = PEFILE_NT_HEADERS.OptionalHeader.Magic;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfCode;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfInitializedData;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT = PEFILE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.BaseOfCode;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE = PEFILE_NT_HEADERS.OptionalHeader.ImageBase;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.SectionAlignment;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.FileAlignment;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfImage;	PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS = PEFILE_NT_HEADERS.OptionalHeader.SizeOfHeaders;	PEFILE_EXPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT];	PEFILE_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT];	PEFILE_RESOURCE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE];	PEFILE_EXCEPTION_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXCEPTION];	PEFILE_SECURITY_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_SECURITY];	PEFILE_BASERELOC_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC];	PEFILE_DEBUG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DEBUG];	PEFILE_ARCHITECTURE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE];	PEFILE_GLOBALPTR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_GLOBALPTR];	PEFILE_TLS_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_TLS];	PEFILE_LOAD_CONFIG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];	PEFILE_BOUND_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];	PEFILE_IAT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IAT];	PEFILE_DELAY_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];	PEFILE_COM_DESCRIPTOR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];}PrintNTHeadersInfo()This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size.void PE64FILE::PrintNTHeadersInfo() {		printf(&quot; NT HEADERS:\n&quot;);	printf(&quot; -----------\n\n&quot;);	printf(&quot; PE Signature: 0x%X\n&quot;, PEFILE_NT_HEADERS_SIGNATURE);	printf(&quot;\n File Header:\n\n&quot;);	printf(&quot;   Machine: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_MACHINE);	printf(&quot;   Number of sections: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS);	printf(&quot;   Size of optional header: 0x%X\n&quot;, PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER);	printf(&quot;\n Optional Header:\n\n&quot;);	printf(&quot;   Magic: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC);	printf(&quot;   Size of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE);	printf(&quot;   Size of initialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA);	printf(&quot;   Size of uninitialized data: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA);	printf(&quot;   Address of entry point: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT);	printf(&quot;   RVA of start of code section: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE);	printf(&quot;   Desired image base: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE);	printf(&quot;   Section alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT);	printf(&quot;   File alignment: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT);	printf(&quot;   Size of image: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE);	printf(&quot;   Size of headers: 0x%X\n&quot;, PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS);	printf(&quot;\n Data Directories:\n&quot;);	printf(&quot;\n   * Export Directory:\n&quot;);	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.VirtualAddress);	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_EXPORT_DIRECTORY.Size);	.	.	[REDACTED]	.	.	printf(&quot;\n   * COM Runtime Descriptor:\n&quot;);	printf(&quot;       RVA: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.VirtualAddress);	printf(&quot;       Size: 0x%X\n&quot;, PEFILE_COM_DESCRIPTOR_DIRECTORY.Size);}Parsing Section HeadersParseSectionHeaders()This function starts by assigning the PEFILE_SECTION_HEADERS class member to a pointer to an IMAGE_SECTION_HEADER array of the count of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS.Then it goes into a loop of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS iterations where in each iteration it changes the file offset to (e_lfanew + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of PEFILE_SECTION_HEADERS.void PE64FILE::ParseSectionHeaders() {		PEFILE_SECTION_HEADERS = new ___IMAGE_SECTION_HEADER[PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS];	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) {		int offset = (PEFILE_DOS_HEADER.e_lfanew + sizeof(PEFILE_NT_HEADERS)) + (i * ___IMAGE_SIZEOF_SECTION_HEADER);		fseek(Ppefile, offset, SEEK_SET);		fread(&amp;PEFILE_SECTION_HEADERS[i], ___IMAGE_SIZEOF_SECTION_HEADER, 1, Ppefile);	}}PrintSectionHeadersInfo()This function loops over the Section Headers array (filled by ParseSectionHeaders()), and it prints information about each section.void PE64FILE::PrintSectionHeadersInfo() {		printf(&quot; SECTION HEADERS:\n&quot;);	printf(&quot; ----------------\n\n&quot;);	for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) {		printf(&quot;   * %.8s:\n&quot;, PEFILE_SECTION_HEADERS[i].Name);		printf(&quot;        VirtualAddress: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].VirtualAddress);		printf(&quot;        VirtualSize: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].Misc.VirtualSize);		printf(&quot;        PointerToRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].PointerToRawData);		printf(&quot;        SizeOfRawData: 0x%X\n&quot;, PEFILE_SECTION_HEADERS[i].SizeOfRawData);		printf(&quot;        Characteristics: 0x%X\n\n&quot;, PEFILE_SECTION_HEADERS[i].Characteristics);	}}Parsing ImportsParseImportDirectory()To parse out the Import Directory Table we need to determine the count of IMAGE_IMPORT_DESCRIPTORs first.This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor.In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks.Otherwise it increments _import_directory_count and the loop continues.After finding the size of the Import Directory, the function assigns the PEFILE_IMPORT_TABLE class member to a pointer to an IMAGE_IMPORT_DESCRIPTOR array of the count of _import_directory_count then goes into another loop similar to the one we’ve seen in ParseSectionHeaders() to parse out the import descriptors.void PE64FILE::ParseImportDirectory() {		DWORD _import_directory_address = resolve(PEFILE_IMPORT_DIRECTORY.VirtualAddress, locate(PEFILE_IMPORT_DIRECTORY.VirtualAddress));	_import_directory_count = 0;	while (true) {		___IMAGE_IMPORT_DESCRIPTOR tmp;		int offset = (_import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address;		fseek(Ppefile, offset, SEEK_SET);		fread(&amp;tmp, sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile);		if (tmp.Name == 0x00000000 &amp;&amp; tmp.FirstThunk == 0x00000000) {			_import_directory_count -= 1;			_import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR);			break;		}		_import_directory_count++;	}	PEFILE_IMPORT_TABLE = new ___IMAGE_IMPORT_DESCRIPTOR[_import_directory_count];	for (int i = 0; i &lt; _import_directory_count; i++) {		int offset = (i * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address;		fseek(Ppefile, offset, SEEK_SET);		fread(&amp;PEFILE_IMPORT_TABLE[i], sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile);	}}PrintImportTableInfo()After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions.This is done by the PrintImportTableInfo() function.This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not.After that it resolves the file offset of the ILT then it parses out each ILT entry.If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint.If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts.We’ve discussed the details about this in the PE imports post.void PE64FILE::PrintImportTableInfo() {		printf(&quot; IMPORT TABLE:\n&quot;);	printf(&quot; ----------------\n\n&quot;);	for (int i = 0; i &lt; _import_directory_count; i++) {		DWORD NameAddr = resolve(PEFILE_IMPORT_TABLE[i].Name, locate(PEFILE_IMPORT_TABLE[i].Name));		int NameSize = 0;		while (true) {			char tmp;			fseek(Ppefile, (NameAddr + NameSize), SEEK_SET);			fread(&amp;tmp, sizeof(char), 1, Ppefile);			if (tmp == 0x00) {				break;			}			NameSize++;		}		char* Name = new char[NameSize + 2];		fseek(Ppefile, NameAddr, SEEK_SET);		fread(Name, (NameSize * sizeof(char)) + 1, 1, Ppefile);		printf(&quot;   * %s:\n&quot;, Name);		delete[] Name;		printf(&quot;       ILT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk);		printf(&quot;       IAT RVA: 0x%X\n&quot;, PEFILE_IMPORT_TABLE[i].FirstThunk);		if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == 0) {			printf(&quot;       Bound: FALSE\n&quot;);		}		else if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == -1) {			printf(&quot;       Bound: TRUE\n&quot;);		}		printf(&quot;\n&quot;);		DWORD ILTAddr = resolve(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk, locate(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk));		int entrycounter = 0;		while (true) {			ILT_ENTRY_64 entry;			fseek(Ppefile, (ILTAddr + (entrycounter * sizeof(QWORD))), SEEK_SET);			fread(&amp;entry, sizeof(ILT_ENTRY_64), 1, Ppefile);			BYTE flag = entry.ORDINAL_NAME_FLAG;			DWORD HintRVA = 0x0;			WORD ordinal = 0x0;			if (flag == 0x0) {				HintRVA = entry.FIELD_2.HINT_NAME_TABE;			}			else if (flag == 0x01) {				ordinal = entry.FIELD_2.ORDINAL;			}			if (flag == 0x0 &amp;&amp; HintRVA == 0x0 &amp;&amp; ordinal == 0x0) {				break;			}			printf(&quot;\n       Entry:\n&quot;);			if (flag == 0x0) {				___IMAGE_IMPORT_BY_NAME hint;				DWORD HintAddr = resolve(HintRVA, locate(HintRVA));				fseek(Ppefile, HintAddr, SEEK_SET);				fread(&amp;hint, sizeof(___IMAGE_IMPORT_BY_NAME), 1, Ppefile);				printf(&quot;         Name: %s\n&quot;, hint.Name);				printf(&quot;         Hint RVA: 0x%X\n&quot;, HintRVA);				printf(&quot;         Hint: 0x%X\n&quot;, hint.Hint);			}			else if (flag == 1) {				printf(&quot;         Ordinal: 0x%X\n&quot;, ordinal);			}			entrycounter++;		}		printf(&quot;\n   ----------------------\n\n&quot;);	}}Parsing Base RelocationsParseBaseReloc()This function follows the same process we’ve seen in ParseImportDirectory().It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each IMAGE_BASE_RELOCATION structure in PEFILE_BASERELOC_TABLE.One thing to note here that is different from what we’ve seen in ParseImportDirectory() is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of SizeOfBlock of each block in each iteration.We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks.void PE64FILE::ParseBaseReloc() {		DWORD _basereloc_directory_address = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress));	_basreloc_directory_count = 0;	int _basereloc_size_counter = 0;	while (true) {		___IMAGE_BASE_RELOCATION tmp;		int offset = (_basereloc_size_counter + _basereloc_directory_address);		fseek(Ppefile, offset, SEEK_SET);		fread(&amp;tmp, sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile);		if (tmp.VirtualAddress == 0x00000000 &amp;&amp;			tmp.SizeOfBlock == 0x00000000) {			break;		}		_basreloc_directory_count++;		_basereloc_size_counter += tmp.SizeOfBlock;	}	PEFILE_BASERELOC_TABLE = new ___IMAGE_BASE_RELOCATION[_basreloc_directory_count];	_basereloc_size_counter = 0;	for (int i = 0; i &lt; _basreloc_directory_count; i++) {		int offset = _basereloc_directory_address + _basereloc_size_counter;		fseek(Ppefile, offset, SEEK_SET);		fread(&amp;PEFILE_BASERELOC_TABLE[i], sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile);		_basereloc_size_counter += PEFILE_BASERELOC_TABLE[i].SizeOfBlock;	}}PrintBaseRelocationInfo()This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of IMAGE_BASE_RELOCATION from the block size then dividing that by the size of a WORD).After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them.We’ve discussed the details about this in the PE base relocations post.void PE64FILE::PrintBaseRelocationsInfo() {		printf(&quot; BASE RELOCATIONS TABLE:\n&quot;);	printf(&quot; -----------------------\n&quot;);	int szCounter = sizeof(___IMAGE_BASE_RELOCATION);	for (int i = 0; i &lt; _basreloc_directory_count; i++) {		DWORD PAGERVA, BLOCKSIZE, BASE_RELOC_ADDR;		int ENTRIES;		BASE_RELOC_ADDR = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress));		PAGERVA = PEFILE_BASERELOC_TABLE[i].VirtualAddress;		BLOCKSIZE = PEFILE_BASERELOC_TABLE[i].SizeOfBlock;		ENTRIES = (BLOCKSIZE - sizeof(___IMAGE_BASE_RELOCATION)) / sizeof(WORD);		printf(&quot;\n   Block 0x%X: \n&quot;, i);		printf(&quot;     Page RVA: 0x%X\n&quot;, PAGERVA);		printf(&quot;     Block size: 0x%X\n&quot;, BLOCKSIZE);		printf(&quot;     Number of entries: 0x%X\n&quot;, ENTRIES);		printf(&quot;\n     Entries:\n&quot;);		for (int i = 0; i &lt; ENTRIES; i++) {			BASE_RELOC_ENTRY entry;			int offset = (BASE_RELOC_ADDR + szCounter + (i * sizeof(WORD)));			fseek(Ppefile, offset, SEEK_SET);			fread(&amp;entry, sizeof(WORD), 1, Ppefile);			printf(&quot;\n       * Value: 0x%X\n&quot;, entry);			printf(&quot;         Relocation Type: 0x%X\n&quot;, entry.TYPE);			printf(&quot;         Offset: 0x%X\n&quot;, entry.OFFSET);		}		printf(&quot;\n   ----------------------\n\n&quot;);		szCounter += BLOCKSIZE;	}}ConclusionHere’s the full output after running the parser on a file:Desktop&gt;.\PE-Parser.exe .\SimpleApp64.exe FILE: .\SimpleApp64.exe TYPE: 0x20B (PE32+) ---------------------------------- DOS HEADER: ----------- Magic: 0x5A4D File address of new exe header: 0x100 ---------------------------------- RICH HEADER: ------------ 0x7809 0x93 0xA: 30729.147.10 0x6FCB 0x101 0x2: 28619.257.2 0x6FCB 0x105 0x11: 28619.261.17 0x6FCB 0x104 0xA: 28619.260.10 0x6FCB 0x103 0x3: 28619.259.3 0x685B 0x101 0x5: 26715.257.5 0x0 0x1 0x30: 0.1.48 0x7086 0x109 0x1: 28806.265.1 0x7086 0xFF 0x1: 28806.255.1 0x7086 0x102 0x1: 28806.258.1 ---------------------------------- NT HEADERS: ----------- PE Signature: 0x4550 File Header:   Machine: 0x8664   Number of sections: 0x6   Size of optional header: 0xF0 Optional Header:   Magic: 0x20B   Size of code section: 0xE00   Size of initialized data: 0x1E00   Size of uninitialized data: 0x0   Address of entry point: 0x12C4   RVA of start of code section: 0x1000   Desired image base: 0x40000000   Section alignment: 0x1000   File alignment: 0x200   Size of image: 0x7000   Size of headers: 0x400 Data Directories:   * Export Directory:       RVA: 0x0       Size: 0x0   * Import Directory:       RVA: 0x27AC       Size: 0xB4   * Resource Directory:       RVA: 0x5000       Size: 0x1E0   * Exception Directory:       RVA: 0x4000       Size: 0x168   * Security Directory:       RVA: 0x0       Size: 0x0   * Base Relocation Table:       RVA: 0x6000       Size: 0x28   * Debug Directory:       RVA: 0x2248       Size: 0x70   * Architecture Specific Data:       RVA: 0x0       Size: 0x0   * RVA of GlobalPtr:       RVA: 0x0       Size: 0x0   * TLS Directory:       RVA: 0x0       Size: 0x0   * Load Configuration Directory:       RVA: 0x22C0       Size: 0x130   * Bound Import Directory:       RVA: 0x0       Size: 0x0   * Import Address Table:       RVA: 0x2000       Size: 0x198   * Delay Load Import Descriptors:       RVA: 0x0       Size: 0x0   * COM Runtime Descriptor:       RVA: 0x0       Size: 0x0 ---------------------------------- SECTION HEADERS: ----------------   * .text:        VirtualAddress: 0x1000        VirtualSize: 0xD2C        PointerToRawData: 0x400        SizeOfRawData: 0xE00        Characteristics: 0x60000020   * .rdata:        VirtualAddress: 0x2000        VirtualSize: 0xE3C        PointerToRawData: 0x1200        SizeOfRawData: 0x1000        Characteristics: 0x40000040   * .data:        VirtualAddress: 0x3000        VirtualSize: 0x638        PointerToRawData: 0x2200        SizeOfRawData: 0x200        Characteristics: 0xC0000040   * .pdata:        VirtualAddress: 0x4000        VirtualSize: 0x168        PointerToRawData: 0x2400        SizeOfRawData: 0x200        Characteristics: 0x40000040   * .rsrc:        VirtualAddress: 0x5000        VirtualSize: 0x1E0        PointerToRawData: 0x2600        SizeOfRawData: 0x200        Characteristics: 0x40000040   * .reloc:        VirtualAddress: 0x6000        VirtualSize: 0x28        PointerToRawData: 0x2800        SizeOfRawData: 0x200        Characteristics: 0x42000040 ---------------------------------- IMPORT TABLE: ----------------   * USER32.dll:       ILT RVA: 0x28E0       IAT RVA: 0x2080       Bound: FALSE       Entry:         Name: MessageBoxA         Hint RVA: 0x29F8         Hint: 0x283   ----------------------   * VCRUNTIME140.dll:       ILT RVA: 0x28F0       IAT RVA: 0x2090       Bound: FALSE       Entry:         Name: memset         Hint RVA: 0x2A5E         Hint: 0x3E       Entry:         Name: __current_exception_context         Hint RVA: 0x2A40         Hint: 0x1C       Entry:         Name: __current_exception         Hint RVA: 0x2A2A         Hint: 0x1B       Entry:         Name: __C_specific_handler         Hint RVA: 0x2A12         Hint: 0x8   ----------------------   * api-ms-win-crt-runtime-l1-1-0.dll:       ILT RVA: 0x2948       IAT RVA: 0x20E8       Bound: FALSE       Entry:         Name: _crt_atexit         Hint RVA: 0x2C12         Hint: 0x1E       Entry:         Name: terminate         Hint RVA: 0x2C20         Hint: 0x67       Entry:         Name: _exit         Hint RVA: 0x2B30         Hint: 0x23       Entry:         Name: _register_thread_local_exe_atexit_callback         Hint RVA: 0x2B76         Hint: 0x3D       Entry:         Name: _c_exit         Hint RVA: 0x2B6C         Hint: 0x15       Entry:         Name: exit         Hint RVA: 0x2B28         Hint: 0x55       Entry:         Name: _initterm_e         Hint RVA: 0x2B1A         Hint: 0x37       Entry:         Name: _initterm         Hint RVA: 0x2B0E         Hint: 0x36       Entry:         Name: _get_initial_narrow_environment         Hint RVA: 0x2AEC         Hint: 0x28       Entry:         Name: _initialize_narrow_environment         Hint RVA: 0x2ACA         Hint: 0x33       Entry:         Name: _configure_narrow_argv         Hint RVA: 0x2AB0         Hint: 0x18       Entry:         Name: _initialize_onexit_table         Hint RVA: 0x2BDA         Hint: 0x34       Entry:         Name: _set_app_type         Hint RVA: 0x2A8C         Hint: 0x42       Entry:         Name: _seh_filter_exe         Hint RVA: 0x2A7A         Hint: 0x40       Entry:         Name: _cexit         Hint RVA: 0x2B62         Hint: 0x16       Entry:         Name: __p___argv         Hint RVA: 0x2B54         Hint: 0x5       Entry:         Name: __p___argc         Hint RVA: 0x2B46         Hint: 0x4       Entry:         Name: _register_onexit_function         Hint RVA: 0x2BF6         Hint: 0x3C   ----------------------   * api-ms-win-crt-math-l1-1-0.dll:       ILT RVA: 0x2938       IAT RVA: 0x20D8       Bound: FALSE       Entry:         Name: __setusermatherr         Hint RVA: 0x2A9C         Hint: 0x9   ----------------------   * api-ms-win-crt-stdio-l1-1-0.dll:       ILT RVA: 0x29E0       IAT RVA: 0x2180       Bound: FALSE       Entry:         Name: __p__commode         Hint RVA: 0x2BCA         Hint: 0x1       Entry:         Name: _set_fmode         Hint RVA: 0x2B38         Hint: 0x54   ----------------------   * api-ms-win-crt-locale-l1-1-0.dll:       ILT RVA: 0x2928       IAT RVA: 0x20C8       Bound: FALSE       Entry:         Name: _configthreadlocale         Hint RVA: 0x2BA4         Hint: 0x8   ----------------------   * api-ms-win-crt-heap-l1-1-0.dll:       ILT RVA: 0x2918       IAT RVA: 0x20B8       Bound: FALSE       Entry:         Name: _set_new_mode         Hint RVA: 0x2BBA         Hint: 0x16   ---------------------- ---------------------------------- BASE RELOCATIONS TABLE: -----------------------   Block 0x0:     Page RVA: 0x2000     Block size: 0x28     Number of entries: 0x10     Entries:       * Value: 0xA198         Relocation Type: 0xA         Offset: 0x198       * Value: 0xA1A0         Relocation Type: 0xA         Offset: 0x1A0       * Value: 0xA1A8         Relocation Type: 0xA         Offset: 0x1A8       * Value: 0xA1B0         Relocation Type: 0xA         Offset: 0x1B0       * Value: 0xA1B8         Relocation Type: 0xA         Offset: 0x1B8       * Value: 0xA1C8         Relocation Type: 0xA         Offset: 0x1C8       * Value: 0xA1E0         Relocation Type: 0xA         Offset: 0x1E0       * Value: 0xA1E8         Relocation Type: 0xA         Offset: 0x1E8       * Value: 0xA220         Relocation Type: 0xA         Offset: 0x220       * Value: 0xA228         Relocation Type: 0xA         Offset: 0x228       * Value: 0xA318         Relocation Type: 0xA         Offset: 0x318       * Value: 0xA330         Relocation Type: 0xA         Offset: 0x330       * Value: 0xA338         Relocation Type: 0xA         Offset: 0x338       * Value: 0xA3D8         Relocation Type: 0xA         Offset: 0x3D8       * Value: 0xA3E0         Relocation Type: 0xA         Offset: 0x3E0       * Value: 0xA3E8         Relocation Type: 0xA         Offset: 0x3E8   ---------------------- ----------------------------------I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts.I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated.Thanks for reading.">
    <meta itemprop="datePublished" content="2021-10-29T03:00:00+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="https://0xrick.github.io/win-internals/pe8/" class="u-url" itemprop="url">A dive into the PE file format - LAB 1: Writing a PE Parser
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-10-29T03:00:00+02:00">October 29, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          28 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content e-content" itemprop="text">
        <div>
          <style>
              #carbonads {
                border: 1px solid black;
                border-radius: 7px;
                border-spacing: 7px;
                display: block;
                overflow: hidden;
                padding: 1em;
                line-height: 1.5;
              }
              #carbonads span {
                position: relative;
                display: block;
                overflow: hidden;
              }
              .carbon-img img {
                display: block;
                float: left;
              }
              .carbon-text {
                display: block;
                font-size: .9em;
                text-align: end;
              }
              .carbon-poweredby {
                display: block;
                font-size: .8em;
                float: right;
                line-height: 1;
                letter-spacing: 1px;
                }
                </style>
                <br>   
          <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CK7DL23U&amp;placement=0xrickgithubio" id="_carbonads_js"></script> 
                <br>
        </div>
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu"><li>
<a href="#a-dive-into-the-pe-file-format---lab-1-writing-a-pe-parser">A dive into the PE file format - LAB 1: Writing a PE Parser</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li>
<a href="#initial-setup">Initial Setup</a><ul>
<li><a href="#process-outline">Process Outline</a></li>
<li><a href="#winnth-definitions">winnt.h Definitions</a></li>
<li>
<a href="#custom-structures">Custom Structures</a><ul>
<li><a href="#rich_header_info">RICH_HEADER_INFO</a></li>
<li><a href="#rich_header_entry">RICH_HEADER_ENTRY</a></li>
<li><a href="#rich_header">RICH_HEADER</a></li>
<li><a href="#ilt_entry_32">ILT_ENTRY_32</a></li>
<li><a href="#ilt_entry_64">ILT_ENTRY_64</a></li>
<li><a href="#base_reloc_entry">BASE_RELOC_ENTRY</a></li>
</ul>
</li>
<li>
<a href="#pefile">PEFILE</a><ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#constructor">Constructor</a></li>
</ul>
</li>
<li><a href="#resolving-rvas">Resolving RVAs</a></li>
<li><a href="#main-function">main function</a></li>
<li><a href="#initparse">INITPARSE()</a></li>
</ul>
</li>
<li>
<a href="#parsing-dos-header">Parsing DOS Header</a><ul>
<li><a href="#parsedosheader">ParseDOSHeader()</a></li>
<li><a href="#printdosheaderinfo">PrintDOSHeaderInfo()</a></li>
</ul>
</li>
<li>
<a href="#parsing-rich-header">Parsing Rich Header</a><ul>
<li><a href="#process">Process</a></li>
<li><a href="#parserichheader">ParseRichHeader()</a></li>
<li><a href="#printrichheaderinfo">PrintRichHeaderInfo()</a></li>
</ul>
</li>
<li>
<a href="#parsing-nt-headers">Parsing NT Headers</a><ul>
<li><a href="#parsentheaders">ParseNTHeaders()</a></li>
<li><a href="#printntheadersinfo">PrintNTHeadersInfo()</a></li>
</ul>
</li>
<li>
<a href="#parsing-section-headers">Parsing Section Headers</a><ul>
<li><a href="#parsesectionheaders">ParseSectionHeaders()</a></li>
<li><a href="#printsectionheadersinfo">PrintSectionHeadersInfo()</a></li>
</ul>
</li>
<li>
<a href="#parsing-imports">Parsing Imports</a><ul>
<li><a href="#parseimportdirectory">ParseImportDirectory()</a></li>
<li><a href="#printimporttableinfo">PrintImportTableInfo()</a></li>
</ul>
</li>
<li>
<a href="#parsing-base-relocations">Parsing Base Relocations</a><ul>
<li><a href="#parsebasereloc">ParseBaseReloc()</a></li>
<li><a href="#printbaserelocationinfo">PrintBaseRelocationInfo()</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li></ul>

            </nav>
          </aside>
        
        <h2 id="a-dive-into-the-pe-file-format---lab-1-writing-a-pe-parser">A dive into the PE file format - LAB 1: Writing a PE Parser</h2>

<h3 id="introduction">Introduction</h3>

<p>In the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept.</p>

<p>The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure.
<br>We’re going to focus on <code class="language-plaintext highlighter-rouge">PE32</code> and <code class="language-plaintext highlighter-rouge">PE32+</code> files, and we’ll only parse the following parts of the file:</p>

<ul>
  <li>DOS Header</li>
  <li>Rich Header</li>
  <li>NT Headers</li>
  <li>Data Directories (within the Optional Header)</li>
  <li>Section Headers</li>
  <li>Import Table</li>
  <li>Base Relocations Table</li>
</ul>

<p>The code of this project can be found on my <a href="https://github.com/0xRick/PE-Parser/" target="_blank" rel="noopener noreferrer">github profile</a>.</p>

<hr>

<h3 id="initial-setup">Initial Setup</h3>

<h4 id="process-outline">Process Outline</h4>

<p>We want out parser to follow the following process:</p>

<ol>
  <li>Read a file.</li>
  <li>Validate that it’s a PE file.</li>
  <li>Determine whether it’s a <code class="language-plaintext highlighter-rouge">PE32</code> or a <code class="language-plaintext highlighter-rouge">PE32+</code>.</li>
  <li>Parse out the following structures:
    <ul>
      <li>DOS Header</li>
      <li>Rich Header</li>
      <li>NT Headers</li>
      <li>Section Headers</li>
      <li>Import Data Directory</li>
      <li>Base Relocation Data Directory</li>
    </ul>
  </li>
  <li>Print out the following information:
    <ul>
      <li>File name and type.</li>
      <li>DOS Header:
        <ul>
          <li>Magic value.</li>
          <li>Address of new exe header.</li>
        </ul>
      </li>
      <li>Each entry of the Rich Header, decrypted and decoded.</li>
      <li>NT Headers - PE file signature.</li>
      <li>NT Headers - File Header:
        <ul>
          <li>Machine value.</li>
          <li>Number of sections.</li>
          <li>Size of Optional Header.</li>
        </ul>
      </li>
      <li>NT Headers - Optional Header:
        <ul>
          <li>Magic value.</li>
          <li>Size of code section.</li>
          <li>Size of initialized data.</li>
          <li>Size of uninitialized data.</li>
          <li>Address of entry point.</li>
          <li>RVA of start of code section.</li>
          <li>Desired Image Base.</li>
          <li>Section alignment.</li>
          <li>File alignment.</li>
          <li>Size of image.</li>
          <li>Size of headers.</li>
        </ul>
      </li>
      <li>For each Data Directory: its name, RVA and size.</li>
      <li>For each Section Header:
        <ul>
          <li>Section name.</li>
          <li>Section virtual address and size.</li>
          <li>Section raw data pointer and size.</li>
          <li>Section characteristics value.</li>
        </ul>
      </li>
      <li>Import Table:
        <ul>
          <li>For each DLL:
            <ul>
              <li>DLL name.</li>
              <li>ILT and IAT RVAs.</li>
              <li>Whether its a bound import or not.</li>
              <li>for every imported function:
                <ul>
                  <li>Ordinal if ordinal/name flag is 1.</li>
                  <li>Name, hint and Hint/Name table RVA if ordinal/name flag is 0.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Base Relocation Table:
        <ul>
          <li>For each block:
            <ul>
              <li>Page RVA.</li>
              <li>Block size.</li>
              <li>Number of entries.</li>
              <li>For each entry:
                <ul>
                  <li>Raw value.</li>
                  <li>Relocation offset.</li>
                  <li>Relocation Type.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h4 id="winnth-definitions">winnt.h Definitions</h4>

<p>We will need the following definitions from the <code class="language-plaintext highlighter-rouge">winnt.h</code> header:</p>

<ul>
  <li>Types:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">BYTE</code></li>
      <li><code class="language-plaintext highlighter-rouge">WORD</code></li>
      <li><code class="language-plaintext highlighter-rouge">DWORD</code></li>
      <li><code class="language-plaintext highlighter-rouge">QWORD</code></li>
      <li><code class="language-plaintext highlighter-rouge">LONG</code></li>
      <li><code class="language-plaintext highlighter-rouge">LONGLONG</code></li>
      <li><code class="language-plaintext highlighter-rouge">ULONGLONG</code></li>
    </ul>
  </li>
  <li>Constants:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_NT_OPTIONAL_HDR32_MAGIC</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_NT_OPTIONAL_HDR64_MAGIC</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DOS_SIGNATURE</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_EXPORT</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_IMPORT</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_RESOURCE</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_EXCEPTION</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_SECURITY</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_BASERELOC</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_DEBUG</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_TLS</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_IAT</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_SIZEOF_SHORT_NAME</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_SIZEOF_SECTION_HEADER</code></li>
    </ul>
  </li>
  <li>Structures:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DOS_HEADER</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER32</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER64</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS32</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS64</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_IMPORT_DESCRIPTOR</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_IMPORT_BY_NAME</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_BASE_RELOCATION</code></li>
      <li><code class="language-plaintext highlighter-rouge">IMAGE_SECTION_HEADER</code></li>
    </ul>
  </li>
</ul>

<p>I took these definitions from <code class="language-plaintext highlighter-rouge">winnt.h</code> and added them to a new header called <code class="language-plaintext highlighter-rouge">winntdef.h</code>.</p>

<p><code class="language-plaintext highlighter-rouge">winntdef.h</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BYTE</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">WORD</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">DWORD</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">QWORD</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">LONG</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__int64</span> <span class="n">LONGLONG</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">ULONGLONG</span><span class="p">;</span>

<span class="cp">#define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC       0x10b
#define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC       0x20b
#define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define ___IMAGE_DOS_SIGNATURE                 0x5A4D
</span>
<span class="cp">#define ___IMAGE_DIRECTORY_ENTRY_EXPORT          0
#define ___IMAGE_DIRECTORY_ENTRY_IMPORT          1
#define ___IMAGE_DIRECTORY_ENTRY_RESOURCE        2
#define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION       3
#define ___IMAGE_DIRECTORY_ENTRY_SECURITY        4
#define ___IMAGE_DIRECTORY_ENTRY_BASERELOC       5
#define ___IMAGE_DIRECTORY_ENTRY_DEBUG           6
#define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7
#define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8
#define ___IMAGE_DIRECTORY_ENTRY_TLS             9
#define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10
#define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11
#define ___IMAGE_DIRECTORY_ENTRY_IAT            12
#define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13
#define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14
</span>
<span class="cp">#define ___IMAGE_SIZEOF_SHORT_NAME              8
#define ___IMAGE_SIZEOF_SECTION_HEADER          40
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_DOS_HEADER</span> <span class="p">{</span>
    <span class="n">WORD</span>   <span class="n">e_magic</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_cblp</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_cp</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_crlc</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_cparhdr</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_minalloc</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_maxalloc</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_ss</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_sp</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_csum</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_ip</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_cs</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_lfarlc</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_ovno</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_res</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">WORD</span>   <span class="n">e_oemid</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_oeminfo</span><span class="p">;</span>
    <span class="n">WORD</span>   <span class="n">e_res2</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">LONG</span>   <span class="n">e_lfanew</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_DOS_HEADER</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_DOS_HEADER</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_DATA_DIRECTORY</span> <span class="p">{</span>
    <span class="n">DWORD</span>   <span class="n">VirtualAddress</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_DATA_DIRECTORY</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_DATA_DIRECTORY</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_OPTIONAL_HEADER</span> <span class="p">{</span>
    <span class="n">WORD</span>    <span class="n">Magic</span><span class="p">;</span>
    <span class="n">BYTE</span>    <span class="n">MajorLinkerVersion</span><span class="p">;</span>
    <span class="n">BYTE</span>    <span class="n">MinorLinkerVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfInitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfUninitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">AddressOfEntryPoint</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">BaseOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">BaseOfData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">ImageBase</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SectionAlignment</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">FileAlignment</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorSubsystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorSubsystemVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Win32VersionValue</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeaders</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">CheckSum</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">Subsystem</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">DllCharacteristics</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfStackReserve</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfStackCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeapReserve</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeapCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">LoaderFlags</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">NumberOfRvaAndSizes</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">___IMAGE_OPTIONAL_HEADER32</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_OPTIONAL_HEADER32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_OPTIONAL_HEADER64</span> <span class="p">{</span>
    <span class="n">WORD</span>        <span class="n">Magic</span><span class="p">;</span>
    <span class="n">BYTE</span>        <span class="n">MajorLinkerVersion</span><span class="p">;</span>
    <span class="n">BYTE</span>        <span class="n">MinorLinkerVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfInitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfUninitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">AddressOfEntryPoint</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">BaseOfCode</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">ImageBase</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SectionAlignment</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">FileAlignment</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorSubsystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorSubsystemVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">Win32VersionValue</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfHeaders</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">CheckSum</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">Subsystem</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">DllCharacteristics</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfStackReserve</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfStackCommit</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfHeapReserve</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfHeapCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">LoaderFlags</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">NumberOfRvaAndSizes</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">___IMAGE_OPTIONAL_HEADER64</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_OPTIONAL_HEADER64</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_FILE_HEADER</span> <span class="p">{</span>
    <span class="n">WORD</span>    <span class="n">Machine</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">NumberOfSections</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">TimeDateStamp</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">PointerToSymbolTable</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">NumberOfSymbols</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">SizeOfOptionalHeader</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">Characteristics</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_FILE_HEADER</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_FILE_HEADER</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_NT_HEADERS64</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Signature</span><span class="p">;</span>
    <span class="n">___IMAGE_FILE_HEADER</span> <span class="n">FileHeader</span><span class="p">;</span>
    <span class="n">___IMAGE_OPTIONAL_HEADER64</span> <span class="n">OptionalHeader</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_NT_HEADERS64</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_NT_HEADERS64</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_NT_HEADERS</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Signature</span><span class="p">;</span>
    <span class="n">___IMAGE_FILE_HEADER</span> <span class="n">FileHeader</span><span class="p">;</span>
    <span class="n">___IMAGE_OPTIONAL_HEADER32</span> <span class="n">OptionalHeader</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_NT_HEADERS32</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_NT_HEADERS32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_IMPORT_DESCRIPTOR</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">DWORD</span>   <span class="n">Characteristics</span><span class="p">;</span>
        <span class="n">DWORD</span>   <span class="n">OriginalFirstThunk</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">DUMMYUNIONNAME</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">TimeDateStamp</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">ForwarderChain</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Name</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">FirstThunk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_IMPORT_DESCRIPTOR</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_IMPORT_BY_NAME</span> <span class="p">{</span>
    <span class="n">WORD</span>    <span class="n">Hint</span><span class="p">;</span>
    <span class="kt">char</span>   <span class="n">Name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">}</span> <span class="n">___IMAGE_IMPORT_BY_NAME</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_IMPORT_BY_NAME</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_BASE_RELOCATION</span> <span class="p">{</span>
    <span class="n">DWORD</span>   <span class="n">VirtualAddress</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfBlock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_BASE_RELOCATION</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__IMAGE_SECTION_HEADER</span> <span class="p">{</span>
    <span class="n">BYTE</span>    <span class="n">Name</span><span class="p">[</span><span class="n">___IMAGE_SIZEOF_SHORT_NAME</span><span class="p">];</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">DWORD</span>   <span class="n">PhysicalAddress</span><span class="p">;</span>
        <span class="n">DWORD</span>   <span class="n">VirtualSize</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">Misc</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">VirtualAddress</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfRawData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">PointerToRawData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">PointerToRelocations</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">PointerToLinenumbers</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">NumberOfRelocations</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">NumberOfLinenumbers</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Characteristics</span><span class="p">;</span>
<span class="p">}</span> <span class="n">___IMAGE_SECTION_HEADER</span><span class="p">,</span> <span class="o">*</span> <span class="n">___PIMAGE_SECTION_HEADER</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="custom-structures">Custom Structures</h4>

<p>I defined the following structures to help with the parsing process.
They’re defined in the <code class="language-plaintext highlighter-rouge">PEFILE_CUSTOM_STRUCTS.h</code> header.</p>

<h5 id="rich_header_info">RICH_HEADER_INFO</h5>

<p>A structure to hold information about the Rich Header during processing.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__RICH_HEADER_INFO</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ptrToBuffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RICH_HEADER_INFO</span><span class="p">,</span> <span class="o">*</span> <span class="n">PRICH_HEADER_INFO</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">size</code>:</strong> Size of the Rich Header (in bytes).</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">ptrToBuffer</code>:</strong> A pointer to the buffer containing the data of the Rich Header.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">entries</code>:</strong> Number of entries in the Rich Header.</li>
</ul>

<h5 id="rich_header_entry">RICH_HEADER_ENTRY</h5>

<p>A structure to represent a Rich Header entry.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__RICH_HEADER_ENTRY</span> <span class="p">{</span>
    <span class="n">WORD</span>  <span class="n">prodID</span><span class="p">;</span>
    <span class="n">WORD</span>  <span class="n">buildID</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">useCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RICH_HEADER_ENTRY</span><span class="p">,</span> <span class="o">*</span> <span class="n">PRICH_HEADER_ENTRY</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">prodID</code>:</strong> Type ID / Product ID.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">buildID</code>:</strong> Build ID.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">useCount</code>:</strong> Use count.</li>
</ul>

<h5 id="rich_header">RICH_HEADER</h5>

<p>A structure to represent the Rich Header.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__RICH_HEADER</span> <span class="p">{</span>
    <span class="n">PRICH_HEADER_ENTRY</span> <span class="n">entries</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RICH_HEADER</span><span class="p">,</span> <span class="o">*</span> <span class="n">PRICH_HEADER</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">entries</code>:</strong> A pointer to a <code class="language-plaintext highlighter-rouge">RICH_HEADER_ENTRY</code> array.</li>
</ul>

<h5 id="ilt_entry_32">ILT_ENTRY_32</h5>

<p>A structure to represent a 32-bit ILT entry during processing.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__ILT_ENTRY_32</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">DWORD</span> <span class="n">ORDINAL</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">DWORD</span> <span class="n">HINT_NAME_TABE</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
        <span class="n">DWORD</span> <span class="n">ORDINAL_NAME_FLAG</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">FIELD_1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ILT_ENTRY_32</span><span class="p">,</span> <span class="o">*</span> <span class="n">PILT_ENTRY_32</span><span class="p">;</span>
</code></pre></div></div>

<p>The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.</p>

<h5 id="ilt_entry_64">ILT_ENTRY_64</h5>

<p>A structure to represent a 64-bit ILT entry during processing.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__ILT_ENTRY_64</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">DWORD</span> <span class="n">ORDINAL</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">DWORD</span> <span class="n">HINT_NAME_TABE</span> <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">FIELD_2</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">ORDINAL_NAME_FLAG</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ILT_ENTRY_64</span><span class="p">,</span> <span class="o">*</span> <span class="n">PILT_ENTRY_64</span><span class="p">;</span>
</code></pre></div></div>

<p>The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed.</p>

<h5 id="base_reloc_entry">BASE_RELOC_ENTRY</h5>

<p>A structure to represent a base relocation entry during processing.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">__BASE_RELOC_ENTRY</span> <span class="p">{</span>
    <span class="n">WORD</span> <span class="n">OFFSET</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">TYPE</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">BASE_RELOC_ENTRY</span><span class="p">,</span> <span class="o">*</span> <span class="n">PBASE_RELOC_ENTRY</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">OFFSET</code>:</strong> Relocation offset.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">TYPE</code>:</strong> Relocation type.</li>
</ul>

<h4 id="pefile">PEFILE</h4>

<p>Our parser will represent a PE file as an object type of either <code class="language-plaintext highlighter-rouge">PE32FILE</code> or <code class="language-plaintext highlighter-rouge">PE64FILE</code>.
<br>These 2 classes only differ in some member definitions but their functionality is identical.
<br>Throughout this post we will use the code from <code class="language-plaintext highlighter-rouge">PE64FILE</code>.</p>

<h5 id="definition">Definition</h5>

<p>The class is defined as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PE64FILE</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">PE64FILE</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_NAME</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">Ppefile</span><span class="p">);</span>
	
    <span class="kt">void</span> <span class="n">PrintInfo</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">NAME</span><span class="p">;</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">Ppefile</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_import_directory_count</span><span class="p">,</span> <span class="n">_import_directory_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_basreloc_directory_count</span><span class="p">;</span>

    <span class="c1">// HEADERS</span>
    <span class="n">___IMAGE_DOS_HEADER</span>     <span class="n">PEFILE_DOS_HEADER</span><span class="p">;</span>
    <span class="n">___IMAGE_NT_HEADERS64</span>   <span class="n">PEFILE_NT_HEADERS</span><span class="p">;</span>

    <span class="c1">// DOS HEADER</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_DOS_HEADER_EMAGIC</span><span class="p">;</span>
    <span class="n">LONG</span>  <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">;</span>

    <span class="c1">// RICH HEADER</span>
    <span class="n">RICH_HEADER_INFO</span> <span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">;</span>
    <span class="n">RICH_HEADER</span> <span class="n">PEFILE_RICH_HEADER</span><span class="p">;</span>

    <span class="c1">// NT_HEADERS.Signature</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_SIGNATURE</span><span class="p">;</span>

    <span class="c1">// NT_HEADERS.FileHeader</span>
    <span class="n">WORD</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_MACHINE</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER</span><span class="p">;</span>

    <span class="c1">// NT_HEADERS.OptionalHeader</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE</span><span class="p">;</span>
    <span class="n">ULONGLONG</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS</span><span class="p">;</span>

    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_EXPORT_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_IMPORT_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_RESOURCE_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_EXCEPTION_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_SECURITY_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_BASERELOC_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_DEBUG_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_ARCHITECTURE_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_GLOBALPTR_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_TLS_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_LOAD_CONFIG_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_BOUND_IMPORT_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_IAT_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_DELAY_IMPORT_DIRECTORY</span><span class="p">;</span>
    <span class="n">___IMAGE_DATA_DIRECTORY</span> <span class="n">PEFILE_COM_DESCRIPTOR_DIRECTORY</span><span class="p">;</span>

    <span class="c1">// SECTION HEADERS</span>
    <span class="n">___PIMAGE_SECTION_HEADER</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">;</span>

    <span class="c1">// IMPORT TABLE</span>
    <span class="n">___PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">PEFILE_IMPORT_TABLE</span><span class="p">;</span>
    
    <span class="c1">// BASE RELOCATION TABLE</span>
    <span class="n">___PIMAGE_BASE_RELOCATION</span> <span class="n">PEFILE_BASERELOC_TABLE</span><span class="p">;</span>

    <span class="c1">// FUNCTIONS</span>
    
    <span class="c1">// ADDRESS RESOLVERS</span>
    <span class="kt">int</span>  <span class="n">locate</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">VA</span><span class="p">);</span>
    <span class="n">DWORD</span> <span class="n">resolve</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">VA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

    <span class="c1">// PARSERS</span>
    <span class="kt">void</span> <span class="n">ParseFile</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseDOSHeader</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseNTHeaders</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseSectionHeaders</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseImportDirectory</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseBaseReloc</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">ParseRichHeader</span><span class="p">();</span>

    <span class="c1">// PRINT INFO</span>
    <span class="kt">void</span> <span class="n">PrintFileInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintDOSHeaderInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintRichHeaderInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintNTHeadersInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintSectionHeadersInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintImportTableInfo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">PrintBaseRelocationsInfo</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The only public member beside the class constructor is a function called <code class="language-plaintext highlighter-rouge">printInfo()</code> which will print information about the file.</p>

<p>The class constructor takes two parameters, a <code class="language-plaintext highlighter-rouge">char</code> array representing the name of the file and a file pointer to the actual data of the file.</p>

<p>After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later.</p>

<p>In the end is a series of methods definitions, first two methods are called <code class="language-plaintext highlighter-rouge">locate</code> and <code class="language-plaintext highlighter-rouge">resolve</code>, I will talk about them in a minute.
<br>The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts.</p>

<h5 id="constructor">Constructor</h5>

<p>The constructor of the class simply sets the file pointer and name variables, then it calls the <code class="language-plaintext highlighter-rouge">ParseFile()</code> function.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PE64FILE</span><span class="o">::</span><span class="n">PE64FILE</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_NAME</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">_Ppefile</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="n">NAME</span> <span class="o">=</span> <span class="n">_NAME</span><span class="p">;</span>
	<span class="n">Ppefile</span> <span class="o">=</span> <span class="n">_Ppefile</span><span class="p">;</span>

	<span class="n">ParseFile</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ParseFile()</code> function calls the other parser functions:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseFile</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// PARSE DOS HEADER</span>
	<span class="n">ParseDOSHeader</span><span class="p">();</span>

	<span class="c1">// PARSE RICH HEADER</span>
	<span class="n">ParseRichHeader</span><span class="p">();</span>

	<span class="c1">//PARSE NT HEADERS</span>
	<span class="n">ParseNTHeaders</span><span class="p">();</span>

	<span class="c1">// PARSE SECTION HEADERS</span>
	<span class="n">ParseSectionHeaders</span><span class="p">();</span>

	<span class="c1">// PARSE IMPORT DIRECTORY</span>
	<span class="n">ParseImportDirectory</span><span class="p">();</span>

	<span class="c1">// PARSE BASE RELOCATIONS</span>
	<span class="n">ParseBaseReloc</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="resolving-rvas">Resolving RVAs</h4>

<p>Most of the time, we’ll have a RVA that we’ll need to change to a file offset.
<br>The process of resolving an RVA can be outlined as follows:</p>

<ol>
  <li>
<strong>Determine which section range contains that RVA:</strong>
    <ul>
      <li>Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section.</li>
      <li>If the RVA exists within this range then it belongs to that section.</li>
    </ul>
  </li>
  <li>
<strong>Calculate the file offset:</strong>
    <ul>
      <li>Subtract the RVA from the section virtual address.</li>
      <li>Add that value to the raw data pointer of the section.</li>
    </ul>
  </li>
</ol>

<p>An example of this is locating a Data Directory.
<br>The <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code> structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address.</p>

<p>I wrote two functions to do this, first one to locate the virtual address (<code class="language-plaintext highlighter-rouge">locate()</code>), second one to resolve the address (<code class="language-plaintext highlighter-rouge">resolve()</code>).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">locate</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">VA</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">VA</span> <span class="o">&gt;=</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span>
			<span class="o">&amp;&amp;</span> <span class="n">VA</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Misc</span><span class="p">.</span><span class="n">VirtualSize</span><span class="p">)){</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">resolve</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">VA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">VA</span> <span class="o">-</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">)</span> <span class="o">+</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">PointerToRawData</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">locate()</code> iterates over the <code class="language-plaintext highlighter-rouge">PEFILE_SECTION_HEADERS</code> array, compares the RVA as described above, then it returns the index of the appropriate section header within the <code class="language-plaintext highlighter-rouge">PEFILE_SECTION_HEADERS</code> array.</p>

<p>Please note that in order for these functions to work we’ll need to parse out the section headers and fill the <code class="language-plaintext highlighter-rouge">PEFILE_SECTION_HEADERS</code> array first.
<br>We still haven’t discussed this part, but I wanted to talk about the address resolvers first.</p>

<h4 id="main-function">main function</h4>

<p>The main function of the program is fairly simple, it only does 2 things:</p>

<ul>
  <li>Create a file pointer to the given file, and validate that the file was read correctly.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">INITPARSE()</code> on the file, and based on the return value it decides between three actions:
    <ul>
      <li>Exit.</li>
      <li>Create a <code class="language-plaintext highlighter-rouge">PE32FILE</code> object, call <code class="language-plaintext highlighter-rouge">PrintInfo()</code>, close the file pointer then exit.</li>
      <li>Create a <code class="language-plaintext highlighter-rouge">PE64FILE</code> object, call <code class="language-plaintext highlighter-rouge">PrintInfo()</code>, close the file pointer then exit.</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">PrintInfo()</code> calls the other print info functions.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s [path to executable]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">FILE</span> <span class="o">*</span> <span class="n">PpeFile</span><span class="p">;</span>
	<span class="n">fopen_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PpeFile</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"rb"</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PpeFile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Can't open file.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INITPARSE</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">INITPARSE</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PE32FILE</span> <span class="n">PeFile_1</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PpeFile</span><span class="p">);</span>
		<span class="n">PeFile_1</span><span class="p">.</span><span class="n">PrintInfo</span><span class="p">();</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">INITPARSE</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PE64FILE</span> <span class="n">PeFile_1</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PpeFile</span><span class="p">);</span>
		<span class="n">PeFile_1</span><span class="p">.</span><span class="n">PrintInfo</span><span class="p">();</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="initparse">INITPARSE()</h4>

<p><code class="language-plaintext highlighter-rouge">INITPARSE()</code> is a function defined in <code class="language-plaintext highlighter-rouge">PEFILE.cpp</code>.
<br>Its only job is to validate that the given file is a PE file, then determine whether the file is <code class="language-plaintext highlighter-rouge">PE32</code> or <code class="language-plaintext highlighter-rouge">PE32+</code>.</p>

<p>It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error.</p>

<p>After validating the PE file, it sets the file position to (<code class="language-plaintext highlighter-rouge">DOS_HEADER.e_lfanew</code> + size of <code class="language-plaintext highlighter-rouge">DWORD</code> (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header.
<br>Then it reads a <code class="language-plaintext highlighter-rouge">WORD</code>, we know that the first <code class="language-plaintext highlighter-rouge">WORD</code> of the Optional Header is a magic value that indicates the file type, it then compares that word to <code class="language-plaintext highlighter-rouge">IMAGE_NT_OPTIONAL_HDR32_MAGIC</code> and <code class="language-plaintext highlighter-rouge">IMAGE_NT_OPTIONAL_HDR64_MAGIC</code>, and based on the comparison results it either returns <code class="language-plaintext highlighter-rouge">32</code> or <code class="language-plaintext highlighter-rouge">64</code> indicating <code class="language-plaintext highlighter-rouge">PE32</code> or <code class="language-plaintext highlighter-rouge">PE32+</code>, or it returns an error.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">INITPARSE</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">PpeFile</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">___IMAGE_DOS_HEADER</span> <span class="n">TMP_DOS_HEADER</span><span class="p">;</span>
	<span class="n">WORD</span> <span class="n">PEFILE_TYPE</span><span class="p">;</span>

	<span class="n">fseek</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TMP_DOS_HEADER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_DOS_HEADER</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PpeFile</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TMP_DOS_HEADER</span><span class="p">.</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">___IMAGE_DOS_SIGNATURE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Error. Not a PE file.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fseek</span><span class="p">(</span><span class="n">PpeFile</span><span class="p">,</span> <span class="p">(</span><span class="n">TMP_DOS_HEADER</span><span class="p">.</span><span class="n">e_lfanew</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_FILE_HEADER</span><span class="p">)),</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_TYPE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WORD</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PpeFile</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PEFILE_TYPE</span> <span class="o">==</span> <span class="n">___IMAGE_NT_OPTIONAL_HDR32_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PEFILE_TYPE</span> <span class="o">==</span> <span class="n">___IMAGE_NT_OPTIONAL_HDR64_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<hr>

<h3 id="parsing-dos-header">Parsing DOS Header</h3>

<h4 id="parsedosheader">ParseDOSHeader()</h4>

<p>Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member <code class="language-plaintext highlighter-rouge">PEFILE_DOS_HEADER</code>.
<br>From there we can access all of the struct members, however we’re only interested in <code class="language-plaintext highlighter-rouge">e_magic</code> and <code class="language-plaintext highlighter-rouge">e_lfanew</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseDOSHeader</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_DOS_HEADER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_DOS_HEADER</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

	<span class="n">PEFILE_DOS_HEADER_EMAGIC</span> <span class="o">=</span> <span class="n">PEFILE_DOS_HEADER</span><span class="p">.</span><span class="n">e_magic</span><span class="p">;</span>
	<span class="n">PEFILE_DOS_HEADER_LFANEW</span> <span class="o">=</span> <span class="n">PEFILE_DOS_HEADER</span><span class="p">.</span><span class="n">e_lfanew</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printdosheaderinfo">PrintDOSHeaderInfo()</h4>

<p>This function prints <code class="language-plaintext highlighter-rouge">e_magic</code> and <code class="language-plaintext highlighter-rouge">e_lfanew</code> values.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintDOSHeaderInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" DOS HEADER:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" -----------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" Magic: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_DOS_HEADER_EMAGIC</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" File address of new exe header: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/1.png" alt="" class="align-center"></p>

<hr>

<h3 id="parsing-rich-header">Parsing Rich Header</h3>

<h4 id="process">Process</h4>

<p>To parse out the Rich Header we’ll need to go through multiple steps.</p>

<p>We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place.</p>

<p>First of all, we need to locate the Rich Header.
<br>We don’t know the exact location, however we have everything we need to locate it.
<br>We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers.
<br>We also know that any Rich Header ends with a 32-bit value <code class="language-plaintext highlighter-rouge">Rich</code> followed by the XOR key.</p>

<p>One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed.
<br>A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the <code class="language-plaintext highlighter-rouge">Rich</code> sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header.</p>

<p>Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the <code class="language-plaintext highlighter-rouge">Rich</code> signature and keep XORing 4 bytes at a time until we reach the <code class="language-plaintext highlighter-rouge">DanS</code> signature which indicates the beginning of the Rich Header.</p>

<p>After obtaining the position and the size of the Rich Header, we can normally read and process the data.</p>

<h4 id="parserichheader">ParseRichHeader()</h4>

<p>This function starts by allocating a buffer on the heap, then it reads <code class="language-plaintext highlighter-rouge">e_lfanew</code> size of bytes from the beginning of the file and stores the data in the allocated buffer.</p>

<p>It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to <code class="language-plaintext highlighter-rouge">0x52</code> (<code class="language-plaintext highlighter-rouge">R</code>) and <code class="language-plaintext highlighter-rouge">0x69</code> (<code class="language-plaintext highlighter-rouge">i</code>).
<br>When the sequence is found, it stores the index in a variable then the loop breaks.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">char</span><span class="o">*</span> <span class="n">dataPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">];</span>
	<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">,</span> <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">index_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dataPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x52</span> <span class="o">&amp;&amp;</span> <span class="n">dataPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x69</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index_</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Error while parsing Rich Header."</span><span class="p">);</span>
		<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments <code class="language-plaintext highlighter-rouge">RichHeaderSize</code> by <code class="language-plaintext highlighter-rouge">4</code> until it reaches the <code class="language-plaintext highlighter-rouge">DanS</code> sequence.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">indexpointer</span> <span class="o">=</span> <span class="n">index_</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">RichHeaderSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">tmpchar</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpchar</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="n">indexpointer</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmpchar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpchar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">indexpointer</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">RichHeaderSize</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmpchar</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x61</span> <span class="o">&amp;&amp;</span> <span class="n">tmpchar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x44</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates <code class="language-plaintext highlighter-rouge">PEFILE_RICH_HEADER_INFO</code> with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">char</span><span class="o">*</span> <span class="n">RichHeaderPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">RichHeaderSize</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">RichHeaderPtr</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_</span> <span class="o">-</span> <span class="n">RichHeaderSize</span><span class="p">),</span> <span class="n">RichHeaderSize</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RichHeaderSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">RichHeaderSize</span><span class="p">;</span>
	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">ptrToBuffer</span> <span class="o">=</span> <span class="n">RichHeaderPtr</span><span class="p">;</span>
	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">RichHeaderSize</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">delete</span><span class="p">[]</span> <span class="n">dataPtr</span><span class="p">;</span>
</code></pre></div></div>

<p>The rest of the function reads each entry of the Rich Header and updates <code class="language-plaintext highlighter-rouge">PEFILE_RICH_HEADER</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RICH_HEADER_ENTRY</span><span class="p">[</span><span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RichHeaderSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WORD</span> <span class="n">PRODID</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">WORD</span> <span class="n">BUILDID</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">USECOUNT</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
		<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">PRODID</span><span class="p">,</span>
			<span class="n">BUILDID</span><span class="p">,</span>
			<span class="n">USECOUNT</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">&gt;=</span> <span class="n">RichHeaderSize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x00000000</span> <span class="p">};</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">delete</span><span class="p">[]</span> <span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">ptrToBuffer</span><span class="p">;</span>
</code></pre></div></div>

<p>Here’s the full function:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseRichHeader</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="kt">char</span><span class="o">*</span> <span class="n">dataPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">];</span>
	<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">,</span> <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">index_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PEFILE_DOS_HEADER_LFANEW</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dataPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x52</span> <span class="o">&amp;&amp;</span> <span class="n">dataPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x69</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index_</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Error while parsing Rich Header."</span><span class="p">);</span>
		<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">indexpointer</span> <span class="o">=</span> <span class="n">index_</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">RichHeaderSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">tmpchar</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpchar</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="n">indexpointer</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmpchar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpchar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">indexpointer</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">RichHeaderSize</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmpchar</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x61</span> <span class="o">&amp;&amp;</span> <span class="n">tmpchar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x44</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">char</span><span class="o">*</span> <span class="n">RichHeaderPtr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">RichHeaderSize</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">RichHeaderPtr</span><span class="p">,</span> <span class="n">dataPtr</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_</span> <span class="o">-</span> <span class="n">RichHeaderSize</span><span class="p">),</span> <span class="n">RichHeaderSize</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RichHeaderSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">key</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">RichHeaderSize</span><span class="p">;</span>
	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">ptrToBuffer</span> <span class="o">=</span> <span class="n">RichHeaderPtr</span><span class="p">;</span>
	<span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">RichHeaderSize</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">delete</span><span class="p">[]</span> <span class="n">dataPtr</span><span class="p">;</span>

	<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RICH_HEADER_ENTRY</span><span class="p">[</span><span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RichHeaderSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WORD</span> <span class="n">PRODID</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">WORD</span> <span class="n">BUILDID</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">USECOUNT</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">RichHeaderPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
		<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">PRODID</span><span class="p">,</span>
			<span class="n">BUILDID</span><span class="p">,</span>
			<span class="n">USECOUNT</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">&gt;=</span> <span class="n">RichHeaderSize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x00000000</span> <span class="p">};</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">delete</span><span class="p">[]</span> <span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">ptrToBuffer</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printrichheaderinfo">PrintRichHeaderInfo()</h4>

<p>This function iterates over each entry in <code class="language-plaintext highlighter-rouge">PEFILE_RICH_HEADER</code> and prints its value.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintRichHeaderInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" RICH HEADER:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" ------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PEFILE_RICH_HEADER_INFO</span><span class="p">.</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">" 0x%X 0x%X 0x%X: %d.%d.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buildID</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prodID</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">useCount</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buildID</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prodID</span><span class="p">,</span>
			<span class="n">PEFILE_RICH_HEADER</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">useCount</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/2.png" alt="" class="align-center"></p>

<hr>

<h3 id="parsing-nt-headers">Parsing NT Headers</h3>

<h4 id="parsentheaders">ParseNTHeaders()</h4>

<p>Similar to the DOS Header, all we need to do is to read from <code class="language-plaintext highlighter-rouge">e_lfanew</code> an amount of bytes equal to the size of <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS</code>.</p>

<p>After that we can parse out the contents of the File Header and the Optional Header.</p>

<p>The Optional Header contains an array of <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code> structures which we care about.
<br>To parse out this information, we can use the <code class="language-plaintext highlighter-rouge">IMAGE_DIRECTORY_[...]</code> constants defined in <code class="language-plaintext highlighter-rouge">winnt.h</code> as array indexes to access the corresponding <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code> structure of each Data Directory.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseNTHeaders</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">PEFILE_DOS_HEADER</span><span class="p">.</span><span class="n">e_lfanew</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_NT_HEADERS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PEFILE_NT_HEADERS</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

	<span class="n">PEFILE_NT_HEADERS_SIGNATURE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">Signature</span><span class="p">;</span>

	<span class="n">PEFILE_NT_HEADERS_FILE_HEADER_MACHINE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">Machine</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">SizeOfOptionalHeader</span><span class="p">;</span>

	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfCode</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfInitializedData</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfUninitializedData</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">AddressOfEntryPoint</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">BaseOfCode</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SectionAlignment</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">FileAlignment</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfImage</span><span class="p">;</span>
	<span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfHeaders</span><span class="p">;</span>

	<span class="n">PEFILE_EXPORT_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">];</span>
	<span class="n">PEFILE_IMPORT_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class="p">];</span>
	<span class="n">PEFILE_RESOURCE_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_RESOURCE</span><span class="p">];</span>
	<span class="n">PEFILE_EXCEPTION_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_EXCEPTION</span><span class="p">];</span>
	<span class="n">PEFILE_SECURITY_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_SECURITY</span><span class="p">];</span>
	<span class="n">PEFILE_BASERELOC_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_BASERELOC</span><span class="p">];</span>
	<span class="n">PEFILE_DEBUG_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_DEBUG</span><span class="p">];</span>
	<span class="n">PEFILE_ARCHITECTURE_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</span><span class="p">];</span>
	<span class="n">PEFILE_GLOBALPTR_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_GLOBALPTR</span><span class="p">];</span>
	<span class="n">PEFILE_TLS_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_TLS</span><span class="p">];</span>
	<span class="n">PEFILE_LOAD_CONFIG_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</span><span class="p">];</span>
	<span class="n">PEFILE_BOUND_IMPORT_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</span><span class="p">];</span>
	<span class="n">PEFILE_IAT_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_IAT</span><span class="p">];</span>
	<span class="n">PEFILE_DELAY_IMPORT_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</span><span class="p">];</span>
	<span class="n">PEFILE_COM_DESCRIPTOR_DIRECTORY</span> <span class="o">=</span> <span class="n">PEFILE_NT_HEADERS</span><span class="p">.</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</span><span class="p">];</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printntheadersinfo">PrintNTHeadersInfo()</h4>

<p>This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintNTHeadersInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" NT HEADERS:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" -----------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">" PE Signature: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_SIGNATURE</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> File Header:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Machine: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_MACHINE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Number of sections: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of optional header: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Optional Header:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Magic: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of code section: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of initialized data: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of uninitialized data: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Address of entry point: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   RVA of start of code section: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Desired image base: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Section alignment: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   File alignment: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of image: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"   Size of headers: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Data Directories:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">   * Export Directory:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"       RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_EXPORT_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"       Size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_EXPORT_DIRECTORY</span><span class="p">.</span><span class="n">Size</span><span class="p">);</span>
	<span class="p">.</span>
	<span class="p">.</span>
	<span class="p">[</span><span class="n">REDACTED</span><span class="p">]</span>
	<span class="p">.</span>
	<span class="p">.</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">   * COM Runtime Descriptor:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"       RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_COM_DESCRIPTOR_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"       Size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_COM_DESCRIPTOR_DIRECTORY</span><span class="p">.</span><span class="n">Size</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/3.png" alt="" class="align-center"></p>

<hr>

<h3 id="parsing-section-headers">Parsing Section Headers</h3>

<h4 id="parsesectionheaders">ParseSectionHeaders()</h4>

<p>This function starts by assigning the <code class="language-plaintext highlighter-rouge">PEFILE_SECTION_HEADERS</code> class member to a pointer to an <code class="language-plaintext highlighter-rouge">IMAGE_SECTION_HEADER</code> array of the count of <code class="language-plaintext highlighter-rouge">PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS</code>.</p>

<p>Then it goes into a loop of <code class="language-plaintext highlighter-rouge">PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS</code> iterations where in each iteration it changes the file offset to (<code class="language-plaintext highlighter-rouge">e_lfanew</code> + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of <code class="language-plaintext highlighter-rouge">PEFILE_SECTION_HEADERS</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseSectionHeaders</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">PEFILE_SECTION_HEADERS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">___IMAGE_SECTION_HEADER</span><span class="p">[</span><span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PEFILE_DOS_HEADER</span><span class="p">.</span><span class="n">e_lfanew</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PEFILE_NT_HEADERS</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">___IMAGE_SIZEOF_SECTION_HEADER</span><span class="p">);</span>
		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">___IMAGE_SIZEOF_SECTION_HEADER</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printsectionheadersinfo">PrintSectionHeadersInfo()</h4>

<p>This function loops over the Section Headers array (filled by <code class="language-plaintext highlighter-rouge">ParseSectionHeaders()</code>), and it prints information about each section.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintSectionHeadersInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" SECTION HEADERS:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" ----------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   * %.8s:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Name</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"        VirtualAddress: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"        VirtualSize: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Misc</span><span class="p">.</span><span class="n">VirtualSize</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"        PointerToRawData: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">PointerToRawData</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"        SizeOfRawData: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfRawData</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"        Characteristics: 0x%X</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_SECTION_HEADERS</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/4.png" alt="" class="align-center"></p>

<hr>

<h3 id="parsing-imports">Parsing Imports</h3>

<h4 id="parseimportdirectory">ParseImportDirectory()</h4>

<p>To parse out the Import Directory Table we need to determine the count of <code class="language-plaintext highlighter-rouge">IMAGE_IMPORT_DESCRIPTOR</code>s first.</p>

<p>This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor.
<br>In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks.
<br>Otherwise it increments <code class="language-plaintext highlighter-rouge">_import_directory_count</code> and the loop continues.</p>

<p>After finding the size of the Import Directory, the function assigns the <code class="language-plaintext highlighter-rouge">PEFILE_IMPORT_TABLE</code> class member to a pointer to an <code class="language-plaintext highlighter-rouge">IMAGE_IMPORT_DESCRIPTOR</code> array of the count of <code class="language-plaintext highlighter-rouge">_import_directory_count</code> then goes into another loop similar to the one we’ve seen in <code class="language-plaintext highlighter-rouge">ParseSectionHeaders()</code> to parse out the import descriptors.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseImportDirectory</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">DWORD</span> <span class="n">_import_directory_address</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">PEFILE_IMPORT_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">PEFILE_IMPORT_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">));</span>
	<span class="n">_import_directory_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">___IMAGE_IMPORT_DESCRIPTOR</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">_import_directory_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">))</span> <span class="o">+</span> <span class="n">_import_directory_address</span><span class="p">;</span>
		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">Name</span> <span class="o">==</span> <span class="mh">0x00000000</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="p">.</span><span class="n">FirstThunk</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_import_directory_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">_import_directory_size</span> <span class="o">=</span> <span class="n">_import_directory_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">_import_directory_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PEFILE_IMPORT_TABLE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">[</span><span class="n">_import_directory_count</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_import_directory_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">))</span> <span class="o">+</span> <span class="n">_import_directory_address</span><span class="p">;</span>
		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_DESCRIPTOR</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printimporttableinfo">PrintImportTableInfo()</h4>

<p>After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions.
<br>This is done by the <code class="language-plaintext highlighter-rouge">PrintImportTableInfo()</code> function.</p>

<p>This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not.</p>

<p>After that it resolves the file offset of the ILT then it parses out each ILT entry.
<br>If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint.</p>

<p>If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts.</p>

<p>We’ve discussed the details about this in the <a href="/win-internals/pe6/">PE imports post</a>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintImportTableInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" IMPORT TABLE:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" ----------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_import_directory_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DWORD</span> <span class="n">NameAddr</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Name</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Name</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">NameSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="p">(</span><span class="n">NameAddr</span> <span class="o">+</span> <span class="n">NameSize</span><span class="p">),</span> <span class="n">SEEK_SET</span><span class="p">);</span>
			<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">NameSize</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="kt">char</span><span class="o">*</span> <span class="n">Name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">NameSize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">NameAddr</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="p">(</span><span class="n">NameSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   * %s:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Name</span><span class="p">);</span>
		<span class="k">delete</span><span class="p">[]</span> <span class="n">Name</span><span class="p">;</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"       ILT RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DUMMYUNIONNAME</span><span class="p">.</span><span class="n">OriginalFirstThunk</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"       IAT RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FirstThunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">TimeDateStamp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"       Bound: FALSE</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">TimeDateStamp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"       Bound: TRUE</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

		<span class="n">DWORD</span> <span class="n">ILTAddr</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DUMMYUNIONNAME</span><span class="p">.</span><span class="n">OriginalFirstThunk</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">PEFILE_IMPORT_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DUMMYUNIONNAME</span><span class="p">.</span><span class="n">OriginalFirstThunk</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">entrycounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ILT_ENTRY_64</span> <span class="n">entry</span><span class="p">;</span>

			<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="p">(</span><span class="n">ILTAddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">entrycounter</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">QWORD</span><span class="p">))),</span> <span class="n">SEEK_SET</span><span class="p">);</span>
			<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ILT_ENTRY_64</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

			<span class="n">BYTE</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">ORDINAL_NAME_FLAG</span><span class="p">;</span>
			<span class="n">DWORD</span> <span class="n">HintRVA</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
			<span class="n">WORD</span> <span class="n">ordinal</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">HintRVA</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">FIELD_2</span><span class="p">.</span><span class="n">HINT_NAME_TABE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ordinal</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">FIELD_2</span><span class="p">.</span><span class="n">ORDINAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mh">0x0</span> <span class="o">&amp;&amp;</span> <span class="n">HintRVA</span> <span class="o">==</span> <span class="mh">0x0</span> <span class="o">&amp;&amp;</span> <span class="n">ordinal</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">       Entry:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">___IMAGE_IMPORT_BY_NAME</span> <span class="n">hint</span><span class="p">;</span>

				<span class="n">DWORD</span> <span class="n">HintAddr</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">HintRVA</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">HintRVA</span><span class="p">));</span>
				<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">HintAddr</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
				<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hint</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_IMPORT_BY_NAME</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"         Name: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hint</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"         Hint RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HintRVA</span><span class="p">);</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"         Hint: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hint</span><span class="p">.</span><span class="n">Hint</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"         Ordinal: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ordinal</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">entrycounter</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">   ----------------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/5.png" alt="" class="align-center"></p>

<hr>

<h3 id="parsing-base-relocations">Parsing Base Relocations</h3>

<h4 id="parsebasereloc">ParseBaseReloc()</h4>

<p>This function follows the same process we’ve seen in <code class="language-plaintext highlighter-rouge">ParseImportDirectory()</code>.
<br>It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each <code class="language-plaintext highlighter-rouge">IMAGE_BASE_RELOCATION</code> structure in <code class="language-plaintext highlighter-rouge">PEFILE_BASERELOC_TABLE</code>.
<br>One thing to note here that is different from what we’ve seen in <code class="language-plaintext highlighter-rouge">ParseImportDirectory()</code> is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of <code class="language-plaintext highlighter-rouge">SizeOfBlock</code> of each block in each iteration.
<br>We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">ParseBaseReloc</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">DWORD</span> <span class="n">_basereloc_directory_address</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">PEFILE_BASERELOC_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">PEFILE_BASERELOC_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">));</span>
	<span class="n">_basreloc_directory_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_basereloc_size_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">___IMAGE_BASE_RELOCATION</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">_basereloc_size_counter</span> <span class="o">+</span> <span class="n">_basereloc_directory_address</span><span class="p">);</span>

		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">VirtualAddress</span> <span class="o">==</span> <span class="mh">0x00000000</span> <span class="o">&amp;&amp;</span>
			<span class="n">tmp</span><span class="p">.</span><span class="n">SizeOfBlock</span> <span class="o">==</span> <span class="mh">0x00000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">_basreloc_directory_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">_basereloc_size_counter</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">SizeOfBlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PEFILE_BASERELOC_TABLE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">[</span><span class="n">_basreloc_directory_count</span><span class="p">];</span>

	<span class="n">_basereloc_size_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_basreloc_directory_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">_basereloc_directory_address</span> <span class="o">+</span> <span class="n">_basereloc_size_counter</span><span class="p">;</span>
		<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
		<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PEFILE_BASERELOC_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>
		<span class="n">_basereloc_size_counter</span> <span class="o">+=</span> <span class="n">PEFILE_BASERELOC_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfBlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h4 id="printbaserelocationinfo">PrintBaseRelocationInfo()</h4>

<p>This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of <code class="language-plaintext highlighter-rouge">IMAGE_BASE_RELOCATION</code> from the block size then dividing that by the size of a WORD).
<br>After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them.</p>

<p>We’ve discussed the details about this in the <a href="/win-internals/pe7/">PE base relocations post</a>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">PE64FILE</span><span class="o">::</span><span class="n">PrintBaseRelocationsInfo</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">" BASE RELOCATIONS TABLE:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" -----------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">szCounter</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_basreloc_directory_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">DWORD</span> <span class="n">PAGERVA</span><span class="p">,</span> <span class="n">BLOCKSIZE</span><span class="p">,</span> <span class="n">BASE_RELOC_ADDR</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ENTRIES</span><span class="p">;</span>

		<span class="n">BASE_RELOC_ADDR</span> <span class="o">=</span> <span class="n">resolve</span><span class="p">(</span><span class="n">PEFILE_BASERELOC_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">,</span> <span class="n">locate</span><span class="p">(</span><span class="n">PEFILE_BASERELOC_DIRECTORY</span><span class="p">.</span><span class="n">VirtualAddress</span><span class="p">));</span>
		<span class="n">PAGERVA</span> <span class="o">=</span> <span class="n">PEFILE_BASERELOC_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">;</span>
		<span class="n">BLOCKSIZE</span> <span class="o">=</span> <span class="n">PEFILE_BASERELOC_TABLE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfBlock</span><span class="p">;</span>
		<span class="n">ENTRIES</span> <span class="o">=</span> <span class="p">(</span><span class="n">BLOCKSIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">___IMAGE_BASE_RELOCATION</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WORD</span><span class="p">);</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">   Block 0x%X: </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"     Page RVA: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">PAGERVA</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"     Block size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">BLOCKSIZE</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"     Number of entries: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ENTRIES</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">     Entries:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">BASE_RELOC_ENTRY</span> <span class="n">entry</span><span class="p">;</span>

			<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">BASE_RELOC_ADDR</span> <span class="o">+</span> <span class="n">szCounter</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WORD</span><span class="p">)));</span>

			<span class="n">fseek</span><span class="p">(</span><span class="n">Ppefile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
			<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WORD</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ppefile</span><span class="p">);</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">       * Value: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"         Relocation Type: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">TYPE</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"         Offset: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">OFFSET</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">   ----------------------</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">szCounter</span> <span class="o">+=</span> <span class="n">BLOCKSIZE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/wininternals/pe8/6.png" alt="" class="align-center"></p>

<hr>

<h3 id="conclusion">Conclusion</h3>

<p>Here’s the full output after running the parser on a file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Desktop&gt;.\PE-Parser.exe .\SimpleApp64.exe


 FILE: .\SimpleApp64.exe
 TYPE: 0x20B (PE32+)

 ----------------------------------

 DOS HEADER:
 -----------

 Magic: 0x5A4D
 File address of new exe header: 0x100

 ----------------------------------

 RICH HEADER:
 ------------

 0x7809 0x93 0xA: 30729.147.10
 0x6FCB 0x101 0x2: 28619.257.2
 0x6FCB 0x105 0x11: 28619.261.17
 0x6FCB 0x104 0xA: 28619.260.10
 0x6FCB 0x103 0x3: 28619.259.3
 0x685B 0x101 0x5: 26715.257.5
 0x0 0x1 0x30: 0.1.48
 0x7086 0x109 0x1: 28806.265.1
 0x7086 0xFF 0x1: 28806.255.1
 0x7086 0x102 0x1: 28806.258.1

 ----------------------------------

 NT HEADERS:
 -----------

 PE Signature: 0x4550

 File Header:

   Machine: 0x8664
   Number of sections: 0x6
   Size of optional header: 0xF0

 Optional Header:

   Magic: 0x20B
   Size of code section: 0xE00
   Size of initialized data: 0x1E00
   Size of uninitialized data: 0x0
   Address of entry point: 0x12C4
   RVA of start of code section: 0x1000
   Desired image base: 0x40000000
   Section alignment: 0x1000
   File alignment: 0x200
   Size of image: 0x7000
   Size of headers: 0x400

 Data Directories:

   * Export Directory:
       RVA: 0x0
       Size: 0x0

   * Import Directory:
       RVA: 0x27AC
       Size: 0xB4

   * Resource Directory:
       RVA: 0x5000
       Size: 0x1E0

   * Exception Directory:
       RVA: 0x4000
       Size: 0x168

   * Security Directory:
       RVA: 0x0
       Size: 0x0

   * Base Relocation Table:
       RVA: 0x6000
       Size: 0x28

   * Debug Directory:
       RVA: 0x2248
       Size: 0x70

   * Architecture Specific Data:
       RVA: 0x0
       Size: 0x0

   * RVA of GlobalPtr:
       RVA: 0x0
       Size: 0x0

   * TLS Directory:
       RVA: 0x0
       Size: 0x0

   * Load Configuration Directory:
       RVA: 0x22C0
       Size: 0x130

   * Bound Import Directory:
       RVA: 0x0
       Size: 0x0

   * Import Address Table:
       RVA: 0x2000
       Size: 0x198

   * Delay Load Import Descriptors:
       RVA: 0x0
       Size: 0x0

   * COM Runtime Descriptor:
       RVA: 0x0
       Size: 0x0

 ----------------------------------

 SECTION HEADERS:
 ----------------

   * .text:
        VirtualAddress: 0x1000
        VirtualSize: 0xD2C
        PointerToRawData: 0x400
        SizeOfRawData: 0xE00
        Characteristics: 0x60000020

   * .rdata:
        VirtualAddress: 0x2000
        VirtualSize: 0xE3C
        PointerToRawData: 0x1200
        SizeOfRawData: 0x1000
        Characteristics: 0x40000040

   * .data:
        VirtualAddress: 0x3000
        VirtualSize: 0x638
        PointerToRawData: 0x2200
        SizeOfRawData: 0x200
        Characteristics: 0xC0000040

   * .pdata:
        VirtualAddress: 0x4000
        VirtualSize: 0x168
        PointerToRawData: 0x2400
        SizeOfRawData: 0x200
        Characteristics: 0x40000040

   * .rsrc:
        VirtualAddress: 0x5000
        VirtualSize: 0x1E0
        PointerToRawData: 0x2600
        SizeOfRawData: 0x200
        Characteristics: 0x40000040

   * .reloc:
        VirtualAddress: 0x6000
        VirtualSize: 0x28
        PointerToRawData: 0x2800
        SizeOfRawData: 0x200
        Characteristics: 0x42000040


 ----------------------------------

 IMPORT TABLE:
 ----------------

   * USER32.dll:
       ILT RVA: 0x28E0
       IAT RVA: 0x2080
       Bound: FALSE


       Entry:
         Name: MessageBoxA
         Hint RVA: 0x29F8
         Hint: 0x283

   ----------------------

   * VCRUNTIME140.dll:
       ILT RVA: 0x28F0
       IAT RVA: 0x2090
       Bound: FALSE


       Entry:
         Name: memset
         Hint RVA: 0x2A5E
         Hint: 0x3E

       Entry:
         Name: __current_exception_context
         Hint RVA: 0x2A40
         Hint: 0x1C

       Entry:
         Name: __current_exception
         Hint RVA: 0x2A2A
         Hint: 0x1B

       Entry:
         Name: __C_specific_handler
         Hint RVA: 0x2A12
         Hint: 0x8

   ----------------------

   * api-ms-win-crt-runtime-l1-1-0.dll:
       ILT RVA: 0x2948
       IAT RVA: 0x20E8
       Bound: FALSE


       Entry:
         Name: _crt_atexit
         Hint RVA: 0x2C12
         Hint: 0x1E

       Entry:
         Name: terminate
         Hint RVA: 0x2C20
         Hint: 0x67

       Entry:
         Name: _exit
         Hint RVA: 0x2B30
         Hint: 0x23

       Entry:
         Name: _register_thread_local_exe_atexit_callback
         Hint RVA: 0x2B76
         Hint: 0x3D

       Entry:
         Name: _c_exit
         Hint RVA: 0x2B6C
         Hint: 0x15

       Entry:
         Name: exit
         Hint RVA: 0x2B28
         Hint: 0x55

       Entry:
         Name: _initterm_e
         Hint RVA: 0x2B1A
         Hint: 0x37

       Entry:
         Name: _initterm
         Hint RVA: 0x2B0E
         Hint: 0x36

       Entry:
         Name: _get_initial_narrow_environment
         Hint RVA: 0x2AEC
         Hint: 0x28

       Entry:
         Name: _initialize_narrow_environment
         Hint RVA: 0x2ACA
         Hint: 0x33

       Entry:
         Name: _configure_narrow_argv
         Hint RVA: 0x2AB0
         Hint: 0x18

       Entry:
         Name: _initialize_onexit_table
         Hint RVA: 0x2BDA
         Hint: 0x34

       Entry:
         Name: _set_app_type
         Hint RVA: 0x2A8C
         Hint: 0x42

       Entry:
         Name: _seh_filter_exe
         Hint RVA: 0x2A7A
         Hint: 0x40

       Entry:
         Name: _cexit
         Hint RVA: 0x2B62
         Hint: 0x16

       Entry:
         Name: __p___argv
         Hint RVA: 0x2B54
         Hint: 0x5

       Entry:
         Name: __p___argc
         Hint RVA: 0x2B46
         Hint: 0x4

       Entry:
         Name: _register_onexit_function
         Hint RVA: 0x2BF6
         Hint: 0x3C

   ----------------------

   * api-ms-win-crt-math-l1-1-0.dll:
       ILT RVA: 0x2938
       IAT RVA: 0x20D8
       Bound: FALSE


       Entry:
         Name: __setusermatherr
         Hint RVA: 0x2A9C
         Hint: 0x9

   ----------------------

   * api-ms-win-crt-stdio-l1-1-0.dll:
       ILT RVA: 0x29E0
       IAT RVA: 0x2180
       Bound: FALSE


       Entry:
         Name: __p__commode
         Hint RVA: 0x2BCA
         Hint: 0x1

       Entry:
         Name: _set_fmode
         Hint RVA: 0x2B38
         Hint: 0x54

   ----------------------

   * api-ms-win-crt-locale-l1-1-0.dll:
       ILT RVA: 0x2928
       IAT RVA: 0x20C8
       Bound: FALSE


       Entry:
         Name: _configthreadlocale
         Hint RVA: 0x2BA4
         Hint: 0x8

   ----------------------

   * api-ms-win-crt-heap-l1-1-0.dll:
       ILT RVA: 0x2918
       IAT RVA: 0x20B8
       Bound: FALSE


       Entry:
         Name: _set_new_mode
         Hint RVA: 0x2BBA
         Hint: 0x16

   ----------------------


 ----------------------------------

 BASE RELOCATIONS TABLE:
 -----------------------

   Block 0x0:
     Page RVA: 0x2000
     Block size: 0x28
     Number of entries: 0x10

     Entries:

       * Value: 0xA198
         Relocation Type: 0xA
         Offset: 0x198

       * Value: 0xA1A0
         Relocation Type: 0xA
         Offset: 0x1A0

       * Value: 0xA1A8
         Relocation Type: 0xA
         Offset: 0x1A8

       * Value: 0xA1B0
         Relocation Type: 0xA
         Offset: 0x1B0

       * Value: 0xA1B8
         Relocation Type: 0xA
         Offset: 0x1B8

       * Value: 0xA1C8
         Relocation Type: 0xA
         Offset: 0x1C8

       * Value: 0xA1E0
         Relocation Type: 0xA
         Offset: 0x1E0

       * Value: 0xA1E8
         Relocation Type: 0xA
         Offset: 0x1E8

       * Value: 0xA220
         Relocation Type: 0xA
         Offset: 0x220

       * Value: 0xA228
         Relocation Type: 0xA
         Offset: 0x228

       * Value: 0xA318
         Relocation Type: 0xA
         Offset: 0x318

       * Value: 0xA330
         Relocation Type: 0xA
         Offset: 0x330

       * Value: 0xA338
         Relocation Type: 0xA
         Offset: 0x338

       * Value: 0xA3D8
         Relocation Type: 0xA
         Offset: 0x3D8

       * Value: 0xA3E0
         Relocation Type: 0xA
         Offset: 0x3E0

       * Value: 0xA3E8
         Relocation Type: 0xA
         Offset: 0x3E8

   ----------------------


 ----------------------------------
</code></pre></div></div>

<p>I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts.
<br>I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated.</p>

<p>Thanks for reading.</p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-10-29T03:00:00+02:00">October 29, 2021</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/win-internals/pe7/" class="pagination--pager" title="A dive into the PE file format - PE file structure - Part 6: PE Base Relocations
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
      
  
      
  
      
    </ul>
  </div>
      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>







  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-97164925-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-97164925-2', { 'anonymize_ip': false});
</script>









  </body>
</html>
